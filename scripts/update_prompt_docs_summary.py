#!/usr/bin/env python3
"""Generate a markdown summary of prompt documentation across repositories."""
from __future__ import annotations

import argparse
import itertools
import re
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Sequence

SUMMARY_HEADER = "# Prompt documentation summary"
SUMMARY_FOOTER = (
    "Generated by `scripts/update_prompt_docs_summary.py`.\n"
    "Update `dict/prompt-doc-repos.txt` to control which repositories appear."
)
REPO_LIST_HELP = " ".join(
    [
        "Path to a text file listing repositories to scan",
        "(one per line).",
    ]
)


@dataclass(slots=True)
class PromptDoc:
    """Metadata extracted from a prompt documentation file."""

    repo_display: str
    repo_path: Path
    relative_path: Path
    title: str
    type_value: str
    description: str


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--repos-from",
        required=True,
        type=Path,
        help=REPO_LIST_HELP,
    )
    parser.add_argument(
        "--out",
        required=True,
        type=Path,
        help="Destination markdown file for the generated summary.",
    )
    return parser.parse_args(argv)


def read_repo_paths(list_path: Path) -> List[Path]:
    """Return repository paths listed in ``list_path``.

    Lines starting with ``#`` and blank entries are ignored.
    """

    base_dir = Path.cwd()
    repo_paths: List[Path] = []
    for raw_line in list_path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        expanded = Path(line).expanduser()
        if not expanded.is_absolute():
            expanded = (base_dir / expanded).resolve()
        repo_paths.append(expanded)
    return repo_paths


def collect_prompt_docs(repo_paths: Iterable[Path]) -> List[PromptDoc]:
    """Collect prompt documentation metadata from the provided repositories."""

    docs: List[PromptDoc] = []
    for repo_path in repo_paths:
        prompts_root = repo_path / "docs" / "prompts"
        if not prompts_root.exists():
            continue
        repo_display = repo_path.name or str(repo_path)
        for prompt_path in sorted(prompts_root.rglob("*.md")):
            prompt = _parse_prompt_doc(repo_display, repo_path, prompt_path)
            if prompt is not None:
                docs.append(prompt)
    docs.sort(
        key=lambda doc: (
            doc.repo_display.lower(),
            doc.relative_path.as_posix(),
        )
    )
    return docs


def _parse_prompt_doc(
    repo_display: str, repo_path: Path, prompt_path: Path
) -> PromptDoc | None:
    text = prompt_path.read_text(encoding="utf-8")
    lines = text.splitlines()
    content_lines = _strip_frontmatter(lines)

    title = _extract_title(content_lines)
    if title is None:
        title = prompt_path.stem.replace("-", " ").title()
    type_value = _extract_type(content_lines) or "unspecified"
    description = _extract_description(content_lines)
    if description is None:
        description = "No description provided."

    try:
        relative_path = prompt_path.relative_to(repo_path)
    except ValueError:
        relative_path = prompt_path

    return PromptDoc(
        repo_display=repo_display,
        repo_path=repo_path,
        relative_path=relative_path,
        title=title,
        type_value=type_value,
        description=description,
    )


def _strip_frontmatter(lines: List[str]) -> List[str]:
    if lines and lines[0].strip() == "---":
        try:
            closing_index = lines[1:].index("---") + 2
        except ValueError:
            return lines
        return lines[closing_index:]
    return lines


def _extract_title(lines: List[str]) -> str | None:
    for line in lines:
        stripped = line.strip()
        if stripped.startswith("#"):
            return stripped.lstrip("#").strip()
    return None


def _extract_type(lines: List[str]) -> str | None:
    for line in lines:
        stripped = line.strip()
        if stripped.lower().startswith("type:"):
            return stripped.split(":", 1)[1].strip()
    return None


def _extract_description(lines: List[str]) -> str | None:
    after_type = False
    paragraph: List[str] = []
    for line in lines:
        stripped = line.strip()
        if not stripped:
            if paragraph:
                break
            continue
        if stripped.lower().startswith("type:"):
            after_type = True
            continue
        if not after_type:
            continue
        if stripped.lower().startswith("one-click:"):
            continue
        if stripped.startswith("```"):
            # Skip code blocks that appear before any narrative description.
            return None
        paragraph.append(stripped)
    if not paragraph:
        return None
    return _normalize_description_text(" ".join(paragraph))


_MARKDOWN_LINK_PATTERN = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")


def _normalize_description_text(text: str) -> str:
    """Return ``text`` with inline markdown links stripped to plain text."""

    return _MARKDOWN_LINK_PATTERN.sub(r"\1", text)


def render_summary(docs: Sequence[PromptDoc]) -> str:
    if not docs:
        return SUMMARY_HEADER + "\n\n" + SUMMARY_FOOTER + "\n"

    output_lines: List[str] = [SUMMARY_HEADER, "", SUMMARY_FOOTER, ""]
    for repo_display, group in itertools.groupby(
        docs, key=lambda doc: doc.repo_display
    ):
        output_lines.append(f"## {repo_display}")
        output_lines.append("")
        for doc in group:
            path_display = doc.relative_path.as_posix()
            output_lines.append(_format_bullet(doc, path_display))
            wrapped = textwrap.fill(
                doc.description,
                width=96,
                initial_indent="  ",
                subsequent_indent="  ",
            )
            output_lines.append(wrapped)
            output_lines.append("")
    return "\n".join(output_lines).rstrip() + "\n"


def write_summary(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)
    repo_paths = read_repo_paths(args.repos_from)
    docs = collect_prompt_docs(repo_paths)
    summary = render_summary(docs)
    write_summary(args.out, summary)
    return 0


def _format_bullet(doc: PromptDoc, path_display: str) -> str:
    return "- **{title}** (`{type}`) â€” `{path}`".format(
        title=doc.title,
        type=doc.type_value,
        path=path_display,
    )


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
