"""Utilities for summarizing Codex prompt docs."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Sequence


@dataclass(slots=True)
class PromptDoc:
    """Metadata extracted from a single prompt doc."""

    repo: str
    path: Path
    title: str
    doc_type: str | None
    one_click: str | None
    description: str | None

    @property
    def rel_path(self) -> str:
        """Return a POSIX-style path relative to the repository root."""

        return self.path.as_posix()


def load_repo_sources(repo_file: Path) -> list[tuple[str, Path]]:
    """Return ``(repo_name, repo_root)`` pairs described in ``repo_file``."""

    sources: list[tuple[str, Path]] = []
    for raw_line in repo_file.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split()
        if len(parts) == 1:
            repo = parts[0]
            repo_path = Path(parts[0])
        else:
            repo, repo_root = parts[0], parts[1]
            repo_path = Path(repo_root)
        sources.append((repo, repo_path))
    return sources


def _strip_quotes(value: str) -> str:
    if value.startswith(("'", '"')) and value.endswith(("'", '"')):
        return value[1:-1]
    return value


def _parse_front_matter(lines: Sequence[str]) -> tuple[dict[str, str], int]:
    """Return front-matter key/value pairs and the index past the header."""

    data: dict[str, str] = {}
    if not lines or lines[0] != "---":
        return data, 0

    index = 1
    while index < len(lines):
        line = lines[index]
        if line == "---":
            return data, index + 1
        if ":" in line:
            key, raw_value = line.split(":", 1)
            data[key.strip()] = _strip_quotes(raw_value.strip())
        index += 1
    return data, index


def _first_heading(lines: Iterable[str]) -> str | None:
    for line in lines:
        if line.startswith("#"):
            return line.lstrip("# ")
    return None


def _extract_metadata(
    lines: Sequence[str],
) -> tuple[str | None, str | None, str | None]:
    doc_type: str | None = None
    one_click: str | None = None
    description: str | None = None

    in_code_block = False
    for line in lines:
        stripped = line.strip()
        if stripped.startswith("```"):
            in_code_block = not in_code_block
            continue
        if in_code_block or not stripped:
            continue
        if stripped.startswith("Type:") and doc_type is None:
            doc_type = stripped.split(":", 1)[1].strip()
            continue
        if stripped.startswith("One-click:") and one_click is None:
            one_click = stripped.split(":", 1)[1].strip()
            continue
        if description is None and not stripped.startswith("#"):
            description = stripped
            break
    return doc_type, one_click, description


def discover_prompt_docs(repo: str, repo_root: Path) -> list[PromptDoc]:
    """Collect prompt docs for ``repo`` located beneath ``repo_root``."""

    docs_dir = repo_root / "docs" / "prompts" / "codex"
    if not docs_dir.exists():
        return []

    prompt_docs: list[PromptDoc] = []
    for path in sorted(docs_dir.glob("*.md")):
        lines = path.read_text(encoding="utf-8").splitlines()
        front_matter, start_index = _parse_front_matter(lines)
        heading = _first_heading(lines[start_index:])
        doc_type, one_click, description = _extract_metadata(
            lines[start_index:]
        )
        title = front_matter.get("title") or heading or path.stem
        prompt_docs.append(
            PromptDoc(
                repo=repo,
                path=path.relative_to(repo_root),
                title=title,
                doc_type=doc_type,
                one_click=one_click,
                description=description,
            )
        )
    return prompt_docs


def escape_pipes(value: str | None) -> str:
    """Escape pipe characters for use inside a Markdown table cell."""

    if value is None:
        return "â€”"
    return value.replace("|", r"\|")


def render_summary(docs: Sequence[PromptDoc]) -> str:
    """Render a Markdown summary for ``docs`` grouped by repository."""

    lines: list[str] = [
        "# Prompt Docs Summary",
        "",
        "Generated by `scripts/update_prompt_docs_summary.py`.",
        "",
    ]
    if not docs:
        lines.append("No prompt docs were discovered.")
        lines.append("")
        return "\n".join(lines) + "\n"

    docs_by_repo: dict[str, list[PromptDoc]] = {}
    for doc in docs:
        docs_by_repo.setdefault(doc.repo, []).append(doc)

    for repo in sorted(docs_by_repo):
        lines.append(f"## {repo}")
        lines.append("")
        lines.append("| File | Title | Type | One-click | Summary |")
        lines.append("| --- | --- | --- | --- | --- |")
        for doc in docs_by_repo[repo]:
            summary = escape_pipes(doc.description)
            doc_type = escape_pipes(doc.doc_type)
            one_click = escape_pipes(doc.one_click)
            rel_path = doc.rel_path
            row = (
                f"| [{rel_path}]({rel_path}) | {doc.title} | {doc_type} | "
                f"{one_click} | {summary} |"
            )
            lines.append(row)
        lines.append("")
    return "\n".join(lines) + "\n"


def generate_summary(repo_file: Path) -> str:
    """Convenience wrapper that loads repositories and renders the summary."""

    docs: list[PromptDoc] = []
    for repo, root in load_repo_sources(repo_file):
        docs.extend(discover_prompt_docs(repo, root))
    return render_summary(docs)


def write_summary(output_path: Path, content: str) -> None:
    output_path.write_text(content, encoding="utf-8")


__all__ = [
    "PromptDoc",
    "discover_prompt_docs",
    "escape_pipes",
    "generate_summary",
    "load_repo_sources",
    "render_summary",
    "write_summary",
]
