<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Wove Product Assembly Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at top, #1e1f2f, #0b0c13);
        color: #f5f5f5;
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      #overlay {
        position: fixed;
        top: 1.5rem;
        left: 1.5rem;
        max-width: 22rem;
        padding: 1.25rem 1.5rem;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        border-radius: 0.75rem;
        backdrop-filter: blur(8px);
        box-shadow: 0 0.75rem 2rem rgba(0, 0, 0, 0.35);
      }

      #overlay h1 {
        margin: 0 0 0.5rem;
        font-size: 1.35rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      #overlay p {
        margin: 0 0 0.75rem;
        font-size: 0.95rem;
        line-height: 1.4;
      }

      #overlay ul {
        margin: 0;
        padding-left: 1.1rem;
        font-size: 0.9rem;
        line-height: 1.35;
      }

      #roadmap-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #roadmap-panel h2 {
        margin: 0 0 0.4rem;
        font-size: 1rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #9bb7ff;
      }

      #roadmap-panel p {
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.4;
        color: #e5e7ff;
      }

      #pattern-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #pattern-panel h2 {
        margin: 0 0 0.35rem;
        font-size: 0.98rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #ffc27d;
      }

      #pattern-panel p {
        margin: 0 0 0.45rem;
        font-size: 0.88rem;
        line-height: 1.4;
        color: #ffe7c9;
      }

      #pattern-progress {
        position: relative;
        height: 0.45rem;
        border-radius: 999px;
        overflow: hidden;
        background: rgba(255, 226, 178, 0.2);
        box-shadow: inset 0 0 0 1px rgba(255, 194, 125, 0.35);
      }

      #pattern-progress-bar {
        height: 100%;
        width: 0%;
        border-radius: 999px;
        background: linear-gradient(90deg, #ffb977, #ffe8c9);
        transition: width 0.18s ease-out;
      }

      #status {
        position: fixed;
        bottom: 1.2rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.5rem 0.85rem;
        border-radius: 999px;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }

      @media (max-width: 780px) {
        #overlay {
          left: 50%;
          transform: translateX(-50%);
          width: calc(100% - 3rem);
        }
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Wove Assembly</h1>
      <p>
        Explore the evolving assembly line for Wove robotics. Start with
        <strong>v1c</strong>, our first crochet robot, and imagine where future
        models will slot in as the roadmap expands.
      </p>
      <ul>
        <li>Drag to orbit, scroll to zoom, right-click to pan.</li>
        <li>Hover a component to read about its function.</li>
        <li>
          Check back often—new Codex tasks will iterate on this experience over
          time.
        </li>
        <li>
          Find the translucent workpiece support bed to see how swatches mount
          for calibration runs.
        </li>
        <li>
          The glowing safety interlocks mark physical end stops and the
          emergency stop switch described in the v1c roadmap.
        </li>
        <li>Click a pedestal to spotlight its roadmap milestone.</li>
      </ul>
      <div id="roadmap-panel">
        <h2 id="roadmap-title">Assembly Roadmap</h2>
        <p id="roadmap-description">
          Select a product cluster to learn how it advances the automation journey.
        </p>
      </div>
      <div id="pattern-panel">
        <h2>Pattern Studio Preview</h2>
        <p id="pattern-step-index">Loading planner steps…</p>
        <p id="pattern-step">Planner preview warming up.</p>
        <div id="pattern-progress">
          <div id="pattern-progress-bar"></div>
        </div>
      </div>
    </div>
    <div id="status">Initializing viewer…</div>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c13);

      const statusElement = document.getElementById('status');
      const roadmapTitleElement = document.getElementById('roadmap-title');
      const roadmapDescriptionElement = document.getElementById('roadmap-description');
      const patternStepElement = document.getElementById('pattern-step');
      const patternStepIndexElement = document.getElementById('pattern-step-index');
      const patternProgressBarElement = document.getElementById('pattern-progress-bar');

      const pointer = new THREE.Vector2();
      const raycaster = new THREE.Raycaster();
      const interactiveMeshes = [];
      const productClusters = [];
      const safeAccessHighlights = [];
      let activeCluster = null;
      const selectionRingHeight = 0.06;
      const yarnFlowControllers = [];
      let yarnExtrusionActive = false;
      let patternPlannerEvents = [];
      let patternPreviewGroup = null;
      let patternPreviewAnchor = null;
      const patternPreviewDurationSeconds = 14;
      let lastPatternStepIndex = -1;
      let lastPatternProgress = -1;

      const FRAME_HALF_WIDTH = 3.6;
      const FRAME_HALF_DEPTH = 2.6;
      const LOWER_RAIL_Y = 0.25;
      const UPPER_RAIL_Y = 4.3;
      const RAIL_THICKNESS = 0.22;

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        500,
      );
      camera.position.set(12, 8, 18);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 60;
      controls.maxPolarAngle = Math.PI * 0.49;

      const ambientLight = new THREE.AmbientLight(0xbac4ff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xf1f3ff, 1.2);
      keyLight.position.set(10, 16, 10);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x6c79ff, 0.6);
      fillLight.position.set(-6, 12, -12);
      scene.add(fillLight);

      const groundGeometry = new THREE.CircleGeometry(16, 64);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x131421,
        roughness: 0.85,
        metalness: 0.2,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(32, 32, 0x2e3a68, 0x1d233c);
      scene.add(gridHelper);

      const selectionRingGeometry = new THREE.RingGeometry(1.0, 1.3, 64);
      const selectionRingMaterial = new THREE.MeshBasicMaterial({
        color: 0x8ab4ff,
        transparent: true,
        opacity: 0.45,
        side: THREE.DoubleSide,
      });
      const selectionRing = new THREE.Mesh(selectionRingGeometry, selectionRingMaterial);
      selectionRing.rotation.x = -Math.PI / 2;
      selectionRing.position.y = selectionRingHeight;
      selectionRing.visible = false;
      selectionRing.scale.setScalar(1.0);
      scene.add(selectionRing);

      function buildLabel(text, color = '#f5f5f5') {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const padding = 32;
        const fontSize = 56;
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        const metrics = context.measureText(text);
        canvas.width = metrics.width + padding * 2;
        canvas.height = fontSize + padding * 1.4;

        context.fillStyle = 'rgba(12, 13, 25, 0.8)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.strokeStyle = 'rgba(245, 245, 245, 0.35)';
        context.lineWidth = 4;
        context.strokeRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = color;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        const baseScale = 0.02;
        sprite.scale.set(canvas.width * baseScale, canvas.height * baseScale, 1);
        return sprite;
      }

      function addHoverInfo(mesh, text, options = {}) {
        mesh.userData.hoverText = text;
        mesh.userData.hoverPassthrough = options.passthrough ?? false;
        interactiveMeshes.push(mesh);
      }

      function buildPlannerPreview(events) {
        const group = new THREE.Group();
        group.name = 'pattern-planner-preview';

        if (!Array.isArray(events) || events.length === 0) {
          return group;
        }

        let minX = events[0].x;
        let maxX = events[0].x;
        let minY = events[0].y;
        let maxY = events[0].y;
        let maxExtrusion = events[0].extrusion;

        events.forEach((event) => {
          minX = Math.min(minX, event.x);
          maxX = Math.max(maxX, event.x);
          minY = Math.min(minY, event.y);
          maxY = Math.max(maxY, event.y);
          maxExtrusion = Math.max(maxExtrusion, event.extrusion);
        });

        const planeWidth = 0.72;
        const planeHeight = 0.52;
        const usableWidth = planeWidth * 0.88;
        const usableHeight = planeHeight * 0.82;

        const xSpan = Math.max(maxX - minX, 1);
        const ySpan = Math.max(maxY - minY, 1);
        const extrusionSpan = Math.max(maxExtrusion, 0.01);

        const positions = new Float32Array(events.length * 3);
        const colors = new Float32Array(events.length * 3);
        const points = [];

        events.forEach((event, index) => {
          const normalizedX = (event.x - minX) / xSpan;
          const normalizedY = (event.y - minY) / ySpan;
          const centeredX = normalizedX - 0.5;
          const centeredY = normalizedY - 0.5;
          const xPos = centeredX * usableWidth;
          const yPos = centeredY * usableHeight;
          const extrusionRatio = Math.max(event.extrusion, 0) / extrusionSpan;
          const zPos = 0.02 + extrusionRatio * 0.06;
          const point = new THREE.Vector3(xPos, yPos, zPos);
          points.push(point);

          positions[index * 3] = point.x;
          positions[index * 3 + 1] = point.y;
          positions[index * 3 + 2] = point.z;

          const isExtruding =
            typeof event.comment === 'string' && event.comment.includes('feed yarn');
          const color = new THREE.Color(isExtruding ? 0xffb46b : 0x7fb3ff);
          colors[index * 3] = color.r;
          colors[index * 3 + 1] = color.g;
          colors[index * 3 + 2] = color.b;
        });

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const lineMaterial = new THREE.LineBasicMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.95,
        });

        const line = new THREE.Line(geometry, lineMaterial);
        line.renderOrder = 2;
        group.add(line);

        const cumulativeDistances = [0];
        for (let index = 1; index < points.length; index += 1) {
          const previous = points[index - 1];
          const current = points[index];
          const distance = current.distanceTo(previous);
          cumulativeDistances.push(cumulativeDistances[index - 1] + distance);
        }
        const totalDistance =
          cumulativeDistances[cumulativeDistances.length - 1] || 1.0;

        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.02, 20, 20),
          new THREE.MeshStandardMaterial({
            color: 0xf5f9ff,
            emissive: 0x88aaff,
            emissiveIntensity: 1.2,
            metalness: 0.35,
            roughness: 0.25,
          }),
        );
        marker.castShadow = true;
        marker.position.copy(points[0]);
        group.add(marker);

        const haloMaterial = new THREE.MeshBasicMaterial({
          color: 0xb9caff,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide,
        });
        const halo = new THREE.Mesh(
          new THREE.RingGeometry(0.04, 0.065, 32),
          haloMaterial,
        );
        halo.rotation.x = Math.PI / 2;
        halo.position.copy(marker.position);
        group.add(halo);

        const previewLabel = buildLabel('Base Chain Row', '#ffe7c9');
        previewLabel.position.set(0, usableHeight * 0.75, 0.05);
        previewLabel.scale.multiplyScalar(0.28);
        group.add(previewLabel);

        group.userData.preview = {
          points,
          cumulativeDistances,
          totalDistance,
          marker,
          halo,
          haloMaterial,
        };

        updatePatternOverlay(0, 0);

        return group;
      }

      function disposePreviewGroup(group) {
        group.traverse((child) => {
          if (child.geometry) {
            child.geometry.dispose();
          }
          if (child.material) {
            const materials = Array.isArray(child.material)
              ? child.material
              : [child.material];
            materials.forEach((material) => {
              if (material.map && typeof material.map.dispose === 'function') {
                material.map.dispose();
              }
              if (typeof material.dispose === 'function') {
                material.dispose();
              }
            });
          }
        });
      }

      function rebuildPatternPreview() {
        if (!patternPreviewAnchor) {
          return;
        }

        if (patternPreviewGroup) {
          patternPreviewAnchor.remove(patternPreviewGroup);
          disposePreviewGroup(patternPreviewGroup);
          patternPreviewGroup = null;
        }

        patternPreviewGroup = buildPlannerPreview(patternPlannerEvents);
        patternPreviewGroup.position.set(0, 0, 0.01);
        patternPreviewAnchor.add(patternPreviewGroup);
        lastPatternStepIndex = -1;
        lastPatternProgress = -1;

        if (patternPlannerEvents.length === 0) {
          yarnExtrusionActive = false;
          if (patternProgressBarElement) {
            patternProgressBarElement.style.width = '0%';
          }
        } else {
          updatePatternOverlay(0, 0);
        }
      }

      async function loadPatternPreviewData() {
        try {
          const response = await fetch('data/pattern_preview.json');
          if (!response.ok) {
            throw new Error(`Unexpected status ${response.status}`);
          }
          const raw = await response.json();
          if (!Array.isArray(raw)) {
            throw new Error('Planner preview data must be an array.');
          }
          patternPlannerEvents = raw
            .map((entry) => ({
              comment:
                typeof entry.comment === 'string' && entry.comment.length > 0
                  ? entry.comment
                  : null,
              command: typeof entry.command === 'string' ? entry.command : '',
              x: Number(entry.x) || 0,
              y: Number(entry.y) || 0,
              z: Number(entry.z) || 0,
              extrusion: Number(entry.extrusion) || 0,
            }))
            .filter((entry) => Number.isFinite(entry.x) && Number.isFinite(entry.y));
          Object.freeze(patternPlannerEvents);
          rebuildPatternPreview();
        } catch (error) {
          console.error('Failed to load planner preview data.', error);
          yarnExtrusionActive = false;
          if (patternStepElement) {
            patternStepElement.textContent = 'Planner preview unavailable.';
          }
          if (patternStepIndexElement) {
            patternStepIndexElement.textContent = 'No planner steps loaded';
          }
          if (patternProgressBarElement) {
            patternProgressBarElement.style.width = '0%';
          }
        }
      }

      function updatePatternOverlay(stepIndex, progressRatio) {
        if (!patternStepElement) {
          return;
        }

        const totalSteps = patternPlannerEvents.length;
        if (totalSteps === 0) {
          yarnExtrusionActive = false;
          lastPatternStepIndex = -1;
          lastPatternProgress = -1;
          if (patternProgressBarElement) {
            patternProgressBarElement.style.width = '0%';
          }
          return;
        }

        const clampedIndex = Math.min(Math.max(stepIndex, 0), totalSteps - 1);
        const clampedProgress = Math.min(Math.max(progressRatio, 0), 1);

        if (clampedIndex !== lastPatternStepIndex) {
          const event = patternPlannerEvents[clampedIndex] ?? {};
          const comment =
            typeof event.comment === 'string' && event.comment.trim().length > 0
              ? event.comment
              : 'Planner preview event';
          patternStepElement.textContent = comment;
          if (patternStepIndexElement) {
            patternStepIndexElement.textContent = `Step ${clampedIndex + 1} of ${totalSteps}`;
          }
          yarnExtrusionActive =
            typeof comment === 'string' && comment.toLowerCase().includes('feed yarn');
          lastPatternStepIndex = clampedIndex;
        }

        if (Math.abs(clampedProgress - lastPatternProgress) > 0.01) {
          if (patternProgressBarElement) {
            patternProgressBarElement.style.width = `${(clampedProgress * 100).toFixed(1)}%`;
          }
          lastPatternProgress = clampedProgress;
        }
      }
      function updatePatternPreview(elapsedSeconds) {
        if (!patternPreviewGroup) {
          return;
        }
        const preview = patternPreviewGroup.userData.preview;
        if (!preview || preview.totalDistance <= 0) {
          return;
        }

        const cycle = patternPreviewDurationSeconds;
        const wrapped = cycle > 0 ? elapsedSeconds % cycle : elapsedSeconds;
        const progress = wrapped / cycle;
        const targetDistance = progress * preview.totalDistance;

        let index = 0;
        while (
          index < preview.cumulativeDistances.length - 1 &&
          preview.cumulativeDistances[index + 1] < targetDistance
        ) {
          index += 1;
        }

        const startPoint = preview.points[index];
        const endPoint = preview.points[Math.min(index + 1, preview.points.length - 1)];
        const startDistance = preview.cumulativeDistances[index];
        const endDistance = preview.cumulativeDistances[
          Math.min(index + 1, preview.cumulativeDistances.length - 1)
        ];
        const segmentSpan = Math.max(endDistance - startDistance, 1e-6);
        const segmentProgress = (targetDistance - startDistance) / segmentSpan;

        preview.marker.position.lerpVectors(startPoint, endPoint, segmentProgress);
        const pulse = 0.6 + 0.4 * Math.sin(elapsedSeconds * 3.0);
        preview.marker.material.emissiveIntensity = pulse;

        if (preview.halo) {
          preview.halo.position.copy(preview.marker.position);
          const haloPulse = 0.35 + 0.3 * Math.sin(elapsedSeconds * 2.2);
          preview.haloMaterial.opacity = haloPulse;
        }

        updatePatternOverlay(index, progress);
      }

      function createSafetyShield() {
        const shieldGroup = new THREE.Group();
        shieldGroup.name = 'safety-shield';

        const shellMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x9fb7ff,
          transparent: true,
          opacity: 0.18,
          roughness: 0.08,
          metalness: 0.05,
          transmission: 0.82,
          thickness: 0.5,
          clearcoat: 0.6,
          clearcoatRoughness: 0.08,
        });

        const shell = new THREE.Mesh(
          new THREE.BoxGeometry(7.6, 4.8, 5.6),
          shellMaterial,
        );
        shell.position.set(0, 2.6, 0.3);
        shell.castShadow = false;
        shell.receiveShadow = false;
        shieldGroup.add(shell);
        addHoverInfo(
          shell,
          'Polycarbonate shield: translucent enclosure that keeps hands clear during motion demos.',
          { passthrough: true },
        );

        const edgeMaterial = new THREE.LineBasicMaterial({
          color: 0xc4d7ff,
          transparent: true,
          opacity: 0.55,
        });
        const shellEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(shell.geometry),
          edgeMaterial,
        );
        shell.add(shellEdges);

        const hingeMaterial = new THREE.MeshStandardMaterial({
          color: 0x4d5c87,
          metalness: 0.55,
          roughness: 0.35,
          emissive: 0x20283f,
        });

        const hinge = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 4.4, 24),
          hingeMaterial,
        );
        hinge.rotation.z = Math.PI / 2;
        hinge.position.set(3.65, 2.6, 0.3);
        hinge.castShadow = true;
        shieldGroup.add(hinge);

        const doorMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xaec9ff,
          transparent: true,
          opacity: 0.22,
          roughness: 0.1,
          transmission: 0.88,
          thickness: 0.45,
          metalness: 0.02,
        });

        const doorPivot = new THREE.Group();
        doorPivot.position.set(3.65, 2.6, 0.3);
        doorPivot.rotation.y = THREE.MathUtils.degToRad(-18);

        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.14, 4.4, 5.2),
          doorMaterial,
        );
        door.castShadow = false;
        door.receiveShadow = false;
        doorPivot.add(door);
        addHoverInfo(
          door,
          'Access door swings open for maintenance while keeping bystanders protected.',
        );

        const doorEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(door.geometry),
          new THREE.LineBasicMaterial({
            color: 0x90b4ff,
            transparent: true,
            opacity: 0.65,
          }),
        );
        door.add(doorEdges);
        shieldGroup.add(doorPivot);

        const latch = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.6, 0.6),
          hingeMaterial,
        );
        latch.position.set(3.9, 2.0, 2.8);
        latch.rotation.y = THREE.MathUtils.degToRad(-18);
        latch.castShadow = true;
        shieldGroup.add(latch);

        const glow = new THREE.PointLight(0x9fbfff, 0.8, 7.0);
        glow.position.set(3.1, 3.8, 2.2);
        shieldGroup.add(glow);

        const label = buildLabel('Polycarbonate Shield', '#d7e5ff');
        label.position.set(0, 4.9, 0.3);
        label.scale.multiplyScalar(0.55);
        shieldGroup.add(label);

        return shieldGroup;
      }

      function createSafeAccessPath() {
        const group = new THREE.Group();
        group.name = 'safe-access-path';

        const pathGeometry = new THREE.PlaneGeometry(3.0, 1.8);
        const pathMaterial = new THREE.MeshStandardMaterial({
          color: 0x66fddf,
          emissive: 0x1b7561,
          emissiveIntensity: 0.5,
          metalness: 0.08,
          roughness: 0.3,
          transparent: true,
          opacity: 0.72,
          side: THREE.DoubleSide,
          depthWrite: false,
        });
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        path.position.set(4.5, 0.025, 0.35);
        path.receiveShadow = false;
        group.add(path);
        addHoverInfo(
          path,
          'Mint-lit safe access path — follow the alternating, pulsing footprints to service the crochet cell without clipping hardware.',
        );
        safeAccessHighlights.push({
          material: pathMaterial,
          baseIntensity: 0.5,
          amplitude: 0.25,
          speed: 1.8,
          baseOpacity: 0.72,
          opacityAmplitude: 0.1,
          phaseOffset: 0,
        });

        const outline = new THREE.LineSegments(
          new THREE.EdgesGeometry(pathGeometry),
          new THREE.LineBasicMaterial({
            color: 0xa9fff0,
            transparent: true,
            opacity: 0.65,
          }),
        );
        outline.rotation.x = -Math.PI / 2;
        outline.position.copy(path.position);
        outline.position.y += 0.002;
        group.add(outline);

        const arrowMaterial = new THREE.MeshStandardMaterial({
          color: 0xc4fff3,
          emissive: 0x2c9c83,
          emissiveIntensity: 0.6,
          metalness: 0.12,
          roughness: 0.25,
        });
        const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.46, 32), arrowMaterial);
        arrow.rotation.z = -Math.PI / 2;
        arrow.position.set(3.55, 0.38, 0.35);
        arrow.castShadow = true;
        group.add(arrow);
        safeAccessHighlights.push({
          material: arrowMaterial,
          baseIntensity: 0.6,
          amplitude: 0.25,
          speed: 2.3,
          phaseOffset: Math.PI / 3,
        });

        const footstepGeometry = new THREE.CircleGeometry(0.26, 40);

        function addFootstep(x, z, rotationDegrees, phaseOffset) {
          const footprintMaterial = new THREE.MeshStandardMaterial({
            color: 0xdbfff4,
            emissive: 0x2f9270,
            emissiveIntensity: 0.48,
            metalness: 0.08,
            roughness: 0.24,
            transparent: true,
            opacity: 0.86,
            side: THREE.DoubleSide,
            depthWrite: false,
          });
          const footprint = new THREE.Mesh(footstepGeometry, footprintMaterial);
          footprint.rotation.x = -Math.PI / 2;
          footprint.rotation.y = THREE.MathUtils.degToRad(rotationDegrees);
          footprint.position.set(x, 0.03, z);
          footprint.scale.set(1.45, 1.0, 1.15);
          footprint.renderOrder = 3;
          group.add(footprint);
          safeAccessHighlights.push({
            material: footprintMaterial,
            baseIntensity: 0.48,
            amplitude: 0.32,
            speed: 2.6,
            phaseOffset,
            baseOpacity: 0.86,
            opacityAmplitude: 0.18,
          });

          const toeMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0fff9,
            emissive: 0x42c9a2,
            emissiveIntensity: 0.55,
            metalness: 0.05,
            roughness: 0.22,
            transparent: true,
            opacity: 0.78,
            depthWrite: false,
          });
          const toe = new THREE.Mesh(new THREE.CircleGeometry(0.1, 24), toeMaterial);
          toe.rotation.x = -Math.PI / 2;
          toe.rotation.y = footprint.rotation.y;
          toe.position.set(
            x + Math.cos(footprint.rotation.y) * 0.22,
            0.031,
            z - Math.sin(footprint.rotation.y) * 0.22,
          );
          toe.scale.set(1.25, 1.0, 1.2);
          toe.renderOrder = 4;
          group.add(toe);
          safeAccessHighlights.push({
            material: toeMaterial,
            baseIntensity: 0.55,
            amplitude: 0.25,
            speed: 2.6,
            phaseOffset: phaseOffset + 0.7,
            baseOpacity: 0.78,
            opacityAmplitude: 0.15,
          });
        }

        const stepSequence = [
          { x: 3.85, z: 0.12, rotation: 8, phase: 0.0 },
          { x: 4.15, z: 0.58, rotation: 12, phase: 0.45 },
          { x: 4.45, z: 0.12, rotation: 8, phase: 0.9 },
          { x: 4.75, z: 0.58, rotation: 12, phase: 1.35 },
          { x: 5.05, z: 0.12, rotation: 8, phase: 1.8 },
          { x: 5.35, z: 0.58, rotation: 12, phase: 2.25 },
        ];
        stepSequence.forEach((step) => addFootstep(step.x, step.z, step.rotation, step.phase));

        const label = buildLabel('Safe Access Path', '#baffec');
        label.position.set(4.6, 0.92, -0.45);
        label.scale.multiplyScalar(0.44);
        group.add(label);

        const guideLight = new THREE.PointLight(0x8affe4, 1.15, 5.5);
        guideLight.position.set(4.25, 0.9, 0.35);
        group.add(guideLight);

        return group;
      }

      function createBeltGuards() {
        const group = new THREE.Group();
        group.name = 'belt-guards';

        const guardMaterial = new THREE.MeshStandardMaterial({
          color: 0x34425a,
          metalness: 0.55,
          roughness: 0.32,
          emissive: 0x141c29,
          emissiveIntensity: 0.45,
        });

        const windowMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x9eb9ff,
          transparent: true,
          opacity: 0.35,
          roughness: 0.12,
          metalness: 0.1,
          transmission: 0.75,
          thickness: 0.3,
        });

        const clipMaterial = new THREE.MeshStandardMaterial({
          color: 0x485673,
          metalness: 0.5,
          roughness: 0.35,
          emissive: 0x1b2333,
          emissiveIntensity: 0.35,
        });

        const guardLength = FRAME_HALF_WIDTH * 2 - 0.5;
        const guardHeight = 0.16;
        const guardDepth = 0.48;
        const guardY = UPPER_RAIL_Y + 0.18;
        const guardOffsetZ = FRAME_HALF_DEPTH - 0.42;

        [-1, 1].forEach((direction, index) => {
          const guard = new THREE.Mesh(
            new THREE.BoxGeometry(guardLength, guardHeight, guardDepth),
            guardMaterial,
          );
          guard.position.set(0, guardY, direction * guardOffsetZ);
          guard.castShadow = true;
          guard.receiveShadow = true;
          group.add(guard);

          if (index === 0) {
            addHoverInfo(
              guard,
              'Snap-on belt guard — shields CoreXY belts from snagging while leaving inspection slots.',
            );
          }

          const inspectionWindow = new THREE.Mesh(
            new THREE.BoxGeometry(
              guardLength * 0.82,
              guardHeight * 0.55,
              guardDepth * 0.55,
            ),
            windowMaterial,
          );
          inspectionWindow.position.set(0, 0.02, 0);
          inspectionWindow.renderOrder = 1;
          guard.add(inspectionWindow);

          const clipPositions = [-guardLength * 0.42, 0, guardLength * 0.42];
          clipPositions.forEach((xPosition) => {
            const clip = new THREE.Mesh(
              new THREE.BoxGeometry(
                guardHeight * 0.85,
                guardHeight * 0.8,
                guardDepth + 0.12,
              ),
              clipMaterial,
            );
            clip.position.set(xPosition, -guardHeight * 0.5, 0);
            clip.castShadow = true;
            clip.receiveShadow = true;
            guard.add(clip);
          });

          const edgeGeometry = new THREE.EdgesGeometry(
            new THREE.BoxGeometry(guardLength, guardHeight, guardDepth),
          );
          const edgeMaterial = new THREE.LineBasicMaterial({
            color: 0xaec6ff,
            transparent: true,
            opacity: 0.55,
          });
          const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
          guard.add(edges);
        });

        const crossGuardLength = FRAME_HALF_DEPTH * 2 - 0.9;
        const crossSpacing = FRAME_HALF_WIDTH - 1.2;

        [-1, 1].forEach((direction) => {
          const crossGuard = new THREE.Mesh(
            new THREE.BoxGeometry(guardHeight, guardHeight, crossGuardLength),
            guardMaterial,
          );
          crossGuard.position.set(direction * crossSpacing, guardY, 0.35);
          crossGuard.castShadow = true;
          crossGuard.receiveShadow = true;
          group.add(crossGuard);

          const crossWindow = new THREE.Mesh(
            new THREE.BoxGeometry(
              guardHeight * 0.6,
              guardHeight * 0.5,
              crossGuardLength * 0.6,
            ),
            windowMaterial,
          );
          crossWindow.position.set(0, 0.015, 0);
          crossWindow.renderOrder = 1;
          crossGuard.add(crossWindow);
        });

        const beltLabel = buildLabel('Snap-On Belt Guards', '#c5d6ff');
        beltLabel.position.set(0, guardY + 0.55, 0.9);
        beltLabel.scale.multiplyScalar(0.45);
        group.add(beltLabel);

        const accent = new THREE.PointLight(0x7ea4ff, 0.9, 5.5);
        accent.position.set(0.4, guardY + 0.3, guardOffsetZ);
        group.add(accent);

        return group;
      }

      function createElectronicsBay() {
        const group = new THREE.Group();
        group.name = 'electronics-bay';

        const enclosureMaterial = new THREE.MeshStandardMaterial({
          color: 0x1d2639,
          metalness: 0.48,
          roughness: 0.42,
          emissive: 0x0c1321,
          emissiveIntensity: 0.35,
        });
        const enclosure = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.9, 1.2),
          enclosureMaterial,
        );
        enclosure.position.y = 0.45;
        enclosure.castShadow = true;
        group.add(enclosure);
        addHoverInfo(
          enclosure,
          'Electronics bay — shields the controller, drivers, and airflow ducting.',
          { passthrough: true },
        );

        const accessPanel = new THREE.Mesh(
          new THREE.PlaneGeometry(1.4, 0.6),
          new THREE.MeshStandardMaterial({
            color: 0x253656,
            emissive: 0x37548e,
            emissiveIntensity: 0.55,
            transparent: true,
            opacity: 0.65,
            side: THREE.DoubleSide,
          }),
        );
        accessPanel.position.set(0, 0.5, 0.62);
        group.add(accessPanel);

        const vent = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.08, 0.08),
          new THREE.MeshStandardMaterial({
            color: 0x455b83,
            metalness: 0.52,
            roughness: 0.34,
          }),
        );
        vent.position.set(0, 0.86, 0.56);
        vent.castShadow = true;
        group.add(vent);

        const controller = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.1, 0.68),
          new THREE.MeshStandardMaterial({
            color: 0x1c3d33,
            emissive: 0x0c231d,
            emissiveIntensity: 0.65,
            metalness: 0.32,
            roughness: 0.36,
          }),
        );
        controller.position.set(0, 0.32, 0);
        controller.castShadow = true;
        group.add(controller);
        addHoverInfo(
          controller,
          'Controller stack — SKR Mini and stepper drivers route motion commands.',
        );

        const heatsink = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.16, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x89a8ff,
            emissive: 0x2b448a,
            emissiveIntensity: 0.7,
            metalness: 0.68,
            roughness: 0.28,
          }),
        );
        heatsink.position.set(-0.32, 0.5, -0.12);
        heatsink.castShadow = true;
        group.add(heatsink);

        const fan = new THREE.Mesh(
          new THREE.CylinderGeometry(0.26, 0.26, 0.12, 32),
          new THREE.MeshStandardMaterial({
            color: 0x121722,
            metalness: 0.42,
            roughness: 0.38,
          }),
        );
        fan.rotation.x = Math.PI / 2;
        fan.position.set(0.54, 0.48, 0);
        fan.castShadow = true;
        group.add(fan);
        addHoverInfo(fan, 'Cooling fan — pulls heat away from the driver stack.');

        const fanGlow = new THREE.PointLight(0x6fd8ff, 1.4, 2.8);
        fanGlow.position.set(0.54, 0.88, 0.1);
        group.add(fanGlow);

        const harness = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 1.6, 16),
          new THREE.MeshStandardMaterial({
            color: 0x2c3b52,
            metalness: 0.3,
            roughness: 0.4,
            emissive: 0x111a2a,
            emissiveIntensity: 0.4,
          }),
        );
        harness.rotation.z = Math.PI / 2.4;
        harness.position.set(-0.15, 0.18, 0.38);
        harness.castShadow = true;
        group.add(harness);
        addHoverInfo(
          harness,
          'Cable harness — bundles stepper power and sensor leads toward the gantry.',
        );

        const statusLed = new THREE.Mesh(
          new THREE.SphereGeometry(0.08, 16, 16),
          new THREE.MeshStandardMaterial({
            color: 0x7dffbe,
            emissive: 0x33d18a,
            emissiveIntensity: 1.0,
            metalness: 0.2,
            roughness: 0.25,
          }),
        );
        statusLed.position.set(-0.68, 0.68, 0.58);
        statusLed.castShadow = true;
        group.add(statusLed);

        const statusLight = new THREE.PointLight(0x66ffc2, 1.2, 2.2);
        statusLight.position.copy(statusLed.position);
        statusLight.position.y += 0.2;
        group.add(statusLight);

        const label = buildLabel('Electronics Bay', '#a9c8ff');
        label.position.set(0, 1.02, 0.62);
        label.scale.multiplyScalar(0.42);
        group.add(label);

        return group;
      }

      function createTensionPostAssembly() {
        const group = new THREE.Group();
        group.name = 'tension-post-assembly';

        const baseMaterial = new THREE.MeshStandardMaterial({
          color: 0x1d2838,
          metalness: 0.48,
          roughness: 0.36,
        });
        const base = new THREE.Mesh(
          new THREE.CylinderGeometry(0.36, 0.4, 0.12, 32),
          baseMaterial,
        );
        base.position.y = 0.06;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        const riserMaterial = new THREE.MeshStandardMaterial({
          color: 0xd4e2ff,
          metalness: 0.42,
          roughness: 0.25,
          emissive: 0x1c2741,
          emissiveIntensity: 0.4,
        });
        const riserGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.9, 32);
        [-0.16, 0.16].forEach((xOffset, index) => {
          const riser = new THREE.Mesh(riserGeometry, riserMaterial);
          riser.position.set(xOffset, 0.48, 0);
          riser.castShadow = true;
          group.add(riser);
          safeAccessHighlights.push({
            material: riserMaterial,
            baseIntensity: 0.4,
            amplitude: 0.15,
            speed: 1.6,
            phaseOffset: index * 1.2,
          });
        });

        const brace = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 0.38, 24),
          new THREE.MeshStandardMaterial({
            color: 0x7f91b0,
            metalness: 0.55,
            roughness: 0.32,
          }),
        );
        brace.rotation.z = Math.PI / 2;
        brace.position.set(0, 0.88, 0);
        brace.castShadow = true;
        group.add(brace);

        const feltMaterial = new THREE.MeshStandardMaterial({
          color: 0x2c4a3e,
          metalness: 0.15,
          roughness: 0.7,
          emissive: 0x0a1c16,
          emissiveIntensity: 0.5,
        });
        const feltPad = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 0.04, 32),
          feltMaterial,
        );
        feltPad.position.set(0, 0.92, 0);
        feltPad.castShadow = true;
        group.add(feltPad);
        addHoverInfo(
          feltPad,
          'Felt pads cushion yarn wraps so swaps stay smooth and abrasion-free.',
        );
        safeAccessHighlights.push({
          material: feltMaterial,
          baseIntensity: 0.5,
          amplitude: 0.2,
          speed: 1.8,
          phaseOffset: 0.6,
        });

        const clipMaterial = new THREE.MeshStandardMaterial({
          color: 0xfff0c4,
          metalness: 0.75,
          roughness: 0.18,
          emissive: 0x6d4f20,
          emissiveIntensity: 0.6,
        });
        const clip = new THREE.Mesh(
          new THREE.TorusGeometry(0.24, 0.03, 16, 64, Math.PI * 1.3),
          clipMaterial,
        );
        clip.rotation.x = Math.PI / 2;
        clip.rotation.z = Math.PI / 2;
        clip.position.set(0, 0.94, 0);
        clip.castShadow = true;
        group.add(clip);
        addHoverInfo(
          clip,
          'Spring clip pins yarn against the felt to hold tension during swaps.',
        );
        safeAccessHighlights.push({
          material: clipMaterial,
          baseIntensity: 0.6,
          amplitude: 0.25,
          speed: 2.0,
          phaseOffset: 1.4,
        });

        const guideRingMaterial = new THREE.MeshStandardMaterial({
          color: 0xaff3ff,
          metalness: 0.28,
          roughness: 0.22,
          emissive: 0x1f4f59,
          emissiveIntensity: 0.45,
        });
        const guideRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.14, 0.02, 16, 48),
          guideRingMaterial,
        );
        guideRing.rotation.y = Math.PI / 2;
        guideRing.position.set(0.32, 0.88, 0);
        guideRing.castShadow = true;
        group.add(guideRing);
        addHoverInfo(
          guideRing,
          'Guide ring hands yarn into the PTFE tube without nicking fibers.',
        );
        safeAccessHighlights.push({
          material: guideRingMaterial,
          baseIntensity: 0.45,
          amplitude: 0.2,
          speed: 2.2,
          phaseOffset: 0.4,
        });

        const support = new THREE.Mesh(
          new THREE.BoxGeometry(0.18, 0.22, 0.36),
          new THREE.MeshStandardMaterial({
            color: 0x253241,
            metalness: 0.32,
            roughness: 0.48,
          }),
        );
        support.position.set(0, 0.2, -0.12);
        support.castShadow = true;
        group.add(support);

        const accent = new THREE.PointLight(0xa6fbff, 0.9, 2.8);
        accent.position.set(0.1, 1.15, 0.1);
        group.add(accent);

        const label = buildLabel('Tension Post & PTFE Guide', '#b9fff6');
        label.position.set(0.05, 1.2, 0.34);
        label.scale.multiplyScalar(0.38);
        group.add(label);

        const guideEntry = new THREE.Object3D();
        guideEntry.position.set(-0.3, 0.9, 0);
        group.add(guideEntry);

        const guideExit = new THREE.Object3D();
        guideExit.position.set(0.3, 0.9, 0);
        group.add(guideExit);

        group.userData.guideEntry = guideEntry;
        group.userData.guideExit = guideExit;

        return group;
      }

      function createExtrusionFrame() {
        const frameGroup = new THREE.Group();
        frameGroup.name = 'extrusion-frame';

        const aluminumMaterial = new THREE.MeshStandardMaterial({
          color: 0xa8b4c9,
          metalness: 0.65,
          roughness: 0.28,
          emissive: 0x1c2331,
          emissiveIntensity: 0.25,
        });

        const cornerMaterial = new THREE.MeshStandardMaterial({
          color: 0x2d3a52,
          metalness: 0.45,
          roughness: 0.4,
          emissive: 0x121826,
          emissiveIntensity: 0.55,
        });

        const footMaterial = new THREE.MeshStandardMaterial({
          color: 0x14181f,
          metalness: 0.3,
          roughness: 0.55,
          emissive: 0x050608,
          emissiveIntensity: 0.45,
        });

        const lowerRailY = LOWER_RAIL_Y;
        const upperRailY = UPPER_RAIL_Y;
        const railThickness = RAIL_THICKNESS;
        const frameHalfWidth = FRAME_HALF_WIDTH;
        const frameHalfDepth = FRAME_HALF_DEPTH;

        const longRailGeometry = new THREE.BoxGeometry(frameHalfWidth * 2, railThickness, railThickness);
        const shortRailGeometry = new THREE.BoxGeometry(railThickness, railThickness, frameHalfDepth * 2);

        const rails = [
          { geometry: longRailGeometry, position: new THREE.Vector3(0, lowerRailY, frameHalfDepth) },
          { geometry: longRailGeometry, position: new THREE.Vector3(0, lowerRailY, -frameHalfDepth) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(frameHalfWidth, lowerRailY, 0.3) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(-frameHalfWidth, lowerRailY, 0.3) },
          { geometry: longRailGeometry, position: new THREE.Vector3(0, upperRailY, frameHalfDepth) },
          { geometry: longRailGeometry, position: new THREE.Vector3(0, upperRailY, -frameHalfDepth) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(frameHalfWidth, upperRailY, 0.3) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(-frameHalfWidth, upperRailY, 0.3) },
        ];

        rails.forEach(({ geometry, position }, index) => {
          const rail = new THREE.Mesh(geometry, aluminumMaterial);
          rail.position.copy(position);
          rail.castShadow = true;
          frameGroup.add(rail);

          if (index === 0) {
            addHoverInfo(
              rail,
              'Aluminum extrusion frame — 20×20 mm perimeter with corner cubes and leveling feet.',
            );
          }
        });

        const postHeight = upperRailY - lowerRailY;
        const postGeometry = new THREE.BoxGeometry(railThickness, postHeight, railThickness);
        const postPositions = [
          [frameHalfWidth, (upperRailY + lowerRailY) / 2, frameHalfDepth],
          [-frameHalfWidth, (upperRailY + lowerRailY) / 2, frameHalfDepth],
          [frameHalfWidth, (upperRailY + lowerRailY) / 2, -frameHalfDepth],
          [-frameHalfWidth, (upperRailY + lowerRailY) / 2, -frameHalfDepth],
        ];
        postPositions.forEach(([x, y, z]) => {
          const post = new THREE.Mesh(postGeometry, aluminumMaterial);
          post.position.set(x, y, z);
          post.castShadow = true;
          frameGroup.add(post);
        });

        const cornerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const cornerY = lowerRailY + 0.16;
        postPositions.forEach(([x, , z]) => {
          const cube = new THREE.Mesh(cornerGeometry, cornerMaterial);
          cube.position.set(x, cornerY, z);
          cube.castShadow = true;
          frameGroup.add(cube);
        });

        const footGeometry = new THREE.CylinderGeometry(0.3, 0.34, 0.28, 24);
        const footY = 0.14;
        postPositions.forEach(([x, , z]) => {
          const foot = new THREE.Mesh(footGeometry, footMaterial);
          foot.position.set(x, footY, z);
          foot.castShadow = true;
          frameGroup.add(foot);
          addHoverInfo(foot, 'Leveling foot — printed pad keeps the frame stable on workbenches.');
        });

        const accentLight = new THREE.PointLight(0xb7c9ff, 1.1, 12.0);
        accentLight.position.set(0, upperRailY + 0.5, 0.2);
        frameGroup.add(accentLight);

        const frameLabel = buildLabel('Extrusion Frame', '#dbe8ff');
        frameLabel.position.set(0, upperRailY + 0.6, -frameHalfDepth - 0.2);
        frameLabel.scale.multiplyScalar(0.5);
        frameGroup.add(frameLabel);

        return frameGroup;
      }

      function createV1CAssembly() {
        const group = new THREE.Group();
        group.name = 'v1c-assembly';

        const extrusionFrame = createExtrusionFrame();
        group.add(extrusionFrame);

        const chassisMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a9bff,
          metalness: 0.35,
          roughness: 0.4,
        });
        const chassis = new THREE.Mesh(
          new THREE.BoxGeometry(6, 0.8, 4),
          chassisMaterial,
        );
        chassis.position.y = 0.4;
        chassis.castShadow = true;
        chassis.receiveShadow = true;
        group.add(chassis);
        addHoverInfo(
          chassis,
          'v1c base platform — houses the drive electronics and bed alignment rails.',
        );

        const bedMaterial = new THREE.MeshStandardMaterial({
          color: 0xbfe4ff,
          metalness: 0.2,
          roughness: 0.3,
          transparent: true,
          opacity: 0.9,
          emissive: 0x1b3a4f,
        });
        const bedThickness = 0.25;
        const bed = new THREE.Mesh(new THREE.BoxGeometry(4.8, bedThickness, 3.2), bedMaterial);
        bed.position.set(0, 0.9, 0.2);
        bed.castShadow = true;
        bed.receiveShadow = true;
        group.add(bed);
        addHoverInfo(
          bed,
          'Workpiece support bed: removable build plate with magnetic anchors for swatch staging.',
        );

        const electronicsBay = createElectronicsBay();
        electronicsBay.position.set(-2.1, 0.4, -1.4);
        group.add(electronicsBay);

        const tensionAssembly = createTensionPostAssembly();
        tensionAssembly.position.set(-1.5, 0.92, -1.32);
        group.add(tensionAssembly);

        const bedTopY = bed.position.y + bedThickness / 2;
        const anchorsGroup = new THREE.Group();
        anchorsGroup.name = 'magnetic-anchors';
        const anchorBaseMaterial = new THREE.MeshStandardMaterial({
          color: 0x3f4657,
          metalness: 0.55,
          roughness: 0.32,
        });
        const anchorCapTemplate = new THREE.MeshStandardMaterial({
          color: 0xffe3a4,
          metalness: 0.82,
          roughness: 0.22,
          emissive: 0x8a5a1a,
          emissiveIntensity: 0.45,
        });
        const anchorOffsets = [
          [-1.8, -1.0],
          [1.8, -1.0],
          [-1.8, 1.2],
          [1.8, 1.2],
        ];
        anchorOffsets.forEach(([x, z], index) => {
          const anchorGroup = new THREE.Group();
          anchorGroup.position.set(x, bedTopY + 0.05, z);

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.22, 0.24, 0.08, 32),
            anchorBaseMaterial,
          );
          base.castShadow = true;
          base.receiveShadow = true;
          anchorGroup.add(base);

          const core = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.06, 24),
            new THREE.MeshStandardMaterial({
              color: 0x1b2233,
              metalness: 0.35,
              roughness: 0.45,
            }),
          );
          core.position.y = 0.03;
          core.castShadow = true;
          anchorGroup.add(core);

          const capMaterial = anchorCapTemplate.clone();
          const cap = new THREE.Mesh(
            new THREE.CylinderGeometry(0.14, 0.14, 0.045, 32),
            capMaterial,
          );
          cap.position.y = 0.065;
          cap.castShadow = true;
          anchorGroup.add(cap);
          addHoverInfo(
            cap,
            'Magnetic anchor puck — secures swap-in plates with embedded magnets.',
          );

          const haloMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd27f,
            emissive: 0xffb347,
            emissiveIntensity: 0.5,
            metalness: 0.65,
            roughness: 0.28,
            transparent: true,
            opacity: 0.8,
          });
          const halo = new THREE.Mesh(new THREE.TorusGeometry(0.18, 0.012, 16, 48), haloMaterial);
          halo.rotation.x = Math.PI / 2;
          halo.position.y = 0.028;
          anchorGroup.add(halo);

          const anchorGlow = new THREE.PointLight(0xffdeaa, 0.55, 1.4);
          anchorGlow.position.set(0, 0.2, 0);
          anchorGroup.add(anchorGlow);

          safeAccessHighlights.push({
            material: haloMaterial,
            baseIntensity: 0.5,
            amplitude: 0.28,
            speed: 1.8,
            phaseOffset: index * 0.7,
            baseOpacity: 0.8,
            opacityAmplitude: 0.12,
          });
          safeAccessHighlights.push({
            material: capMaterial,
            baseIntensity: 0.45,
            amplitude: 0.22,
            speed: 1.8,
            phaseOffset: index * 0.7 + 0.9,
          });

          anchorsGroup.add(anchorGroup);
        });

        const anchorsLabel = buildLabel('Magnetic Anchors', '#ffe8bf');
        anchorsLabel.position.set(0, bedTopY + 0.62, 1.5);
        anchorsLabel.scale.multiplyScalar(0.42);
        anchorsGroup.add(anchorsLabel);
        group.add(anchorsGroup);

        const gantryMaterial = new THREE.MeshStandardMaterial({
          color: 0xffc857,
          metalness: 0.2,
          roughness: 0.3,
          emissive: 0x332400,
        });
        const gantry = new THREE.Mesh(new THREE.BoxGeometry(0.6, 4.5, 6.5), gantryMaterial);
        gantry.position.set(0, 2.75, 0.35);
        gantry.castShadow = true;
        group.add(gantry);
        addHoverInfo(
          gantry,
          'Dual-axis gantry lifts the crocheting effector while guiding yarn tension.',
        );

        const beltGuards = createBeltGuards();
        group.add(beltGuards);

        const effectorMaterial = new THREE.MeshStandardMaterial({
          color: 0xff6f91,
          roughness: 0.35,
          metalness: 0.15,
          emissive: 0x401220,
        });
        const effectorGeometry = new THREE.CylinderGeometry(0.45, 0.6, 2.2, 32);
        const effector = new THREE.Mesh(effectorGeometry, effectorMaterial);
        effector.rotation.z = Math.PI / 2;
        effector.position.set(1.8, 2.4, 0.6);
        effector.castShadow = true;
        group.add(effector);
        const effectorGuide = new THREE.Object3D();
        effectorGuide.position.set(0.58, 0.24, 0.28);
        effector.add(effectorGuide);
        effector.userData.guide = effectorGuide;
        addHoverInfo(
          effector,
          'Crochet effector: hooks yarn, executes stitch choreography, and measures tension.',
        );

        const fanGroup = new THREE.Group();
        fanGroup.name = 'cooling-fan-assembly';
        fanGroup.position.set(2.35, 2.7, 0.6);

        const bracketMaterial = new THREE.MeshStandardMaterial({
          color: 0x2f3a55,
          metalness: 0.55,
          roughness: 0.35,
          emissive: 0x101627,
          emissiveIntensity: 0.6,
        });
        const bracket = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.92, 0.68), bracketMaterial);
        bracket.position.set(-0.18, 0.02, 0.02);
        bracket.castShadow = true;
        bracket.receiveShadow = true;
        fanGroup.add(bracket);

        const strut = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.18, 0.28), bracketMaterial);
        strut.position.set(-0.36, -0.22, 0.0);
        strut.castShadow = true;
        strut.receiveShadow = true;
        fanGroup.add(strut);

        const housingMaterial = new THREE.MeshStandardMaterial({
          color: 0x445d89,
          metalness: 0.45,
          roughness: 0.28,
          emissive: 0x1b2744,
          emissiveIntensity: 0.55,
        });
        const housing = new THREE.Mesh(new THREE.CylinderGeometry(0.36, 0.36, 0.22, 48), housingMaterial);
        housing.rotation.z = Math.PI / 2;
        housing.position.set(0.1, 0, 0);
        housing.castShadow = true;
        housing.receiveShadow = true;
        fanGroup.add(housing);
        addHoverInfo(
          housing,
          'Cooling fan mount — 20 mm fan keeps the hook actuator cool during long runs.',
        );

        const hub = new THREE.Mesh(
          new THREE.CylinderGeometry(0.09, 0.09, 0.22, 24),
          new THREE.MeshStandardMaterial({
            color: 0xf5f9ff,
            emissive: 0x7fa6ff,
            emissiveIntensity: 0.45,
            metalness: 0.65,
            roughness: 0.18,
          }),
        );
        hub.rotation.z = Math.PI / 2;
        hub.position.set(0.1, 0, 0);
        hub.castShadow = true;
        fanGroup.add(hub);

        const bladesGroup = new THREE.Group();
        bladesGroup.position.set(0.2, 0, 0);
        const bladeMaterial = new THREE.MeshStandardMaterial({
          color: 0xe4ecff,
          emissive: 0x6f8cff,
          emissiveIntensity: 0.4,
          metalness: 0.32,
          roughness: 0.36,
          side: THREE.DoubleSide,
        });
        const bladeGeometry = new THREE.BoxGeometry(0.02, 0.54, 0.16);
        for (let index = 0; index < 3; index += 1) {
          const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
          blade.rotation.x = (Math.PI / 3) * index;
          blade.castShadow = true;
          bladesGroup.add(blade);
        }
        fanGroup.add(bladesGroup);

        const guardMaterial = new THREE.MeshStandardMaterial({
          color: 0xaec4ff,
          emissive: 0x3246a1,
          emissiveIntensity: 0.4,
          transparent: true,
          opacity: 0.65,
          side: THREE.DoubleSide,
        });
        const guard = new THREE.Mesh(new THREE.TorusGeometry(0.34, 0.01, 16, 64), guardMaterial);
        guard.rotation.z = Math.PI / 2;
        guard.position.set(0.2, 0, 0);
        fanGroup.add(guard);

        const fanGlow = new THREE.PointLight(0x9ec4ff, 0.8, 1.8);
        fanGlow.position.set(0.24, 0.1, 0);
        fanGroup.add(fanGlow);

        const fanLabel = buildLabel('Cooling Fan Mount', '#d7e5ff');
        fanLabel.position.set(0.0, 0.95, 0);
        fanLabel.scale.multiplyScalar(0.42);
        fanGroup.add(fanLabel);

        group.add(fanGroup);

        const spoolMaterial = new THREE.MeshStandardMaterial({
          color: 0xd1d5ff,
          metalness: 0.1,
          roughness: 0.6,
        });
        const spool = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 2.8, 32), spoolMaterial);
        spool.position.set(-2.4, 2.1, -1.6);
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        group.add(spool);
        const spoolGuide = new THREE.Object3D();
        spoolGuide.position.set(0, 0.6, 0);
        spool.add(spoolGuide);
        spool.userData.guide = spoolGuide;
        addHoverInfo(
          spool,
          'Yarn management module: active tensioning keeps stitches uniform throughout runs.',
        );

        const sensorAssembly = new THREE.Group();
        sensorAssembly.position.set(-1.1, 1.9, -1.9);

        const armMaterial = new THREE.MeshStandardMaterial({
          color: 0x7b8bff,
          metalness: 0.25,
          roughness: 0.35,
          emissive: 0x1c224d,
        });
        const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.4, 24), armMaterial);
        arm.rotation.z = Math.PI / 2.6;
        arm.position.set(0.2, 0.1, 0);
        arm.castShadow = true;
        sensorAssembly.add(arm);

        const hinge = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, 0.32, 24),
          new THREE.MeshStandardMaterial({
            color: 0x303756,
            metalness: 0.5,
            roughness: 0.2,
          }),
        );
        hinge.rotation.z = Math.PI / 2;
        hinge.position.set(-0.4, -0.05, 0);
        hinge.castShadow = true;
        sensorAssembly.add(hinge);

        const sensorHousing = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.35, 0.6),
          new THREE.MeshStandardMaterial({
            color: 0xffd59d,
            metalness: 0.2,
            roughness: 0.25,
            emissive: 0x3a260a,
          }),
        );
        sensorHousing.position.set(0.6, 0.18, 0);
        sensorHousing.castShadow = true;
        sensorAssembly.add(sensorHousing);
        addHoverInfo(
          sensorHousing,
          'Hall-effect tension sensor: monitors deflection in the yarn path for feedback control.',
        );

        const sensorIndicator = new THREE.PointLight(0xffc98a, 1.4, 3.5);
        sensorIndicator.position.set(0.6, 0.3, 0);
        sensorAssembly.add(sensorIndicator);

        const sensorGuide = new THREE.Object3D();
        sensorGuide.position.set(0.6, 0.24, 0);
        sensorAssembly.add(sensorGuide);
        sensorAssembly.userData.guide = sensorGuide;

        const sensorLabel = buildLabel('Hall-Effect Sensor', '#ffd59d');
        sensorLabel.position.set(0.6, 0.9, 0);
        sensorLabel.scale.multiplyScalar(0.65);
        sensorAssembly.add(sensorLabel);

        group.add(sensorAssembly);

        group.updateWorldMatrix(true, true);

        const spoolPoint = new THREE.Vector3();
        spool.userData.guide.getWorldPosition(spoolPoint);
        const tensionEntryPoint = new THREE.Vector3();
        tensionAssembly.userData.guideEntry.getWorldPosition(tensionEntryPoint);
        const tensionExitPoint = new THREE.Vector3();
        tensionAssembly.userData.guideExit.getWorldPosition(tensionExitPoint);
        const sensorPoint = new THREE.Vector3();
        sensorAssembly.userData.guide.getWorldPosition(sensorPoint);
        const effectorPoint = new THREE.Vector3();
        effector.userData.guide.getWorldPosition(effectorPoint);

        const ptfeCurve = new THREE.CatmullRomCurve3([
          spoolPoint,
          spoolPoint.clone().add(new THREE.Vector3(0.45, 0.12, 0.18)),
          tensionEntryPoint,
          tensionExitPoint,
          sensorPoint.clone().add(new THREE.Vector3(0.18, 0.15, 0.04)),
          sensorPoint,
          effectorPoint.clone().add(new THREE.Vector3(-0.22, 0.1, -0.12)),
          effectorPoint,
        ]);

        const ptfeMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xbdf6ff,
          metalness: 0.05,
          roughness: 0.08,
          transparent: true,
          opacity: 0.5,
          transmission: 0.9,
          thickness: 0.45,
        });
        const ptfeTube = new THREE.Mesh(
          new THREE.TubeGeometry(ptfeCurve, 160, 0.04, 16, false),
          ptfeMaterial,
        );
        ptfeTube.castShadow = false;
        ptfeTube.receiveShadow = false;
        group.add(ptfeTube);
        addHoverInfo(
          ptfeTube,
          'PTFE guide tube — routes yarn from the spool through the sensor and into the hook.',
          { passthrough: true },
        );
        safeAccessHighlights.push({
          material: ptfeMaterial,
          baseOpacity: 0.5,
          opacityAmplitude: 0.12,
          speed: 1.4,
          phaseOffset: 1.1,
        });

        const yarnTextureCanvas = document.createElement('canvas');
        yarnTextureCanvas.width = 256;
        yarnTextureCanvas.height = 16;
        const yarnContext = yarnTextureCanvas.getContext('2d');
        if (yarnContext) {
          yarnContext.fillStyle = '#55261a';
          yarnContext.fillRect(0, 0, yarnTextureCanvas.width, yarnTextureCanvas.height);
          const stripeWidth = yarnTextureCanvas.width / 16;
          for (let index = 0; index < 16; index += 1) {
            const offset = index * stripeWidth;
            const gradient = yarnContext.createLinearGradient(offset, 0, offset + stripeWidth, 0);
            gradient.addColorStop(0.0, '#ffcf94');
            gradient.addColorStop(0.5, '#ff9f4a');
            gradient.addColorStop(1.0, '#ffcf94');
            yarnContext.fillStyle = gradient;
            yarnContext.fillRect(offset, 0, stripeWidth, yarnTextureCanvas.height);
          }
        }
        const yarnTexture = new THREE.CanvasTexture(yarnTextureCanvas);
        yarnTexture.wrapS = THREE.RepeatWrapping;
        yarnTexture.wrapT = THREE.ClampToEdgeWrapping;
        yarnTexture.repeat.set(8, 1);
        yarnTexture.anisotropy = 4;
        yarnTexture.needsUpdate = true;
        const yarnMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          emissive: 0xffb173,
          emissiveIntensity: 0.45,
          metalness: 0.12,
          roughness: 0.3,
          transparent: true,
          opacity: 0.85,
          transmission: 0.3,
          thickness: 0.18,
          map: yarnTexture,
          side: THREE.DoubleSide,
        });
        const yarnTube = new THREE.Mesh(
          new THREE.TubeGeometry(ptfeCurve, 200, 0.02, 24, false),
          yarnMaterial,
        );
        yarnTube.castShadow = false;
        yarnTube.receiveShadow = false;
        group.add(yarnTube);
        addHoverInfo(
          yarnTube,
          'Animated yarn flow — watch feed pulses as the crochet cell draws fiber.',
          { passthrough: true },
        );
        yarnFlowControllers.push({
          texture: yarnTexture,
          speed: 0.35,
          material: yarnMaterial,
          restIntensity: 0.45,
          activeIntensity: 0.9,
          currentIntensity: 0.45,
        });

        const displayLabel = buildLabel('v1c – Crochet Robot', '#8ab4ff');
        displayLabel.position.set(0, 4.3, 0);
        group.add(displayLabel);

        const bedLabel = buildLabel('Workpiece Support Bed', '#b6f0ff');
        bedLabel.position.set(0, 1.6, -1.6);
        bedLabel.scale.multiplyScalar(0.85);
        group.add(bedLabel);

        const safetyShield = createSafetyShield();
        group.add(safetyShield);

        const safeAccessPath = createSafeAccessPath();
        group.add(safeAccessPath);

        function createEmergencyStop() {
          const emergencyGroup = new THREE.Group();
          emergencyGroup.position.set(2.2, 0.6, 1.35);

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.55, 0.55, 0.16, 48),
            new THREE.MeshStandardMaterial({
              color: 0x15161f,
              metalness: 0.5,
              roughness: 0.2,
            }),
          );
          base.castShadow = true;
          emergencyGroup.add(base);

          const button = new THREE.Mesh(
            new THREE.CylinderGeometry(0.45, 0.5, 0.28, 48),
            new THREE.MeshStandardMaterial({
              color: 0xff4d4f,
              emissive: 0x5f0608,
              emissiveIntensity: 0.8,
              metalness: 0.2,
              roughness: 0.35,
            }),
          );
          button.position.y = 0.21;
          button.castShadow = true;
          emergencyGroup.add(button);
          addHoverInfo(
            button,
            'Emergency stop switch — instantly cuts power to the v1c motion system.',
          );

          const halo = new THREE.Mesh(
            new THREE.TorusGeometry(0.52, 0.05, 16, 64),
            new THREE.MeshStandardMaterial({
              color: 0xff8083,
              emissive: 0x701010,
              emissiveIntensity: 0.7,
              metalness: 0.35,
              roughness: 0.15,
              transparent: true,
              opacity: 0.85,
            }),
          );
          halo.rotation.x = Math.PI / 2;
          halo.position.y = 0.08;
          emergencyGroup.add(halo);

          const indicator = new THREE.PointLight(0xff494c, 2.3, 4.2);
          indicator.position.y = 0.45;
          emergencyGroup.add(indicator);

          const label = buildLabel('Safety Interlock', '#ffb3b3');
          label.position.set(0, 0.95, 0);
          emergencyGroup.add(label);

          return emergencyGroup;
        }

        function createEndStop(position, axisLabel) {
          const group = new THREE.Group();
          group.position.copy(position);
          group.name = `end-stop-${axisLabel.toLowerCase()}`;

          const housing = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.5, 0.35),
            new THREE.MeshStandardMaterial({
              color: 0xffc285,
              metalness: 0.4,
              roughness: 0.25,
              emissive: 0x462501,
              emissiveIntensity: 0.55,
            }),
          );
          housing.castShadow = true;
          group.add(housing);
          addHoverInfo(
            housing,
            `${axisLabel}-axis end stop — trips firmware limits before overtravel can occur.`,
          );

          const indicatorMaterial = new THREE.MeshStandardMaterial({
            color: 0xfff1c6,
            emissive: 0xffb347,
            emissiveIntensity: 0.85,
            metalness: 0.25,
            roughness: 0.3,
            transparent: true,
            opacity: 0.92,
          });
          const indicator = new THREE.Mesh(
            new THREE.SphereGeometry(0.18, 24, 24),
            indicatorMaterial,
          );
          indicator.position.set(0, 0.44, 0);
          indicator.castShadow = true;
          group.add(indicator);

          const axisPhaseOffset =
            axisLabel === 'X' ? 0 : axisLabel === 'Y' ? Math.PI * 0.4 : Math.PI * 0.8;
          safeAccessHighlights.push({
            tag: `end-stop-${axisLabel.toLowerCase()}-indicator`,
            material: indicatorMaterial,
            baseIntensity: 0.85,
            amplitude: 0.55,
            speed: 3.1,
            phaseOffset: axisPhaseOffset,
            baseOpacity: 0.92,
            opacityAmplitude: 0.06,
          });

          const haloMaterial = new THREE.MeshBasicMaterial({
            color: 0xffe6aa,
            transparent: true,
            opacity: 0.52,
            side: THREE.DoubleSide,
            depthWrite: false,
          });
          const halo = new THREE.Mesh(new THREE.RingGeometry(0.26, 0.36, 40), haloMaterial);
          halo.rotation.x = Math.PI / 2;
          halo.position.set(0, 0.14, 0);
          halo.renderOrder = 6;
          group.add(halo);
          safeAccessHighlights.push({
            tag: `end-stop-${axisLabel.toLowerCase()}-halo`,
            material: haloMaterial,
            baseOpacity: 0.52,
            opacityAmplitude: 0.28,
            speed: 2.6,
            phaseOffset: axisPhaseOffset + 0.9,
          });

          const glowLight = new THREE.PointLight(0xffdd9c, 1.6, 3.4);
          glowLight.position.set(0, 0.6, 0);
          group.add(glowLight);

          const glowStem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.3, 16),
            new THREE.MeshStandardMaterial({
              color: 0xffd492,
              emissive: 0x7a3f02,
              emissiveIntensity: 0.55,
              metalness: 0.3,
              roughness: 0.35,
            }),
          );
          glowStem.position.set(0, 0.28, 0);
          glowStem.castShadow = true;
          group.add(glowStem);

          return group;
        }

        const emergencyStop = createEmergencyStop();
        group.add(emergencyStop);

        const endStops = [
          createEndStop(new THREE.Vector3(3.1, 2.1, 1.1), 'X'),
          createEndStop(new THREE.Vector3(-2.2, 3.6, -2.6), 'Y'),
          createEndStop(new THREE.Vector3(-1.0, 0.95, -1.4), 'Z'),
        ];
        endStops.forEach((stop) => group.add(stop));

        return group;
      }

      function createPedestalCluster(options) {
        const {
          name,
          roadmap,
          hoverText,
          position,
          accentColor,
          hoverColor,
          selectionScale = 0.54,
          selectionHeight = 0.24,
          buildDisplay,
          displayOffset = 0,
        } = options;

        const group = new THREE.Group();
        group.position.copy(position);
        group.userData.name = name;
        group.userData.roadmap = roadmap;
        group.userData.selectionScale = selectionScale;
        group.userData.selectionHeight = selectionHeight;

        const base = new THREE.Mesh(
          new THREE.CylinderGeometry(1.5, 1.8, 0.4, 48),
          new THREE.MeshStandardMaterial({
            color: 0x191c2a,
            roughness: 0.8,
            metalness: 0.15,
          }),
        );
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        const column = new THREE.Mesh(
          new THREE.CylinderGeometry(0.55, 0.75, 1.3, 48),
          new THREE.MeshStandardMaterial({
            color: accentColor,
            emissive: new THREE.Color(accentColor).multiplyScalar(0.35),
            metalness: 0.25,
            roughness: 0.45,
          }),
        );
        column.position.y = 0.85;
        column.castShadow = true;
        group.add(column);

        const platform = new THREE.Mesh(
          new THREE.CylinderGeometry(1.1, 1.1, 0.22, 48),
          new THREE.MeshStandardMaterial({
            color: hoverColor,
            emissive: new THREE.Color(hoverColor).multiplyScalar(0.25),
            metalness: 0.35,
            roughness: 0.3,
          }),
        );
        platform.position.y = 1.48;
        platform.castShadow = true;
        platform.name = `${name.toLowerCase().replace(/\s+/g, '-')}-pedestal`;
        group.add(platform);
        addHoverInfo(platform, hoverText);

        const glow = new THREE.PointLight(accentColor, 1.2, 8.0);
        glow.position.y = 1.7;
        group.add(glow);

        const halo = new THREE.Mesh(
          new THREE.TorusGeometry(1.05, 0.04, 16, 96),
          new THREE.MeshStandardMaterial({
            color: accentColor,
            emissive: new THREE.Color(accentColor).multiplyScalar(0.5),
            emissiveIntensity: 0.6,
            transparent: true,
            opacity: 0.8,
          }),
        );
        halo.rotation.x = Math.PI / 2;
        halo.position.y = 1.62;
        group.add(halo);

        const label = buildLabel(name, '#f5f9ff');
        label.position.set(0, 2.25, 0);
        label.scale.multiplyScalar(0.6);
        group.add(label);

        if (typeof buildDisplay === 'function') {
          const display = buildDisplay();
          if (display) {
            const platformTop = 1.48 + 0.11;
            display.position.y += platformTop + displayOffset;
            group.add(display);
          }
        }

        return group;
      }

      function createTensionLabDisplay() {
        const group = new THREE.Group();
        group.name = 'tension-lab-display';

        const bench = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.12, 1.1),
          new THREE.MeshStandardMaterial({
            color: 0x1a2f3a,
            metalness: 0.35,
            roughness: 0.4,
          }),
        );
        bench.position.y = 0.18;
        bench.castShadow = true;
        bench.receiveShadow = true;
        group.add(bench);
        addHoverInfo(
          bench,
          'Calibration bench — stages load cells and fixture rails for yarn testing.',
        );

        const rail = new THREE.Mesh(
          new THREE.BoxGeometry(1.6, 0.08, 0.14),
          new THREE.MeshStandardMaterial({
            color: 0x0f1f28,
            metalness: 0.3,
            roughness: 0.35,
          }),
        );
        rail.position.set(-0.2, 0.32, -0.04);
        rail.castShadow = true;
        group.add(rail);

        const spoolRig = new THREE.Group();
        spoolRig.position.set(0.38, 0.36, 0.02);

        const spoolCore = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.92, 24),
          new THREE.MeshStandardMaterial({
            color: 0x324451,
            metalness: 0.55,
            roughness: 0.28,
          }),
        );
        spoolCore.rotation.z = Math.PI / 2;
        spoolCore.castShadow = true;
        spoolRig.add(spoolCore);

        const spool = new THREE.Mesh(
          new THREE.CylinderGeometry(0.42, 0.42, 0.8, 48),
          new THREE.MeshStandardMaterial({
            color: 0xffe3a1,
            emissive: 0x94763a,
            emissiveIntensity: 0.35,
            roughness: 0.45,
          }),
        );
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        spoolRig.add(spool);
        addHoverInfo(
          spool,
          'Tension spool rig — calibrates hall-effect sensors before they reach production cells.',
        );

        group.add(spoolRig);

        const carriage = new THREE.Mesh(
          new THREE.BoxGeometry(0.34, 0.26, 0.86),
          new THREE.MeshStandardMaterial({
            color: 0x1c4f5c,
            metalness: 0.3,
            roughness: 0.32,
          }),
        );
        carriage.position.set(-0.62, 0.42, -0.05);
        carriage.castShadow = true;
        group.add(carriage);
        addHoverInfo(
          carriage,
          'Sensor carriage — slides along the rail to align load cells with the yarn path.',
        );

        const sensorTower = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.62, 32),
          new THREE.MeshStandardMaterial({
            color: 0x7df0ff,
            emissive: 0x1b6d7d,
            emissiveIntensity: 0.6,
            metalness: 0.4,
            roughness: 0.25,
          }),
        );
        sensorTower.position.set(-0.62, 0.74, 0.24);
        sensorTower.castShadow = true;
        group.add(sensorTower);

        const gaugeDisplay = new THREE.Mesh(
          new THREE.BoxGeometry(0.34, 0.24, 0.18),
          new THREE.MeshStandardMaterial({
            color: 0x0d1c28,
            emissive: 0x163b4d,
            emissiveIntensity: 0.55,
            metalness: 0.28,
            roughness: 0.32,
          }),
        );
        gaugeDisplay.position.set(-0.62, 0.82, 0.52);
        gaugeDisplay.castShadow = true;
        group.add(gaugeDisplay);
        addHoverInfo(
          gaugeDisplay,
          'Live tension telemetry — maps hall sensor readings to grams for planner feedback.',
        );

        const indicator = new THREE.PointLight(0x7df0ff, 1.4, 4.0);
        indicator.position.set(-0.62, 1.18, 0.52);
        group.add(indicator);

        return group;
      }

      function createMaterialPrepDisplay() {
        const group = new THREE.Group();
        group.name = 'material-prep-display';

        const table = new THREE.Mesh(
          new THREE.BoxGeometry(2.1, 0.14, 1.2),
          new THREE.MeshStandardMaterial({
            color: 0x1f2d24,
            metalness: 0.32,
            roughness: 0.48,
          }),
        );
        table.position.y = 0.18;
        table.castShadow = true;
        table.receiveShadow = true;
        group.add(table);
        addHoverInfo(
          table,
          'Material prep bench — stages yarn cones and QA tools before automation.',
        );

        const legGeometry = new THREE.BoxGeometry(0.16, 0.42, 0.16);
        const legMaterial = new THREE.MeshStandardMaterial({
          color: 0x16251b,
          metalness: 0.28,
          roughness: 0.42,
        });
        [
          [-0.92, 0.0, -0.5],
          [0.92, 0.0, -0.5],
          [-0.92, 0.0, 0.5],
          [0.92, 0.0, 0.5],
        ].forEach(([x, y, z]) => {
          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.position.set(x, y, z);
          leg.castShadow = true;
          group.add(leg);
        });

        const coneTree = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 0.92, 24),
          new THREE.MeshStandardMaterial({
            color: 0x2a3f30,
            metalness: 0.33,
            roughness: 0.36,
            emissive: 0x102216,
            emissiveIntensity: 0.4,
          }),
        );
        coneTree.position.set(-0.62, 0.64, 0.1);
        coneTree.castShadow = true;
        group.add(coneTree);

        const coneColors = [0xffe1a1, 0xffc4d0, 0xb8ecff];
        coneColors.forEach((color, index) => {
          const cone = new THREE.Mesh(
            new THREE.CylinderGeometry(0.34, 0.22, 0.46, 32),
            new THREE.MeshStandardMaterial({
              color,
              emissive: new THREE.Color(color).multiplyScalar(0.2),
              emissiveIntensity: 0.35,
              roughness: 0.38,
            }),
          );
          cone.rotation.z = Math.PI / 2;
          cone.position.set(-0.62, 0.48 + index * 0.24, 0.1);
          cone.castShadow = true;
          group.add(cone);
        });
        addHoverInfo(
          coneTree,
          'Cone tree — organizes dyed yarn sets with quick-grab color tags.',
        );

        const prepBins = new THREE.Group();
        prepBins.position.set(0.58, 0.36, -0.32);
        group.add(prepBins);

        const binGeometry = new THREE.BoxGeometry(0.46, 0.26, 0.46);
        const binColors = [0x325444, 0x3e6150, 0x274236];
        binColors.forEach((color, index) => {
          const bin = new THREE.Mesh(
            binGeometry,
            new THREE.MeshStandardMaterial({
              color,
              metalness: 0.18,
              roughness: 0.4,
              emissive: new THREE.Color(color).multiplyScalar(0.18),
            }),
          );
          bin.position.set(index * 0.52 - 0.52, 0, 0);
          bin.castShadow = true;
          prepBins.add(bin);
        });
        addHoverInfo(
          prepBins,
          'Prep bins — stage bobbins, winding tools, and pre-measured skeins.',
        );

        const scaleBase = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.08, 0.34),
          new THREE.MeshStandardMaterial({
            color: 0x1f1d2d,
            metalness: 0.4,
            roughness: 0.32,
          }),
        );
        scaleBase.position.set(0.38, 0.32, 0.42);
        scaleBase.castShadow = true;
        group.add(scaleBase);

        const scaleDeck = new THREE.Mesh(
          new THREE.BoxGeometry(0.46, 0.04, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6b76ff,
            emissive: 0x2c3080,
            emissiveIntensity: 0.6,
            roughness: 0.28,
          }),
        );
        scaleDeck.position.set(0.38, 0.38, 0.42);
        scaleDeck.castShadow = true;
        group.add(scaleDeck);
        addHoverInfo(
          scaleDeck,
          'Inspection scale — verifies yarn weight and cone swaps before runs.',
        );

        const checklist = new THREE.Mesh(
          new THREE.PlaneGeometry(0.42, 0.58),
          new THREE.MeshStandardMaterial({
            color: 0xc5f1d6,
            emissive: 0x4a8d65,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
          }),
        );
        checklist.position.set(0.1, 0.72, -0.46);
        checklist.rotation.y = -Math.PI / 6;
        checklist.castShadow = true;
        group.add(checklist);
        addHoverInfo(
          checklist,
          'Run cards — log dye lots, spool counts, and prep checks for traceability.',
        );

        const prepLabel = buildLabel('Prep & QA', '#d4ffe5');
        prepLabel.position.set(0.0, 1.0, 0.0);
        prepLabel.scale.multiplyScalar(0.4);
        group.add(prepLabel);

        const workLight = new THREE.PointLight(0x82ffb2, 1.1, 4.8);
        workLight.position.set(-0.6, 1.4, 0.1);
        group.add(workLight);

        return group;
      }

      function createPatternStudioDisplay() {
        const group = new THREE.Group();
        group.name = 'pattern-studio-display';

        const desk = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.12, 1.1),
          new THREE.MeshStandardMaterial({
            color: 0x2d1f24,
            metalness: 0.38,
            roughness: 0.45,
          }),
        );
        desk.position.y = 0.2;
        desk.castShadow = true;
        desk.receiveShadow = true;
        group.add(desk);

        const legGeometry = new THREE.BoxGeometry(0.12, 0.42, 0.12);
        const legMaterial = new THREE.MeshStandardMaterial({
          color: 0x1b1318,
          metalness: 0.35,
          roughness: 0.4,
        });
        [
          [-0.78, 0.01, -0.46],
          [0.78, 0.01, -0.46],
          [-0.78, 0.01, 0.46],
          [0.78, 0.01, 0.46],
        ].forEach(([x, y, z]) => {
          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.position.set(x, y, z);
          leg.castShadow = true;
          group.add(leg);
        });

        const monitorGeometry = new THREE.BoxGeometry(0.08, 0.64, 0.92);
        const monitorMaterial = new THREE.MeshStandardMaterial({
          color: 0x111527,
          emissive: 0x3d4eff,
          emissiveIntensity: 0.68,
          metalness: 0.25,
          roughness: 0.24,
        });
        const leftMonitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
        leftMonitor.position.set(-0.45, 0.6, -0.08);
        leftMonitor.rotation.y = 0.18;
        leftMonitor.castShadow = true;
        group.add(leftMonitor);
        addHoverInfo(
          leftMonitor,
          'Planner console — previews pattern_cli exports with motion overlays.',
        );

        const rightMonitor = leftMonitor.clone();
        rightMonitor.position.set(0.2, 0.6, -0.08);
        rightMonitor.rotation.y = -0.12;
        group.add(rightMonitor);

        const keyboard = new THREE.Mesh(
          new THREE.BoxGeometry(0.62, 0.05, 0.26),
          new THREE.MeshStandardMaterial({
            color: 0x37262d,
            metalness: 0.28,
            roughness: 0.45,
          }),
        );
        keyboard.position.set(-0.1, 0.28, 0.18);
        keyboard.castShadow = true;
        group.add(keyboard);

        const holoBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.36, 0.36, 0.04, 48),
          new THREE.MeshStandardMaterial({
            color: 0x3a2d52,
            metalness: 0.3,
            roughness: 0.35,
          }),
        );
        holoBase.position.set(0.58, 0.28, 0.3);
        holoBase.castShadow = true;
        group.add(holoBase);

        const holoEmitter = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.3, 0.5, 32, 1, true),
          new THREE.MeshStandardMaterial({
            color: 0x8c7dff,
            emissive: 0x4a3aff,
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide,
          }),
        );
        holoEmitter.position.set(0.58, 0.58, 0.3);
        holoEmitter.castShadow = true;
        group.add(holoEmitter);
        addHoverInfo(
          holoEmitter,
          'Holographic planner table — replays pattern_cli --format planner exports for dry runs.',
        );

        const planGrid = new THREE.Mesh(
          new THREE.PlaneGeometry(0.72, 0.52),
          new THREE.MeshStandardMaterial({
            color: 0x90a4ff,
            emissive: 0x5367ff,
            emissiveIntensity: 0.75,
            transparent: true,
            opacity: 0.78,
            side: THREE.DoubleSide,
          }),
        );
        planGrid.position.set(0.58, 0.78, 0.3);
        planGrid.rotation.y = Math.PI / 6;
        group.add(planGrid);
        patternPreviewAnchor = new THREE.Group();
        patternPreviewAnchor.position.set(0, 0, 0.01);
        planGrid.add(patternPreviewAnchor);
        rebuildPatternPreview();
        addHoverInfo(
          planGrid,
          'Planner hologram — loops a base chain row captured from pattern_cli --format planner.',
          { passthrough: true },
        );

        const holoLight = new THREE.PointLight(0x8c7dff, 1.3, 4.5);
        holoLight.position.set(0.58, 1.2, 0.3);
        group.add(holoLight);

        return group;
      }

      function createV1KResearchDisplay() {
        const group = new THREE.Group();
        group.name = 'v1k-research-display';

        const deck = new THREE.Mesh(
          new THREE.BoxGeometry(2.2, 0.14, 1.4),
          new THREE.MeshStandardMaterial({
            color: 0x1a1c2d,
            metalness: 0.32,
            roughness: 0.5,
          }),
        );
        deck.position.y = 0.2;
        deck.castShadow = true;
        deck.receiveShadow = true;
        group.add(deck);
        addHoverInfo(
          deck,
          'Research deck — stages knitting-bed prototypes for future automation trials.',
        );

        const railMaterial = new THREE.MeshStandardMaterial({
          color: 0x8ea3ff,
          emissive: 0x39477d,
          emissiveIntensity: 0.55,
          metalness: 0.42,
          roughness: 0.28,
        });
        const railGeometry = new THREE.BoxGeometry(0.14, 0.16, 1.26);
        [-0.55, 0.55].forEach((x) => {
          const rail = new THREE.Mesh(railGeometry, railMaterial);
          rail.position.set(x, 0.38, 0.0);
          rail.castShadow = true;
          group.add(rail);
        });

        const bed = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.08, 0.52),
          new THREE.MeshStandardMaterial({
            color: 0xe4e6ff,
            emissive: 0x4d5aff,
            emissiveIntensity: 0.28,
            metalness: 0.18,
            roughness: 0.24,
          }),
        );
        bed.position.set(0, 0.42, 0.0);
        bed.castShadow = true;
        group.add(bed);
        addHoverInfo(
          bed,
          'Needle bed prototype — validates carriage spacing for the knitting platform.',
        );

        const carriage = new THREE.Mesh(
          new THREE.BoxGeometry(0.54, 0.24, 0.74),
          new THREE.MeshStandardMaterial({
            color: 0xff9fb7,
            emissive: 0x6c2440,
            emissiveIntensity: 0.48,
            metalness: 0.3,
            roughness: 0.32,
          }),
        );
        carriage.position.set(0.18, 0.62, 0.0);
        carriage.castShadow = true;
        group.add(carriage);
        addHoverInfo(
          carriage,
          'Carriage sled — hosts interchangeable toolheads and yarn cutters for v1k.',
        );

        const needleGroup = new THREE.Group();
        needleGroup.position.set(0.18, 0.75, 0.0);
        const needleGeometry = new THREE.CylinderGeometry(0.018, 0.018, 0.46, 10);
        const needleMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f7ff,
          emissive: 0x9097ff,
          emissiveIntensity: 0.35,
          metalness: 0.4,
          roughness: 0.2,
        });
        [-0.24, 0, 0.24].forEach((offset) => {
          const needle = new THREE.Mesh(needleGeometry, needleMaterial);
          needle.rotation.x = Math.PI / 2;
          needle.position.set(offset, 0, 0.0);
          needle.castShadow = true;
          needleGroup.add(needle);
        });
        group.add(needleGroup);

        const consoleBase = new THREE.Mesh(
          new THREE.BoxGeometry(0.9, 0.12, 0.54),
          new THREE.MeshStandardMaterial({
            color: 0x26273d,
            metalness: 0.36,
            roughness: 0.38,
          }),
        );
        consoleBase.position.set(-0.82, 0.28, 0.46);
        consoleBase.castShadow = true;
        group.add(consoleBase);

        const consoleScreen = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.48, 0.58),
          new THREE.MeshStandardMaterial({
            color: 0x101425,
            emissive: 0x3a7bff,
            emissiveIntensity: 0.65,
            metalness: 0.28,
            roughness: 0.28,
          }),
        );
        consoleScreen.position.set(-1.16, 0.66, 0.46);
        consoleScreen.rotation.y = Math.PI / 3.5;
        consoleScreen.castShadow = true;
        group.add(consoleScreen);
        addHoverInfo(
          consoleScreen,
          'Control console — compares crochet motion plans with upcoming knitting paths.',
        );

        const spoolTower = new THREE.Mesh(
          new THREE.CylinderGeometry(0.16, 0.16, 0.9, 24),
          new THREE.MeshStandardMaterial({
            color: 0x34374f,
            metalness: 0.42,
            roughness: 0.34,
          }),
        );
        spoolTower.position.set(0.98, 0.62, 0.52);
        spoolTower.castShadow = true;
        group.add(spoolTower);

        const spool = new THREE.Mesh(
          new THREE.CylinderGeometry(0.42, 0.32, 0.72, 40),
          new THREE.MeshStandardMaterial({
            color: 0xffe6a8,
            emissive: 0x947f3d,
            emissiveIntensity: 0.32,
            roughness: 0.4,
          }),
        );
        spool.rotation.z = Math.PI / 2;
        spool.position.set(0.98, 0.62, 0.52);
        spool.castShadow = true;
        group.add(spool);
        addHoverInfo(
          spool,
          'Yarn staging spindle — feeds prototype fibers into the knitting carriage.',
        );

        const telemetryPod = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.24, 0.46, 32),
          new THREE.MeshStandardMaterial({
            color: 0x8cf0ff,
            emissive: 0x2e8896,
            emissiveIntensity: 0.75,
            transparent: true,
            opacity: 0.82,
          }),
        );
        telemetryPod.position.set(-0.15, 0.58, -0.58);
        telemetryPod.castShadow = true;
        group.add(telemetryPod);
        addHoverInfo(
          telemetryPod,
          'Telemetry pod — logs tension and carriage loads during knitting experiments.',
        );

        const workLight = new THREE.PointLight(0xc0a9ff, 1.5, 5.5);
        workLight.position.set(0.2, 1.3, 0.1);
        group.add(workLight);

        const label = buildLabel('Knitting Research', '#f4e9ff');
        label.position.set(0, 1.1, -0.56);
        label.scale.multiplyScalar(0.42);
        group.add(label);

        return group;
      }

      function populateProductLines() {
        const dais = new THREE.Mesh(
          new THREE.CylinderGeometry(4.2, 4.6, 0.6, 72),
          new THREE.MeshStandardMaterial({
            color: 0x151726,
            roughness: 0.85,
            metalness: 0.2,
          }),
        );
        dais.position.y = 0.3;
        dais.receiveShadow = true;
        dais.castShadow = true;

        const v1cCluster = new THREE.Group();
        v1cCluster.add(dais);
        const v1cAssembly = createV1CAssembly();
        v1cCluster.add(v1cAssembly);
        v1cCluster.userData.name = 'v1c Crochet Cell';
        v1cCluster.userData.roadmap =
          'Launch-ready crochet automation cell with emergency stop, gantry, and tension lab.';
        v1cCluster.userData.selectionScale = 1.0;
        v1cCluster.userData.selectionHeight = 0.32;
        scene.add(v1cCluster);
        productClusters.push(v1cCluster);
        addHoverInfo(
          dais,
          'Central robotics cell — houses the v1c crochet robot and its safety perimeter.',
        );

        const daisGlow = new THREE.PointLight(0x7fa8ff, 1.6, 26.0);
        daisGlow.position.set(0, 4.8, 0);
        v1cCluster.add(daisGlow);

        const clusterDefinitions = [
          {
            name: 'Tension Lab',
            roadmap:
              'Calibrates hall sensors, measures yarn pull force, and tunes servo-driven feed loops.',
            hoverText:
              'Tension lab pedestal — stage load cells and spool fixtures before gantry trials.',
            position: new THREE.Vector3(-6.8, 0, -3.5),
            accentColor: 0x7df0ff,
            hoverColor: 0x21404f,
            buildDisplay: createTensionLabDisplay,
          },
          {
            name: 'Material Prep Pod',
            roadmap:
              'Preps yarn cones, QA scales, and dye lots before the crochet cell loads them.',
            hoverText:
              'Material prep pedestal — organize cones, prep bins, and traceability run cards.',
            position: new THREE.Vector3(-6.4, 0, 3.5),
            accentColor: 0x82ffb2,
            hoverColor: 0x1a3525,
            buildDisplay: createMaterialPrepDisplay,
          },
          {
            name: 'Pattern Studio',
            roadmap:
              'Interactive planner hub translating pattern_cli exports into operator-ready motion previews.',
            hoverText:
              'Pattern studio pedestal — review planner exports and prep automation scripts.',
            position: new THREE.Vector3(7.1, 0, -2.6),
            accentColor: 0xffc47d,
            hoverColor: 0x47331e,
            buildDisplay: createPatternStudioDisplay,
          },
          {
            name: 'v1k Research Rig',
            roadmap:
              'Future knitting-focused platform inheriting motion control and safety architecture.',
            hoverText:
              'v1k research pedestal — staging area for the knitting-focused successor platform.',
            position: new THREE.Vector3(0, 0, 7.2),
            accentColor: 0xc0a9ff,
            hoverColor: 0x3a2d52,
            buildDisplay: createV1KResearchDisplay,
            displayOffset: 0.04,
          },
        ];

        clusterDefinitions.forEach((definition) => {
          const cluster = createPedestalCluster(definition);
          scene.add(cluster);
          productClusters.push(cluster);
        });
      }

      populateProductLines();
      loadPatternPreviewData();

      function updateRoadmapPanel(title, description) {
        roadmapTitleElement.textContent = title;
        roadmapDescriptionElement.textContent = description;
      }

      function selectCluster(cluster) {
        if (!cluster) {
          activeCluster = null;
          selectionRing.visible = false;
          updateRoadmapPanel(
            'Assembly Roadmap',
            'Select a product cluster to learn how it advances the automation journey.',
          );
          return;
        }

        if (activeCluster === cluster) {
          return;
        }

        activeCluster = cluster;
        selectionRing.visible = true;
        const targetScale = cluster.userData.selectionScale ?? 1;
        selectionRing.scale.setScalar(targetScale);
        const targetHeight = cluster.userData.selectionHeight ?? selectionRingHeight;
        selectionRing.position.set(cluster.position.x, targetHeight, cluster.position.z);
        updateRoadmapPanel(cluster.userData.name, cluster.userData.roadmap);
      }

      if (productClusters.length > 0) {
        selectCluster(productClusters[0]);
      }

      function setPointerFromEvent(event) {
        const bounds = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
        pointer.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
      }

      function findClusterFromObject(object) {
        let current = object;
        while (current) {
          if (current.userData && current.userData.roadmap) {
            return current;
          }
          current = current.parent;
        }
        return null;
      }

      const clock = new THREE.Clock();

      function animate() {
        const delta = clock.getDelta();
        const elapsed = clock.elapsedTime;
        scene.traverse((object) => {
          if (object.name === 'v1c-assembly') {
            object.rotation.y = Math.sin(elapsed * 0.15) * 0.15;
          }
        });
        safeAccessHighlights.forEach((highlight) => {
          const {
            material,
            baseIntensity = 0,
            amplitude = 0,
            speed = 1,
            phaseOffset = 0,
            baseOpacity,
            opacityAmplitude = 0,
          } = highlight;
          if (material && typeof material.emissiveIntensity === 'number') {
            const emissivePulse =
              baseIntensity + Math.sin(elapsed * speed + phaseOffset) * amplitude;
            material.emissiveIntensity = Math.max(0, emissivePulse);
          }
          if (
            typeof baseOpacity === 'number' &&
            typeof material.opacity === 'number' &&
            material.transparent
          ) {
            const opacityPulse =
              baseOpacity + Math.sin(elapsed * speed + phaseOffset) * opacityAmplitude;
            material.opacity = THREE.MathUtils.clamp(opacityPulse, 0, 1);
          }
        });
        yarnFlowControllers.forEach((controller) => {
          if (!controller.texture || !controller.material) {
            return;
          }
          controller.texture.offset.x = (controller.texture.offset.x + delta * controller.speed) % 1;
          const target = yarnExtrusionActive
            ? controller.activeIntensity
            : controller.restIntensity;
          controller.currentIntensity = THREE.MathUtils.damp(
            controller.currentIntensity,
            target,
            4.0,
            delta,
          );
          controller.material.emissiveIntensity = controller.currentIntensity;
        });
        updatePatternPreview(elapsed);

        controls.update();
        renderer.render(scene, camera);
      }

      renderer.setAnimationLoop(animate);

      function updateStatus(message) {
        statusElement.textContent = message;
      }

      function onPointerMove(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(interactiveMeshes, false);
        if (intersects.length > 0) {
          const target =
            intersects.find((hit) => !hit.object.userData.hoverPassthrough) || intersects[0];
          updateStatus(target.object.userData.hoverText || '');
        } else {
          updateStatus('Ready for the next Wove product line…');
        }
      }

      window.addEventListener('pointermove', onPointerMove);

      function onPointerDown(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length === 0) {
          return;
        }

        const cluster = findClusterFromObject(intersects[0].object);
        if (cluster) {
          selectCluster(cluster);
        }
      }

      window.addEventListener('pointerdown', onPointerDown);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      updateStatus('Ready for the next Wove product line…');
    </script>
  </body>
</html>
