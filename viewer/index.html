<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Wove Product Assembly Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at top, #1e1f2f, #0b0c13);
        color: #f5f5f5;
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      #overlay {
        position: fixed;
        top: 1.5rem;
        left: 1.5rem;
        max-width: 22rem;
        padding: 1.25rem 1.5rem;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        border-radius: 0.75rem;
        backdrop-filter: blur(8px);
        box-shadow: 0 0.75rem 2rem rgba(0, 0, 0, 0.35);
      }

      #overlay h1 {
        margin: 0 0 0.5rem;
        font-size: 1.35rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      #overlay p {
        margin: 0 0 0.75rem;
        font-size: 0.95rem;
        line-height: 1.4;
      }

      #overlay ul {
        margin: 0;
        padding-left: 1.1rem;
        font-size: 0.9rem;
        line-height: 1.35;
      }

      #roadmap-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #roadmap-panel h2 {
        margin: 0 0 0.4rem;
        font-size: 1rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #9bb7ff;
      }

      #roadmap-panel p {
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.4;
        color: #e5e7ff;
      }

      #status {
        position: fixed;
        bottom: 1.2rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.5rem 0.85rem;
        border-radius: 999px;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }

      @media (max-width: 780px) {
        #overlay {
          left: 50%;
          transform: translateX(-50%);
          width: calc(100% - 3rem);
        }
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Wove Assembly</h1>
      <p>
        Explore the evolving assembly line for Wove robotics. Start with
        <strong>v1c</strong>, our first crochet robot, and imagine where future
        models will slot in as the roadmap expands.
      </p>
      <ul>
        <li>Drag to orbit, scroll to zoom, right-click to pan.</li>
        <li>Hover a component to read about its function.</li>
        <li>
          Check back often—new Codex tasks will iterate on this experience over
          time.
        </li>
        <li>
          Find the translucent workpiece support bed to see how swatches mount
          for calibration runs.
        </li>
        <li>
          The glowing safety interlocks mark physical end stops and the
          emergency stop switch described in the v1c roadmap.
        </li>
        <li>Click a pedestal to spotlight its roadmap milestone.</li>
      </ul>
      <div id="roadmap-panel">
        <h2 id="roadmap-title">Assembly Roadmap</h2>
        <p id="roadmap-description">
          Select a product cluster to learn how it advances the automation journey.
        </p>
      </div>
    </div>
    <div id="status">Initializing viewer…</div>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c13);

      const statusElement = document.getElementById('status');
      const roadmapTitleElement = document.getElementById('roadmap-title');
      const roadmapDescriptionElement = document.getElementById('roadmap-description');

      const pointer = new THREE.Vector2();
      const raycaster = new THREE.Raycaster();
      const interactiveMeshes = [];
      const productClusters = [];
      let activeCluster = null;
      const selectionRingHeight = 0.06;

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        500,
      );
      camera.position.set(12, 8, 18);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 60;
      controls.maxPolarAngle = Math.PI * 0.49;

      const ambientLight = new THREE.AmbientLight(0xbac4ff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xf1f3ff, 1.2);
      keyLight.position.set(10, 16, 10);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x6c79ff, 0.6);
      fillLight.position.set(-6, 12, -12);
      scene.add(fillLight);

      const groundGeometry = new THREE.CircleGeometry(16, 64);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x131421,
        roughness: 0.85,
        metalness: 0.2,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(32, 32, 0x2e3a68, 0x1d233c);
      scene.add(gridHelper);

      const selectionRingGeometry = new THREE.RingGeometry(1.0, 1.3, 64);
      const selectionRingMaterial = new THREE.MeshBasicMaterial({
        color: 0x8ab4ff,
        transparent: true,
        opacity: 0.45,
        side: THREE.DoubleSide,
      });
      const selectionRing = new THREE.Mesh(selectionRingGeometry, selectionRingMaterial);
      selectionRing.rotation.x = -Math.PI / 2;
      selectionRing.position.y = selectionRingHeight;
      selectionRing.visible = false;
      selectionRing.scale.setScalar(1.0);
      scene.add(selectionRing);

      function buildLabel(text, color = '#f5f5f5') {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const padding = 32;
        const fontSize = 56;
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        const metrics = context.measureText(text);
        canvas.width = metrics.width + padding * 2;
        canvas.height = fontSize + padding * 1.4;

        context.fillStyle = 'rgba(12, 13, 25, 0.8)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.strokeStyle = 'rgba(245, 245, 245, 0.35)';
        context.lineWidth = 4;
        context.strokeRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = color;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        const baseScale = 0.02;
        sprite.scale.set(canvas.width * baseScale, canvas.height * baseScale, 1);
        return sprite;
      }

      function addHoverInfo(mesh, text, options = {}) {
        mesh.userData.hoverText = text;
        mesh.userData.hoverPassthrough = options.passthrough ?? false;
        interactiveMeshes.push(mesh);
      }

      function createSafetyShield() {
        const shieldGroup = new THREE.Group();
        shieldGroup.name = 'safety-shield';

        const shellMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x9fb7ff,
          transparent: true,
          opacity: 0.18,
          roughness: 0.08,
          metalness: 0.05,
          transmission: 0.82,
          thickness: 0.5,
          clearcoat: 0.6,
          clearcoatRoughness: 0.08,
        });

        const shell = new THREE.Mesh(
          new THREE.BoxGeometry(7.6, 4.8, 5.6),
          shellMaterial,
        );
        shell.position.set(0, 2.6, 0.3);
        shell.castShadow = false;
        shell.receiveShadow = false;
        shieldGroup.add(shell);
        addHoverInfo(
          shell,
          'Polycarbonate shield: translucent enclosure that keeps hands clear during motion demos.',
          { passthrough: true },
        );

        const edgeMaterial = new THREE.LineBasicMaterial({
          color: 0xc4d7ff,
          transparent: true,
          opacity: 0.55,
        });
        const shellEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(shell.geometry),
          edgeMaterial,
        );
        shell.add(shellEdges);

        const hingeMaterial = new THREE.MeshStandardMaterial({
          color: 0x4d5c87,
          metalness: 0.55,
          roughness: 0.35,
          emissive: 0x20283f,
        });

        const hinge = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 4.4, 24),
          hingeMaterial,
        );
        hinge.rotation.z = Math.PI / 2;
        hinge.position.set(3.65, 2.6, 0.3);
        hinge.castShadow = true;
        shieldGroup.add(hinge);

        const doorMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xaec9ff,
          transparent: true,
          opacity: 0.22,
          roughness: 0.1,
          transmission: 0.88,
          thickness: 0.45,
          metalness: 0.02,
        });

        const doorPivot = new THREE.Group();
        doorPivot.position.set(3.65, 2.6, 0.3);
        doorPivot.rotation.y = THREE.MathUtils.degToRad(-18);

        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.14, 4.4, 5.2),
          doorMaterial,
        );
        door.castShadow = false;
        door.receiveShadow = false;
        doorPivot.add(door);
        addHoverInfo(
          door,
          'Access door swings open for maintenance while keeping bystanders protected.',
        );

        const doorEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(door.geometry),
          new THREE.LineBasicMaterial({
            color: 0x90b4ff,
            transparent: true,
            opacity: 0.65,
          }),
        );
        door.add(doorEdges);
        shieldGroup.add(doorPivot);

        const latch = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.6, 0.6),
          hingeMaterial,
        );
        latch.position.set(3.9, 2.0, 2.8);
        latch.rotation.y = THREE.MathUtils.degToRad(-18);
        latch.castShadow = true;
        shieldGroup.add(latch);

        const walkwayGeometry = new THREE.PlaneGeometry(3.6, 1.8);
        const walkwayMaterial = new THREE.MeshStandardMaterial({
          color: 0x5efed8,
          emissive: 0x1b7a63,
          emissiveIntensity: 0.6,
          metalness: 0.1,
          roughness: 0.45,
          transparent: true,
          opacity: 0.55,
          side: THREE.DoubleSide,
        });
        const walkway = new THREE.Mesh(walkwayGeometry, walkwayMaterial);
        walkway.rotation.x = -Math.PI / 2;
        walkway.position.set(1.4, 0.06, 0.3);
        walkway.castShadow = false;
        walkway.receiveShadow = false;
        shieldGroup.add(walkway);
        addHoverInfo(
          walkway,
          'Safe access path — follow the highlighted lane when stepping into the enclosure.',
        );

        const walkwayEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(new THREE.PlaneGeometry(3.6, 1.8)),
          new THREE.LineBasicMaterial({
            color: 0x96ffe6,
            transparent: true,
            opacity: 0.8,
          }),
        );
        walkwayEdges.rotation.x = -Math.PI / 2;
        walkwayEdges.position.copy(walkway.position);
        shieldGroup.add(walkwayEdges);

        const walkwayLight = new THREE.PointLight(0x82ffe0, 1.2, 6.0);
        walkwayLight.position.set(0.4, 1.1, 0.3);
        shieldGroup.add(walkwayLight);

        const footMaterial = new THREE.MeshStandardMaterial({
          color: 0xd9fff2,
          emissive: 0x2f8f6b,
          emissiveIntensity: 0.45,
          transparent: true,
          opacity: 0.85,
          side: THREE.DoubleSide,
        });
        const footGeometry = new THREE.CircleGeometry(0.32, 32);
        const footPositions = [
          new THREE.Vector3(2.3, 0.07, 0.55),
          new THREE.Vector3(1.4, 0.07, 0.1),
          new THREE.Vector3(0.5, 0.07, -0.25),
        ];
        footPositions.forEach((position, index) => {
          const foot = new THREE.Mesh(footGeometry, footMaterial);
          foot.rotation.x = -Math.PI / 2;
          foot.scale.set(0.55 + (index % 2) * 0.08, 1.0, 1.0);
          foot.position.copy(position);
          foot.castShadow = false;
          foot.receiveShadow = false;
          shieldGroup.add(foot);
        });

        const walkwayLabel = buildLabel('Safe Access Path', '#b9ffe9');
        walkwayLabel.position.set(0.4, 0.95, -0.4);
        walkwayLabel.scale.multiplyScalar(0.42);
        shieldGroup.add(walkwayLabel);

        const glow = new THREE.PointLight(0x9fbfff, 0.8, 7.0);
        glow.position.set(3.1, 3.8, 2.2);
        shieldGroup.add(glow);

        const label = buildLabel('Polycarbonate Shield', '#d7e5ff');
        label.position.set(0, 4.9, 0.3);
        label.scale.multiplyScalar(0.55);
        shieldGroup.add(label);

        return shieldGroup;
      }

      function createV1CAssembly() {
        const group = new THREE.Group();
        group.name = 'v1c-assembly';

        const chassisMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a9bff,
          metalness: 0.35,
          roughness: 0.4,
        });
        const chassis = new THREE.Mesh(
          new THREE.BoxGeometry(6, 0.8, 4),
          chassisMaterial,
        );
        chassis.position.y = 0.4;
        chassis.castShadow = true;
        chassis.receiveShadow = true;
        group.add(chassis);
        addHoverInfo(
          chassis,
          'v1c base platform — houses the drive electronics and bed alignment rails.',
        );

        const bedMaterial = new THREE.MeshStandardMaterial({
          color: 0xbfe4ff,
          metalness: 0.2,
          roughness: 0.3,
          transparent: true,
          opacity: 0.9,
          emissive: 0x1b3a4f,
        });
        const bed = new THREE.Mesh(new THREE.BoxGeometry(4.8, 0.25, 3.2), bedMaterial);
        bed.position.set(0, 0.9, 0.2);
        bed.castShadow = true;
        bed.receiveShadow = true;
        group.add(bed);
        addHoverInfo(
          bed,
          'Workpiece support bed: removable build plate with magnetic anchors for swatch staging.',
        );

        const anchorGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.12, 20);
        const anchorMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd27f,
          metalness: 0.6,
          roughness: 0.4,
          emissive: 0x332100,
        });
        const anchorPositions = [
          new THREE.Vector3(-1.8, 1.03, -1.0),
          new THREE.Vector3(1.8, 1.03, -1.0),
          new THREE.Vector3(-1.8, 1.03, 1.2),
          new THREE.Vector3(1.8, 1.03, 1.2),
        ];
        anchorPositions.forEach((position) => {
          const anchor = new THREE.Mesh(anchorGeometry, anchorMaterial);
          anchor.position.copy(position);
          anchor.rotation.x = Math.PI / 2;
          anchor.castShadow = true;
          group.add(anchor);
        });

        const gantryMaterial = new THREE.MeshStandardMaterial({
          color: 0xffc857,
          metalness: 0.2,
          roughness: 0.3,
          emissive: 0x332400,
        });
        const gantry = new THREE.Mesh(new THREE.BoxGeometry(0.6, 4.5, 6.5), gantryMaterial);
        gantry.position.set(0, 2.75, 0.35);
        gantry.castShadow = true;
        group.add(gantry);
        addHoverInfo(
          gantry,
          'Dual-axis gantry lifts the crocheting effector while guiding yarn tension.',
        );

        const effectorMaterial = new THREE.MeshStandardMaterial({
          color: 0xff6f91,
          roughness: 0.35,
          metalness: 0.15,
          emissive: 0x401220,
        });
        const effectorGeometry = new THREE.CylinderGeometry(0.45, 0.6, 2.2, 32);
        const effector = new THREE.Mesh(effectorGeometry, effectorMaterial);
        effector.rotation.z = Math.PI / 2;
        effector.position.set(1.8, 2.4, 0.6);
        effector.castShadow = true;
        group.add(effector);
        addHoverInfo(
          effector,
          'Crochet effector: hooks yarn, executes stitch choreography, and measures tension.',
        );

        const spoolMaterial = new THREE.MeshStandardMaterial({
          color: 0xd1d5ff,
          metalness: 0.1,
          roughness: 0.6,
        });
        const spool = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 2.8, 32), spoolMaterial);
        spool.position.set(-2.4, 2.1, -1.6);
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        group.add(spool);
        addHoverInfo(
          spool,
          'Yarn management module: active tensioning keeps stitches uniform throughout runs.',
        );

        const sensorAssembly = new THREE.Group();
        sensorAssembly.position.set(-1.1, 1.9, -1.9);

        const armMaterial = new THREE.MeshStandardMaterial({
          color: 0x7b8bff,
          metalness: 0.25,
          roughness: 0.35,
          emissive: 0x1c224d,
        });
        const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.4, 24), armMaterial);
        arm.rotation.z = Math.PI / 2.6;
        arm.position.set(0.2, 0.1, 0);
        arm.castShadow = true;
        sensorAssembly.add(arm);

        const hinge = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, 0.32, 24),
          new THREE.MeshStandardMaterial({
            color: 0x303756,
            metalness: 0.5,
            roughness: 0.2,
          }),
        );
        hinge.rotation.z = Math.PI / 2;
        hinge.position.set(-0.4, -0.05, 0);
        hinge.castShadow = true;
        sensorAssembly.add(hinge);

        const sensorHousing = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.35, 0.6),
          new THREE.MeshStandardMaterial({
            color: 0xffd59d,
            metalness: 0.2,
            roughness: 0.25,
            emissive: 0x3a260a,
          }),
        );
        sensorHousing.position.set(0.6, 0.18, 0);
        sensorHousing.castShadow = true;
        sensorAssembly.add(sensorHousing);
        addHoverInfo(
          sensorHousing,
          'Hall-effect tension sensor: monitors deflection in the yarn path for feedback control.',
        );

        const sensorIndicator = new THREE.PointLight(0xffc98a, 1.4, 3.5);
        sensorIndicator.position.set(0.6, 0.3, 0);
        sensorAssembly.add(sensorIndicator);

        const sensorLabel = buildLabel('Hall-Effect Sensor', '#ffd59d');
        sensorLabel.position.set(0.6, 0.9, 0);
        sensorLabel.scale.multiplyScalar(0.65);
        sensorAssembly.add(sensorLabel);

        group.add(sensorAssembly);

        const displayLabel = buildLabel('v1c – Crochet Robot', '#8ab4ff');
        displayLabel.position.set(0, 4.3, 0);
        group.add(displayLabel);

        const bedLabel = buildLabel('Workpiece Support Bed', '#b6f0ff');
        bedLabel.position.set(0, 1.6, -1.6);
        bedLabel.scale.multiplyScalar(0.85);
        group.add(bedLabel);

        const safetyShield = createSafetyShield();
        group.add(safetyShield);

        function createEmergencyStop() {
          const emergencyGroup = new THREE.Group();
          emergencyGroup.position.set(2.2, 0.6, 1.35);

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.55, 0.55, 0.16, 48),
            new THREE.MeshStandardMaterial({
              color: 0x15161f,
              metalness: 0.5,
              roughness: 0.2,
            }),
          );
          base.castShadow = true;
          emergencyGroup.add(base);

          const button = new THREE.Mesh(
            new THREE.CylinderGeometry(0.45, 0.5, 0.28, 48),
            new THREE.MeshStandardMaterial({
              color: 0xff4d4f,
              emissive: 0x5f0608,
              emissiveIntensity: 0.8,
              metalness: 0.2,
              roughness: 0.35,
            }),
          );
          button.position.y = 0.21;
          button.castShadow = true;
          emergencyGroup.add(button);
          addHoverInfo(
            button,
            'Emergency stop switch — instantly cuts power to the v1c motion system.',
          );

          const halo = new THREE.Mesh(
            new THREE.TorusGeometry(0.52, 0.05, 16, 64),
            new THREE.MeshStandardMaterial({
              color: 0xff8083,
              emissive: 0x701010,
              emissiveIntensity: 0.7,
              metalness: 0.35,
              roughness: 0.15,
              transparent: true,
              opacity: 0.85,
            }),
          );
          halo.rotation.x = Math.PI / 2;
          halo.position.y = 0.08;
          emergencyGroup.add(halo);

          const indicator = new THREE.PointLight(0xff494c, 2.3, 4.2);
          indicator.position.y = 0.45;
          emergencyGroup.add(indicator);

          const label = buildLabel('Safety Interlock', '#ffb3b3');
          label.position.set(0, 0.95, 0);
          emergencyGroup.add(label);

          return emergencyGroup;
        }

        function createEndStop(position, axisLabel) {
          const endStop = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.5, 0.35),
            new THREE.MeshStandardMaterial({
              color: 0xffc285,
              metalness: 0.4,
              roughness: 0.25,
              emissive: 0x462501,
              emissiveIntensity: 0.4,
            }),
          );
          endStop.position.copy(position);
          endStop.castShadow = true;
          endStop.name = `end-stop-${axisLabel.toLowerCase()}`;
          addHoverInfo(
            endStop,
            `${axisLabel}-axis end stop — trips firmware limits before overtravel can occur.`,
          );
          return endStop;
        }

        const emergencyStop = createEmergencyStop();
        group.add(emergencyStop);

        const endStops = [
          createEndStop(new THREE.Vector3(3.1, 2.1, 1.1), 'X'),
          createEndStop(new THREE.Vector3(-2.2, 3.6, -2.6), 'Y'),
          createEndStop(new THREE.Vector3(-1.0, 0.95, -1.4), 'Z'),
        ];
        endStops.forEach((stop) => group.add(stop));

        return group;
      }

      function createPedestalCluster(options) {
        const {
          name,
          roadmap,
          hoverText,
          position,
          accentColor,
          hoverColor,
          selectionScale = 0.54,
          selectionHeight = 0.24,
          buildDisplay,
          displayOffset = 0,
        } = options;

        const group = new THREE.Group();
        group.position.copy(position);
        group.userData.name = name;
        group.userData.roadmap = roadmap;
        group.userData.selectionScale = selectionScale;
        group.userData.selectionHeight = selectionHeight;

        const base = new THREE.Mesh(
          new THREE.CylinderGeometry(1.5, 1.8, 0.4, 48),
          new THREE.MeshStandardMaterial({
            color: 0x191c2a,
            roughness: 0.8,
            metalness: 0.15,
          }),
        );
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        const column = new THREE.Mesh(
          new THREE.CylinderGeometry(0.55, 0.75, 1.3, 48),
          new THREE.MeshStandardMaterial({
            color: accentColor,
            emissive: new THREE.Color(accentColor).multiplyScalar(0.35),
            metalness: 0.25,
            roughness: 0.45,
          }),
        );
        column.position.y = 0.85;
        column.castShadow = true;
        group.add(column);

        const platform = new THREE.Mesh(
          new THREE.CylinderGeometry(1.1, 1.1, 0.22, 48),
          new THREE.MeshStandardMaterial({
            color: hoverColor,
            emissive: new THREE.Color(hoverColor).multiplyScalar(0.25),
            metalness: 0.35,
            roughness: 0.3,
          }),
        );
        platform.position.y = 1.48;
        platform.castShadow = true;
        platform.name = `${name.toLowerCase().replace(/\s+/g, '-')}-pedestal`;
        group.add(platform);
        addHoverInfo(platform, hoverText);

        const glow = new THREE.PointLight(accentColor, 1.2, 8.0);
        glow.position.y = 1.7;
        group.add(glow);

        const halo = new THREE.Mesh(
          new THREE.TorusGeometry(1.05, 0.04, 16, 96),
          new THREE.MeshStandardMaterial({
            color: accentColor,
            emissive: new THREE.Color(accentColor).multiplyScalar(0.5),
            emissiveIntensity: 0.6,
            transparent: true,
            opacity: 0.8,
          }),
        );
        halo.rotation.x = Math.PI / 2;
        halo.position.y = 1.62;
        group.add(halo);

        const label = buildLabel(name, '#f5f9ff');
        label.position.set(0, 2.25, 0);
        label.scale.multiplyScalar(0.6);
        group.add(label);

        if (typeof buildDisplay === 'function') {
          const display = buildDisplay();
          if (display) {
            const platformTop = 1.48 + 0.11;
            display.position.y += platformTop + displayOffset;
            group.add(display);
          }
        }

        return group;
      }

      function createTensionLabDisplay() {
        const group = new THREE.Group();
        group.name = 'tension-lab-display';

        const bench = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.12, 1.1),
          new THREE.MeshStandardMaterial({
            color: 0x1a2f3a,
            metalness: 0.35,
            roughness: 0.4,
          }),
        );
        bench.position.y = 0.18;
        bench.castShadow = true;
        bench.receiveShadow = true;
        group.add(bench);
        addHoverInfo(
          bench,
          'Calibration bench — stages load cells and fixture rails for yarn testing.',
        );

        const rail = new THREE.Mesh(
          new THREE.BoxGeometry(1.6, 0.08, 0.14),
          new THREE.MeshStandardMaterial({
            color: 0x0f1f28,
            metalness: 0.3,
            roughness: 0.35,
          }),
        );
        rail.position.set(-0.2, 0.32, -0.04);
        rail.castShadow = true;
        group.add(rail);

        const spoolRig = new THREE.Group();
        spoolRig.position.set(0.38, 0.36, 0.02);

        const spoolCore = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.92, 24),
          new THREE.MeshStandardMaterial({
            color: 0x324451,
            metalness: 0.55,
            roughness: 0.28,
          }),
        );
        spoolCore.rotation.z = Math.PI / 2;
        spoolCore.castShadow = true;
        spoolRig.add(spoolCore);

        const spool = new THREE.Mesh(
          new THREE.CylinderGeometry(0.42, 0.42, 0.8, 48),
          new THREE.MeshStandardMaterial({
            color: 0xffe3a1,
            emissive: 0x94763a,
            emissiveIntensity: 0.35,
            roughness: 0.45,
          }),
        );
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        spoolRig.add(spool);
        addHoverInfo(
          spool,
          'Tension spool rig — calibrates hall-effect sensors before they reach production cells.',
        );

        group.add(spoolRig);

        const carriage = new THREE.Mesh(
          new THREE.BoxGeometry(0.34, 0.26, 0.86),
          new THREE.MeshStandardMaterial({
            color: 0x1c4f5c,
            metalness: 0.3,
            roughness: 0.32,
          }),
        );
        carriage.position.set(-0.62, 0.42, -0.05);
        carriage.castShadow = true;
        group.add(carriage);
        addHoverInfo(
          carriage,
          'Sensor carriage — slides along the rail to align load cells with the yarn path.',
        );

        const sensorTower = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.62, 32),
          new THREE.MeshStandardMaterial({
            color: 0x7df0ff,
            emissive: 0x1b6d7d,
            emissiveIntensity: 0.6,
            metalness: 0.4,
            roughness: 0.25,
          }),
        );
        sensorTower.position.set(-0.62, 0.74, 0.24);
        sensorTower.castShadow = true;
        group.add(sensorTower);

        const gaugeDisplay = new THREE.Mesh(
          new THREE.BoxGeometry(0.34, 0.24, 0.18),
          new THREE.MeshStandardMaterial({
            color: 0x0d1c28,
            emissive: 0x163b4d,
            emissiveIntensity: 0.55,
            metalness: 0.28,
            roughness: 0.32,
          }),
        );
        gaugeDisplay.position.set(-0.62, 0.82, 0.52);
        gaugeDisplay.castShadow = true;
        group.add(gaugeDisplay);
        addHoverInfo(
          gaugeDisplay,
          'Live tension telemetry — maps hall sensor readings to grams for planner feedback.',
        );

        const indicator = new THREE.PointLight(0x7df0ff, 1.4, 4.0);
        indicator.position.set(-0.62, 1.18, 0.52);
        group.add(indicator);

        return group;
      }

      function createMaterialPrepDisplay() {
        const group = new THREE.Group();
        group.name = 'material-prep-display';

        const table = new THREE.Mesh(
          new THREE.BoxGeometry(2.1, 0.14, 1.2),
          new THREE.MeshStandardMaterial({
            color: 0x1f2d24,
            metalness: 0.32,
            roughness: 0.48,
          }),
        );
        table.position.y = 0.18;
        table.castShadow = true;
        table.receiveShadow = true;
        group.add(table);
        addHoverInfo(
          table,
          'Material prep bench — stages yarn cones and QA tools before automation.',
        );

        const legGeometry = new THREE.BoxGeometry(0.16, 0.42, 0.16);
        const legMaterial = new THREE.MeshStandardMaterial({
          color: 0x16251b,
          metalness: 0.28,
          roughness: 0.42,
        });
        [
          [-0.92, 0.0, -0.5],
          [0.92, 0.0, -0.5],
          [-0.92, 0.0, 0.5],
          [0.92, 0.0, 0.5],
        ].forEach(([x, y, z]) => {
          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.position.set(x, y, z);
          leg.castShadow = true;
          group.add(leg);
        });

        const coneTree = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 0.92, 24),
          new THREE.MeshStandardMaterial({
            color: 0x2a3f30,
            metalness: 0.33,
            roughness: 0.36,
            emissive: 0x102216,
            emissiveIntensity: 0.4,
          }),
        );
        coneTree.position.set(-0.62, 0.64, 0.1);
        coneTree.castShadow = true;
        group.add(coneTree);

        const coneColors = [0xffe1a1, 0xffc4d0, 0xb8ecff];
        coneColors.forEach((color, index) => {
          const cone = new THREE.Mesh(
            new THREE.CylinderGeometry(0.34, 0.22, 0.46, 32),
            new THREE.MeshStandardMaterial({
              color,
              emissive: new THREE.Color(color).multiplyScalar(0.2),
              emissiveIntensity: 0.35,
              roughness: 0.38,
            }),
          );
          cone.rotation.z = Math.PI / 2;
          cone.position.set(-0.62, 0.48 + index * 0.24, 0.1);
          cone.castShadow = true;
          group.add(cone);
        });
        addHoverInfo(
          coneTree,
          'Cone tree — organizes dyed yarn sets with quick-grab color tags.',
        );

        const prepBins = new THREE.Group();
        prepBins.position.set(0.58, 0.36, -0.32);
        group.add(prepBins);

        const binGeometry = new THREE.BoxGeometry(0.46, 0.26, 0.46);
        const binColors = [0x325444, 0x3e6150, 0x274236];
        binColors.forEach((color, index) => {
          const bin = new THREE.Mesh(
            binGeometry,
            new THREE.MeshStandardMaterial({
              color,
              metalness: 0.18,
              roughness: 0.4,
              emissive: new THREE.Color(color).multiplyScalar(0.18),
            }),
          );
          bin.position.set(index * 0.52 - 0.52, 0, 0);
          bin.castShadow = true;
          prepBins.add(bin);
        });
        addHoverInfo(
          prepBins,
          'Prep bins — stage bobbins, winding tools, and pre-measured skeins.',
        );

        const scaleBase = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.08, 0.34),
          new THREE.MeshStandardMaterial({
            color: 0x1f1d2d,
            metalness: 0.4,
            roughness: 0.32,
          }),
        );
        scaleBase.position.set(0.38, 0.32, 0.42);
        scaleBase.castShadow = true;
        group.add(scaleBase);

        const scaleDeck = new THREE.Mesh(
          new THREE.BoxGeometry(0.46, 0.04, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6b76ff,
            emissive: 0x2c3080,
            emissiveIntensity: 0.6,
            roughness: 0.28,
          }),
        );
        scaleDeck.position.set(0.38, 0.38, 0.42);
        scaleDeck.castShadow = true;
        group.add(scaleDeck);
        addHoverInfo(
          scaleDeck,
          'Inspection scale — verifies yarn weight and cone swaps before runs.',
        );

        const checklist = new THREE.Mesh(
          new THREE.PlaneGeometry(0.42, 0.58),
          new THREE.MeshStandardMaterial({
            color: 0xc5f1d6,
            emissive: 0x4a8d65,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
          }),
        );
        checklist.position.set(0.1, 0.72, -0.46);
        checklist.rotation.y = -Math.PI / 6;
        checklist.castShadow = true;
        group.add(checklist);
        addHoverInfo(
          checklist,
          'Run cards — log dye lots, spool counts, and prep checks for traceability.',
        );

        const prepLabel = buildLabel('Prep & QA', '#d4ffe5');
        prepLabel.position.set(0.0, 1.0, 0.0);
        prepLabel.scale.multiplyScalar(0.4);
        group.add(prepLabel);

        const workLight = new THREE.PointLight(0x82ffb2, 1.1, 4.8);
        workLight.position.set(-0.6, 1.4, 0.1);
        group.add(workLight);

        return group;
      }

      function createPatternStudioDisplay() {
        const group = new THREE.Group();
        group.name = 'pattern-studio-display';

        const desk = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.12, 1.1),
          new THREE.MeshStandardMaterial({
            color: 0x2d1f24,
            metalness: 0.38,
            roughness: 0.45,
          }),
        );
        desk.position.y = 0.2;
        desk.castShadow = true;
        desk.receiveShadow = true;
        group.add(desk);

        const legGeometry = new THREE.BoxGeometry(0.12, 0.42, 0.12);
        const legMaterial = new THREE.MeshStandardMaterial({
          color: 0x1b1318,
          metalness: 0.35,
          roughness: 0.4,
        });
        [
          [-0.78, 0.01, -0.46],
          [0.78, 0.01, -0.46],
          [-0.78, 0.01, 0.46],
          [0.78, 0.01, 0.46],
        ].forEach(([x, y, z]) => {
          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.position.set(x, y, z);
          leg.castShadow = true;
          group.add(leg);
        });

        const monitorGeometry = new THREE.BoxGeometry(0.08, 0.64, 0.92);
        const monitorMaterial = new THREE.MeshStandardMaterial({
          color: 0x111527,
          emissive: 0x3d4eff,
          emissiveIntensity: 0.68,
          metalness: 0.25,
          roughness: 0.24,
        });
        const leftMonitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
        leftMonitor.position.set(-0.45, 0.6, -0.08);
        leftMonitor.rotation.y = 0.18;
        leftMonitor.castShadow = true;
        group.add(leftMonitor);
        addHoverInfo(
          leftMonitor,
          'Planner console — previews pattern_cli exports with motion overlays.',
        );

        const rightMonitor = leftMonitor.clone();
        rightMonitor.position.set(0.2, 0.6, -0.08);
        rightMonitor.rotation.y = -0.12;
        group.add(rightMonitor);

        const keyboard = new THREE.Mesh(
          new THREE.BoxGeometry(0.62, 0.05, 0.26),
          new THREE.MeshStandardMaterial({
            color: 0x37262d,
            metalness: 0.28,
            roughness: 0.45,
          }),
        );
        keyboard.position.set(-0.1, 0.28, 0.18);
        keyboard.castShadow = true;
        group.add(keyboard);

        const holoBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.36, 0.36, 0.04, 48),
          new THREE.MeshStandardMaterial({
            color: 0x3a2d52,
            metalness: 0.3,
            roughness: 0.35,
          }),
        );
        holoBase.position.set(0.58, 0.28, 0.3);
        holoBase.castShadow = true;
        group.add(holoBase);

        const holoEmitter = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.3, 0.5, 32, 1, true),
          new THREE.MeshStandardMaterial({
            color: 0x8c7dff,
            emissive: 0x4a3aff,
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide,
          }),
        );
        holoEmitter.position.set(0.58, 0.58, 0.3);
        holoEmitter.castShadow = true;
        group.add(holoEmitter);
        addHoverInfo(
          holoEmitter,
          'Holographic planner table — projects stitch simulations for operator dry runs.',
        );

        const planGrid = new THREE.Mesh(
          new THREE.PlaneGeometry(0.72, 0.52),
          new THREE.MeshStandardMaterial({
            color: 0x90a4ff,
            emissive: 0x5367ff,
            emissiveIntensity: 0.75,
            transparent: true,
            opacity: 0.78,
            side: THREE.DoubleSide,
          }),
        );
        planGrid.position.set(0.58, 0.78, 0.3);
        planGrid.rotation.y = Math.PI / 6;
        group.add(planGrid);

        const holoLight = new THREE.PointLight(0x8c7dff, 1.3, 4.5);
        holoLight.position.set(0.58, 1.2, 0.3);
        group.add(holoLight);

        return group;
      }

      function populateProductLines() {
        const dais = new THREE.Mesh(
          new THREE.CylinderGeometry(4.2, 4.6, 0.6, 72),
          new THREE.MeshStandardMaterial({
            color: 0x151726,
            roughness: 0.85,
            metalness: 0.2,
          }),
        );
        dais.position.y = 0.3;
        dais.receiveShadow = true;
        dais.castShadow = true;

        const v1cCluster = new THREE.Group();
        v1cCluster.add(dais);
        const v1cAssembly = createV1CAssembly();
        v1cCluster.add(v1cAssembly);
        v1cCluster.userData.name = 'v1c Crochet Cell';
        v1cCluster.userData.roadmap =
          'Launch-ready crochet automation cell with emergency stop, gantry, and tension lab.';
        v1cCluster.userData.selectionScale = 1.0;
        v1cCluster.userData.selectionHeight = 0.32;
        scene.add(v1cCluster);
        productClusters.push(v1cCluster);
        addHoverInfo(
          dais,
          'Central robotics cell — houses the v1c crochet robot and its safety perimeter.',
        );

        const daisGlow = new THREE.PointLight(0x7fa8ff, 1.6, 26.0);
        daisGlow.position.set(0, 4.8, 0);
        v1cCluster.add(daisGlow);

        const clusterDefinitions = [
          {
            name: 'Tension Lab',
            roadmap:
              'Calibrates hall sensors, measures yarn pull force, and tunes servo-driven feed loops.',
            hoverText:
              'Tension lab pedestal — stage load cells and spool fixtures before gantry trials.',
            position: new THREE.Vector3(-6.8, 0, -3.5),
            accentColor: 0x7df0ff,
            hoverColor: 0x21404f,
            buildDisplay: createTensionLabDisplay,
          },
          {
            name: 'Material Prep Pod',
            roadmap:
              'Preps yarn cones, QA scales, and dye lots before the crochet cell loads them.',
            hoverText:
              'Material prep pedestal — organize cones, prep bins, and traceability run cards.',
            position: new THREE.Vector3(-6.4, 0, 3.5),
            accentColor: 0x82ffb2,
            hoverColor: 0x1a3525,
            buildDisplay: createMaterialPrepDisplay,
          },
          {
            name: 'Pattern Studio',
            roadmap:
              'Interactive planner hub translating pattern_cli exports into operator-ready motion previews.',
            hoverText:
              'Pattern studio pedestal — review planner exports and prep automation scripts.',
            position: new THREE.Vector3(7.1, 0, -2.6),
            accentColor: 0xffc47d,
            hoverColor: 0x47331e,
            buildDisplay: createPatternStudioDisplay,
          },
          {
            name: 'v1k Research Rig',
            roadmap:
              'Future knitting-focused platform inheriting motion control and safety architecture.',
            hoverText:
              'v1k research pedestal — staging area for the knitting-focused successor platform.',
            position: new THREE.Vector3(0, 0, 7.2),
            accentColor: 0xc0a9ff,
            hoverColor: 0x3a2d52,
          },
        ];

        clusterDefinitions.forEach((definition) => {
          const cluster = createPedestalCluster(definition);
          scene.add(cluster);
          productClusters.push(cluster);
        });
      }

      populateProductLines();

      function updateRoadmapPanel(title, description) {
        roadmapTitleElement.textContent = title;
        roadmapDescriptionElement.textContent = description;
      }

      function selectCluster(cluster) {
        if (!cluster) {
          activeCluster = null;
          selectionRing.visible = false;
          updateRoadmapPanel(
            'Assembly Roadmap',
            'Select a product cluster to learn how it advances the automation journey.',
          );
          return;
        }

        if (activeCluster === cluster) {
          return;
        }

        activeCluster = cluster;
        selectionRing.visible = true;
        const targetScale = cluster.userData.selectionScale ?? 1;
        selectionRing.scale.setScalar(targetScale);
        const targetHeight = cluster.userData.selectionHeight ?? selectionRingHeight;
        selectionRing.position.set(cluster.position.x, targetHeight, cluster.position.z);
        updateRoadmapPanel(cluster.userData.name, cluster.userData.roadmap);
      }

      if (productClusters.length > 0) {
        selectCluster(productClusters[0]);
      }

      function setPointerFromEvent(event) {
        const bounds = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
        pointer.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
      }

      function findClusterFromObject(object) {
        let current = object;
        while (current) {
          if (current.userData && current.userData.roadmap) {
            return current;
          }
          current = current.parent;
        }
        return null;
      }

      const clock = new THREE.Clock();

      function animate() {
        const elapsed = clock.getElapsedTime();
        scene.traverse((object) => {
          if (object.name === 'v1c-assembly') {
            object.rotation.y = Math.sin(elapsed * 0.15) * 0.15;
          }
        });

        controls.update();
        renderer.render(scene, camera);
      }

      renderer.setAnimationLoop(animate);

      function updateStatus(message) {
        statusElement.textContent = message;
      }

      function onPointerMove(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(interactiveMeshes, false);
        if (intersects.length > 0) {
          const target =
            intersects.find((hit) => !hit.object.userData.hoverPassthrough) || intersects[0];
          updateStatus(target.object.userData.hoverText || '');
        } else {
          updateStatus('Ready for the next Wove product line…');
        }
      }

      window.addEventListener('pointermove', onPointerMove);

      function onPointerDown(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length === 0) {
          return;
        }

        const cluster = findClusterFromObject(intersects[0].object);
        if (cluster) {
          selectCluster(cluster);
        }
      }

      window.addEventListener('pointerdown', onPointerDown);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      updateStatus('Ready for the next Wove product line…');
    </script>
  </body>
</html>
