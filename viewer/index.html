<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Wove Product Assembly Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at top, #1e1f2f, #0b0c13);
        color: #f5f5f5;
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      #overlay {
        position: fixed;
        top: 1.5rem;
        left: 1.5rem;
        max-width: 22rem;
        padding: 1.25rem 1.5rem;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        border-radius: 0.75rem;
        backdrop-filter: blur(8px);
        box-shadow: 0 0.75rem 2rem rgba(0, 0, 0, 0.35);
      }

      #overlay h1 {
        margin: 0 0 0.5rem;
        font-size: 1.35rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      #overlay p {
        margin: 0 0 0.75rem;
        font-size: 0.95rem;
        line-height: 1.4;
      }

      #overlay ul {
        margin: 0;
        padding-left: 1.1rem;
        font-size: 0.9rem;
        line-height: 1.35;
      }

      #roadmap-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #roadmap-panel h2 {
        margin: 0 0 0.4rem;
        font-size: 1rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #9bb7ff;
      }

      #roadmap-panel p {
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.4;
        color: #e5e7ff;
      }

      #status {
        position: fixed;
        bottom: 1.2rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.5rem 0.85rem;
        border-radius: 999px;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }

      @media (max-width: 780px) {
        #overlay {
          left: 50%;
          transform: translateX(-50%);
          width: calc(100% - 3rem);
        }
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Wove Assembly</h1>
      <p>
        Explore the evolving assembly line for Wove robotics. Start with
        <strong>v1c</strong>, our first crochet robot, and imagine where future
        models will slot in as the roadmap expands.
      </p>
      <ul>
        <li>Drag to orbit, scroll to zoom, right-click to pan.</li>
        <li>Hover a component to read about its function.</li>
        <li>
          Check back often—new Codex tasks will iterate on this experience over
          time.
        </li>
        <li>
          Find the translucent workpiece support bed to see how swatches mount
          for calibration runs.
        </li>
        <li>
          The glowing safety interlocks mark physical end stops and the
          emergency stop switch described in the v1c roadmap.
        </li>
        <li>Click a pedestal to spotlight its roadmap milestone.</li>
      </ul>
      <div id="roadmap-panel">
        <h2 id="roadmap-title">Assembly Roadmap</h2>
        <p id="roadmap-description">
          Select a product cluster to learn how it advances the automation journey.
        </p>
      </div>
    </div>
    <div id="status">Initializing viewer…</div>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c13);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        500,
      );
      camera.position.set(12, 8, 18);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 60;
      controls.maxPolarAngle = Math.PI * 0.49;

      const ambientLight = new THREE.AmbientLight(0xbac4ff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xf1f3ff, 1.2);
      keyLight.position.set(10, 16, 10);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x6c79ff, 0.6);
      fillLight.position.set(-6, 12, -12);
      scene.add(fillLight);

      const groundGeometry = new THREE.CircleGeometry(16, 64);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x131421,
        roughness: 0.85,
        metalness: 0.2,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(32, 32, 0x2e3a68, 0x1d233c);
      scene.add(gridHelper);

      const selectionRingGeometry = new THREE.RingGeometry(3.45, 3.8, 64);
      const selectionRingMaterial = new THREE.MeshBasicMaterial({
        color: 0x8ab4ff,
        transparent: true,
        opacity: 0.45,
        side: THREE.DoubleSide,
      });
      const selectionRing = new THREE.Mesh(selectionRingGeometry, selectionRingMaterial);
      selectionRing.rotation.x = -Math.PI / 2;
      selectionRing.position.y = 0.02;
      selectionRing.visible = false;
      scene.add(selectionRing);

      function buildLabel(text, color = '#f5f5f5') {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const padding = 32;
        const fontSize = 56;
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        const metrics = context.measureText(text);
        canvas.width = metrics.width + padding * 2;
        canvas.height = fontSize + padding * 1.4;

        context.fillStyle = 'rgba(12, 13, 25, 0.8)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.strokeStyle = 'rgba(245, 245, 245, 0.35)';
        context.lineWidth = 4;
        context.strokeRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = color;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        const baseScale = 0.02;
        sprite.scale.set(canvas.width * baseScale, canvas.height * baseScale, 1);
        return sprite;
      }

      function addHoverInfo(mesh, text) {
        mesh.userData.hoverText = text;
        interactiveMeshes.push(mesh);
      }

      function createV1CAssembly() {
        const group = new THREE.Group();
        group.name = 'v1c-assembly';

        const chassisMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a9bff,
          metalness: 0.35,
          roughness: 0.4,
        });
        const chassis = new THREE.Mesh(
          new THREE.BoxGeometry(6, 0.8, 4),
          chassisMaterial,
        );
        chassis.position.y = 0.4;
        chassis.castShadow = true;
        chassis.receiveShadow = true;
        group.add(chassis);
        addHoverInfo(
          chassis,
          'v1c base platform — houses the drive electronics and bed alignment rails.',
        );

        const bedMaterial = new THREE.MeshStandardMaterial({
          color: 0xbfe4ff,
          metalness: 0.2,
          roughness: 0.3,
          transparent: true,
          opacity: 0.9,
          emissive: 0x1b3a4f,
        });
        const bed = new THREE.Mesh(new THREE.BoxGeometry(4.8, 0.25, 3.2), bedMaterial);
        bed.position.set(0, 0.9, 0.2);
        bed.castShadow = true;
        bed.receiveShadow = true;
        group.add(bed);
        addHoverInfo(
          bed,
          'Workpiece support bed: removable build plate with magnetic anchors for swatch staging.',
        );

        const anchorGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.12, 20);
        const anchorMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd27f,
          metalness: 0.6,
          roughness: 0.4,
          emissive: 0x332100,
        });
        const anchorPositions = [
          new THREE.Vector3(-1.8, 1.03, -1.0),
          new THREE.Vector3(1.8, 1.03, -1.0),
          new THREE.Vector3(-1.8, 1.03, 1.2),
          new THREE.Vector3(1.8, 1.03, 1.2),
        ];
        anchorPositions.forEach((position) => {
          const anchor = new THREE.Mesh(anchorGeometry, anchorMaterial);
          anchor.position.copy(position);
          anchor.rotation.x = Math.PI / 2;
          anchor.castShadow = true;
          group.add(anchor);
        });

        const gantryMaterial = new THREE.MeshStandardMaterial({
          color: 0xffc857,
          metalness: 0.2,
          roughness: 0.3,
          emissive: 0x332400,
        });
        const gantry = new THREE.Mesh(new THREE.BoxGeometry(0.6, 4.5, 6.5), gantryMaterial);
        gantry.position.set(0, 2.75, 0.35);
        gantry.castShadow = true;
        group.add(gantry);
        addHoverInfo(
          gantry,
          'Dual-axis gantry lifts the crocheting effector while guiding yarn tension.',
        );

        const effectorMaterial = new THREE.MeshStandardMaterial({
          color: 0xff6f91,
          roughness: 0.35,
          metalness: 0.15,
          emissive: 0x401220,
        });
        const effector = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.6, 2.2, 32), effectorMaterial);
        effector.rotation.z = Math.PI / 2;
        effector.position.set(1.8, 2.4, 0.6);
        effector.castShadow = true;
        group.add(effector);
        addHoverInfo(
          effector,
          'Crochet effector: hooks yarn, executes stitch choreography, and measures tension.',
        );

        const spoolMaterial = new THREE.MeshStandardMaterial({
          color: 0xd1d5ff,
          metalness: 0.1,
          roughness: 0.6,
        });
        const spool = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 2.8, 32), spoolMaterial);
        spool.position.set(-2.4, 2.1, -1.6);
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        group.add(spool);
        addHoverInfo(
          spool,
          'Yarn management module: active tensioning keeps stitches uniform throughout runs.',
        );

        const sensorAssembly = new THREE.Group();
        sensorAssembly.position.set(-1.1, 1.9, -1.9);

        const armMaterial = new THREE.MeshStandardMaterial({
          color: 0x7b8bff,
          metalness: 0.25,
          roughness: 0.35,
          emissive: 0x1c224d,
        });
        const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.4, 24), armMaterial);
        arm.rotation.z = Math.PI / 2.6;
        arm.position.set(0.2, 0.1, 0);
        arm.castShadow = true;
        sensorAssembly.add(arm);

        const hinge = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, 0.32, 24),
          new THREE.MeshStandardMaterial({
            color: 0x303756,
            metalness: 0.5,
            roughness: 0.2,
          }),
        );
        hinge.rotation.z = Math.PI / 2;
        hinge.position.set(-0.4, -0.05, 0);
        hinge.castShadow = true;
        sensorAssembly.add(hinge);

        const sensorHousing = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.35, 0.6),
          new THREE.MeshStandardMaterial({
            color: 0xffd59d,
            metalness: 0.2,
            roughness: 0.25,
            emissive: 0x3a260a,
          }),
        );
        sensorHousing.position.set(0.6, 0.18, 0);
        sensorHousing.castShadow = true;
        sensorAssembly.add(sensorHousing);
        addHoverInfo(
          sensorHousing,
          'Hall-effect tension sensor: monitors deflection in the yarn path for feedback control.',
        );

        const sensorIndicator = new THREE.PointLight(0xffc98a, 1.4, 3.5);
        sensorIndicator.position.set(0.6, 0.3, 0);
        sensorAssembly.add(sensorIndicator);

        const sensorLabel = buildLabel('Hall-Effect Sensor', '#ffd59d');
        sensorLabel.position.set(0.6, 0.9, 0);
        sensorLabel.scale.multiplyScalar(0.65);
        sensorAssembly.add(sensorLabel);

        group.add(sensorAssembly);

        const displayLabel = buildLabel('v1c – Crochet Robot', '#8ab4ff');
        displayLabel.position.set(0, 4.3, 0);
        group.add(displayLabel);

        const bedLabel = buildLabel('Workpiece Support Bed', '#b6f0ff');
        bedLabel.position.set(0, 1.6, -1.6);
        bedLabel.scale.multiplyScalar(0.85);
        group.add(bedLabel);

        function createEmergencyStop() {
          const emergencyGroup = new THREE.Group();
          emergencyGroup.position.set(2.2, 0.6, 1.35);

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.55, 0.55, 0.16, 48),
            new THREE.MeshStandardMaterial({
              color: 0x15161f,
              metalness: 0.5,
              roughness: 0.2,
            }),
          );
          base.castShadow = true;
          emergencyGroup.add(base);

          const button = new THREE.Mesh(
            new THREE.CylinderGeometry(0.45, 0.5, 0.28, 48),
            new THREE.MeshStandardMaterial({
              color: 0xff4d4f,
              emissive: 0x5f0608,
              emissiveIntensity: 0.8,
              metalness: 0.2,
              roughness: 0.35,
            }),
          );
          button.position.y = 0.21;
          button.castShadow = true;
          emergencyGroup.add(button);
          addHoverInfo(
            button,
            'Emergency stop switch — instantly cuts power to the v1c motion system.',
          );

          const halo = new THREE.Mesh(
            new THREE.TorusGeometry(0.52, 0.05, 16, 64),
            new THREE.MeshStandardMaterial({
              color: 0xff8083,
              emissive: 0x701010,
              emissiveIntensity: 0.7,
              metalness: 0.35,
              roughness: 0.15,
              transparent: true,
              opacity: 0.85,
            }),
          );
          halo.rotation.x = Math.PI / 2;
          halo.position.y = 0.08;
          emergencyGroup.add(halo);

          const indicator = new THREE.PointLight(0xff494c, 2.3, 4.2);
          indicator.position.y = 0.45;
          emergencyGroup.add(indicator);

          const label = buildLabel('Safety Interlock', '#ffb3b3');
          label.position.set(0, 0.95, 0);
          emergencyGroup.add(label);

          return emergencyGroup;
        }

        function createEndStop(position, axisLabel) {
          const endStop = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.5, 0.35),
            new THREE.MeshStandardMaterial({
              color: 0xffc285,
              metalness: 0.4,
              roughness: 0.25,
              emissive: 0x462501,
              emissiveIntensity: 0.4,
            }),
          );
          endStop.position.copy(position);
          endStop.castShadow = true;
          endStop.name = `end-stop-${axisLabel.toLowerCase()}`;
          addHoverInfo(
            endStop,
            `${axisLabel}-axis end stop — trips firmware limits before overtravel can occur.`,
          );
          return endStop;
        }

        const emergencyStop = createEmergencyStop();
        group.add(emergencyStop);

        const endStops = [
          createEndStop(new THREE.Vector3(3.1, 2.1, 1.1), 'X'),
          createEndStop(new THREE.Vector3(-2.2, 3.6, -2.6), 'Y'),
          createEndStop(new THREE.Vector3(-1.0, 0.95, -1.4), 'Z'),
        ];
        endStops.forEach((stop) => group.add(stop));

        return group;
      }

      populateProductLines();

      function updateRoadmapPanel(title, description) {
        roadmapTitleElement.textContent = title;
        roadmapDescriptionElement.textContent = description;
      }

      function selectCluster(cluster) {
        if (!cluster) {
          activeCluster = null;
          selectionRing.visible = false;
          updateRoadmapPanel(
            'Assembly Roadmap',
            'Select a product cluster to learn how it advances the automation journey.',
          );
          return;
        }

        if (activeCluster === cluster) {
          return;
        }

        activeCluster = cluster;
        selectionRing.visible = true;
        selectionRing.position.set(cluster.position.x, selectionRingHeight, cluster.position.z);
        updateRoadmapPanel(cluster.userData.name, cluster.userData.roadmap);
      }

      if (productClusters.length > 0) {
        selectCluster(productClusters[0]);
      }

      function setPointerFromEvent(event) {
        const bounds = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
        pointer.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
      }

      function findClusterFromObject(object) {
        let current = object;
        while (current) {
          if (current.userData && current.userData.roadmap) {
            return current;
          }
          current = current.parent;
        }
        return null;
      }

      const clock = new THREE.Clock();

      function animate() {
        const elapsed = clock.getElapsedTime();
        scene.traverse((object) => {
          if (object.name === 'v1c-assembly') {
            object.rotation.y = Math.sin(elapsed * 0.15) * 0.15;
          }
        });

        controls.update();
        renderer.render(scene, camera);
      }

      renderer.setAnimationLoop(animate);

      function updateStatus(message) {
        statusElement.textContent = message;
      }

      function onPointerMove(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(interactiveMeshes, false);
        if (intersects.length > 0) {
          updateStatus(intersects[0].object.userData.hoverText || '');
        } else {
          updateStatus('Ready for the next Wove product line…');
        }
      }

      window.addEventListener('pointermove', onPointerMove);

      function onPointerDown(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length === 0) {
          return;
        }

        const cluster = findClusterFromObject(intersects[0].object);
        if (cluster) {
          selectCluster(cluster);
        }
      }

      window.addEventListener('pointerdown', onPointerDown);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      updateStatus('Ready for the next Wove product line…');
    </script>
  </body>
</html>
