<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Wove Product Assembly Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at top, #1e1f2f, #0b0c13);
        color: #f5f5f5;
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      #overlay {
        position: fixed;
        top: 1.5rem;
        left: 1.5rem;
        max-width: 22rem;
        padding: 1.25rem 1.5rem;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        border-radius: 0.75rem;
        backdrop-filter: blur(8px);
        box-shadow: 0 0.75rem 2rem rgba(0, 0, 0, 0.35);
      }

      #overlay h1 {
        margin: 0 0 0.5rem;
        font-size: 1.35rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      #overlay p {
        margin: 0 0 0.75rem;
        font-size: 0.95rem;
        line-height: 1.4;
      }

      #overlay ul {
        margin: 0;
        padding-left: 1.1rem;
        font-size: 0.9rem;
        line-height: 1.35;
      }

      #roadmap-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #roadmap-panel h2 {
        margin: 0 0 0.4rem;
        font-size: 1rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #9bb7ff;
      }

      #roadmap-panel p {
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.4;
        color: #e5e7ff;
      }

      #pattern-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #pattern-panel h2 {
        margin: 0 0 0.35rem;
        font-size: 0.98rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #ffc27d;
      }

      #pattern-panel p {
        margin: 0 0 0.45rem;
        font-size: 0.88rem;
        line-height: 1.4;
        color: #ffe7c9;
      }

      #pattern-position {
        margin: 0.6rem 0 0;
        font-size: 0.86rem;
        line-height: 1.4;
        color: #ffe7c9;
        letter-spacing: 0.01em;
      }

      #pattern-progress {
        position: relative;
        height: 0.45rem;
        border-radius: 999px;
        overflow: hidden;
        background: rgba(255, 226, 178, 0.2);
        box-shadow: inset 0 0 0 1px rgba(255, 194, 125, 0.35);
      }

      #pattern-progress-bar {
        height: 100%;
        width: 0%;
        border-radius: 999px;
        background: linear-gradient(90deg, #ffb977, #ffe8c9);
        transition: width 0.18s ease-out;
      }

      #planner-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #planner-panel h2 {
        margin: 0 0 0.35rem;
        font-size: 0.97rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #9ee5ff;
      }

      #planner-panel p {
        margin: 0 0 0.45rem;
        font-size: 0.86rem;
        line-height: 1.35;
        color: #d9f4ff;
      }

      #planner-metadata-details {
        margin: 0;
        padding-left: 1.1rem;
        list-style: disc;
        font-size: 0.84rem;
        line-height: 1.35;
        color: #c7ecff;
      }

      #planner-metadata-details li {
        margin-bottom: 0.3rem;
      }

      #yarn-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #yarn-panel h2 {
        margin: 0 0 0.35rem;
        font-size: 0.96rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #8fffe3;
      }

      #yarn-panel p {
        margin: 0 0 0.45rem;
        font-size: 0.86rem;
        line-height: 1.35;
        color: #c8fff2;
      }

      #pattern-defaults {
        margin-top: 0.8rem;
        padding: 0.75rem 0.9rem;
        border-radius: 0.65rem;
        background: rgba(255, 215, 179, 0.08);
        border: 1px solid rgba(255, 194, 125, 0.18);
      }

      #pattern-defaults-status {
        margin: 0 0 0.5rem;
        font-size: 0.84rem;
        line-height: 1.35;
        color: #ffe7c9;
      }

      #pattern-defaults-list {
        margin: 0;
        padding-left: 1.1rem;
        list-style: disc;
        font-size: 0.84rem;
        line-height: 1.35;
        color: #ffe7c9;
      }

      #pattern-defaults-list li {
        margin-bottom: 0.3rem;
      }

      #machine-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #machine-panel h2 {
        margin: 0 0 0.35rem;
        font-size: 0.95rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #9fffd7;
      }

      #machine-panel p {
        margin: 0;
        font-size: 0.86rem;
        line-height: 1.35;
        color: #e5fff1;
      }

      #machine-profile-axes {
        margin: 0.55rem 0 0;
        padding-left: 1.1rem;
        list-style: disc;
        font-size: 0.84rem;
        line-height: 1.35;
        color: #cffff1;
      }

      #machine-profile-axes li {
        margin-bottom: 0.3rem;
      }

      #homing-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #homing-panel h2 {
        margin: 0 0 0.35rem;
        font-size: 0.95rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #ffbfa6;
      }

      #homing-panel p {
        margin: 0 0 0.45rem;
        font-size: 0.86rem;
        line-height: 1.4;
        color: #ffe1d2;
      }

      #overlay [data-tone='warning'] {
        color: #ffb4a2;
      }

      #overlay [data-tone='info'] {
        color: #cdd6ff;
      }

      #overlay [data-tone='ready'] {
        color: #9fffd7;
      }

      #overlay [data-tone='neutral'] {
        color: #e5e7ff;
      }

      #status {
        position: fixed;
        bottom: 1.2rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.5rem 0.85rem;
        border-radius: 999px;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }

      @media (max-width: 780px) {
        #overlay {
          left: 50%;
          transform: translateX(-50%);
          width: calc(100% - 3rem);
        }
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Wove Assembly</h1>
      <p>
        Explore the evolving assembly line for Wove robotics. Start with
        <strong>v1c</strong>, our first crochet robot, and imagine where future
        models will slot in as the roadmap expands.
      </p>
      <ul>
        <li>Drag to orbit, scroll to zoom, right-click to pan.</li>
        <li>Hover a component to read about its function.</li>
        <li>
          Check back often—new Codex tasks will iterate on this experience over
          time.
        </li>
        <li>
          Find the translucent workpiece support bed to see how swatches mount
          for calibration runs.
        </li>
        <li>
          The glowing safety interlocks mark physical end stops and the
          emergency stop switch described in the v1c roadmap.
        </li>
        <li>
          Click a pedestal to spotlight its roadmap milestone and watch the camera glide to frame it.
        </li>
      </ul>
      <div id="roadmap-panel">
        <h2 id="roadmap-title">Assembly Roadmap</h2>
        <p id="roadmap-description">
          Select a product cluster to learn how it advances the automation journey.
        </p>
      </div>
      <div id="pattern-panel">
        <h2>Pattern Studio Preview</h2>
        <p id="pattern-step-index">Loading planner steps…</p>
        <p id="pattern-step">Planner preview warming up.</p>
        <div id="pattern-progress">
          <div id="pattern-progress-bar"></div>
        </div>
        <p id="pattern-position" data-tone="info">
          Position: Loading planner coordinates…
        </p>
        <p id="pattern-bounds" data-tone="neutral">
          Planner bounds warming up…
        </p>
        <div id="pattern-defaults">
          <p id="pattern-defaults-status" data-tone="info">
            Loading planner defaults…
          </p>
          <ul id="pattern-defaults-list"></ul>
        </div>
      </div>
      <div id="planner-panel">
        <h2>Planner Metadata</h2>
        <p id="planner-metadata-status" data-tone="info">
          Loading planner metadata…
        </p>
        <ul id="planner-metadata-details"></ul>
      </div>
      <div id="yarn-panel">
        <h2>Yarn Flow Monitor</h2>
        <p id="yarn-flow-status" data-tone="neutral">
          Yarn flow monitor idle — load a planner preview to track feed events.
        </p>
        <p id="yarn-flow-spool" data-tone="neutral">
          Spool status: Parked until planner preview loads.
        </p>
        <p id="yarn-flow-total" data-tone="neutral">
          Total yarn fed: Awaiting planner preview…
        </p>
        <p id="yarn-flow-queue" data-tone="neutral">
          Remaining feed pulses: Awaiting planner preview…
        </p>
        <p id="yarn-flow-upcoming" data-tone="neutral">
          Next feed pulses: Awaiting planner preview…
        </p>
      </div>
      <div id="machine-panel">
        <h2>Machine Profile</h2>
        <p id="machine-profile-status">Loading machine profile metadata…</p>
        <ul id="machine-profile-axes"></ul>
      </div>
      <div id="homing-panel">
        <h2>Homing Guard</h2>
        <p id="homing-guard-status" data-tone="info">
          Loading homing guard metadata…
        </p>
        <p id="homing-guard-home-state" data-tone="info">
          Waiting for planner defaults…
        </p>
        <p id="homing-guard-position" data-tone="neutral">
          Coordinates: Awaiting planner coordinates…
        </p>
      </div>
    </div>
    <div id="status">Initializing viewer…</div>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c13);

      const statusElement = document.getElementById('status');
      const roadmapTitleElement = document.getElementById('roadmap-title');
      const roadmapDescriptionElement = document.getElementById('roadmap-description');
      const patternStepElement = document.getElementById('pattern-step');
      const patternStepIndexElement = document.getElementById('pattern-step-index');
      const patternProgressBarElement = document.getElementById('pattern-progress-bar');
      const patternPositionElement = document.getElementById('pattern-position');
      const patternBoundsElement = document.getElementById('pattern-bounds');
      const patternDefaultsStatusElement = document.getElementById(
        'pattern-defaults-status',
      );
      const patternDefaultsListElement = document.getElementById('pattern-defaults-list');
      const plannerMetadataStatusElement = document.getElementById(
        'planner-metadata-status',
      );
      const plannerMetadataListElement = document.getElementById('planner-metadata-details');
      const machineProfileStatusElement = document.getElementById('machine-profile-status');
      const machineProfileAxesElement = document.getElementById('machine-profile-axes');
      const homingGuardStatusElement = document.getElementById('homing-guard-status');
      const homingGuardHomeStateElement = document.getElementById(
        'homing-guard-home-state',
      );
      const homingGuardPositionElement = document.getElementById('homing-guard-position');
      const yarnFlowStatusElement = document.getElementById('yarn-flow-status');
      const yarnFlowSpoolElement = document.getElementById('yarn-flow-spool');
      const yarnFlowTotalElement = document.getElementById('yarn-flow-total');
      const yarnFlowQueueElement = document.getElementById('yarn-flow-queue');
      const yarnFlowUpcomingElement = document.getElementById('yarn-flow-upcoming');

      const pointer = new THREE.Vector2();
      const raycaster = new THREE.Raycaster();
      const interactiveMeshes = [];
      const productClusters = [];
      const safeAccessHighlights = [];
      const stepBadgeControllers = [];
      const anchorPulseControllers = [];
      let activeCluster = null;
      const selectionRingHeight = 0.06;
      const selectionSweepSpeed = 0.9;
      const patternPreviewSource = 'assets/base_chain_row.planner.json';
      const fallbackPatternPlannerEvents = [
        { comment: 'use millimeters', x: 0.0, y: 0.0, z: 4.0, extrusion: 0.0 },
        { comment: 'absolute positioning', x: 0.0, y: 0.0, z: 4.0, extrusion: 0.0 },
        { comment: 'zero axes', x: 0.0, y: 0.0, z: 4.0, extrusion: 0.0 },
        { comment: 'chain stitch 1 of 3: plunge', x: 0.0, y: 0.0, z: -1.5, extrusion: 0.0 },
        { comment: 'chain stitch 1 of 3: feed yarn', x: 0.0, y: 0.0, z: -1.5, extrusion: 0.5 },
        { comment: 'chain stitch 1 of 3: raise', x: 0.0, y: 0.0, z: 4.0, extrusion: 0.5 },
        { comment: 'chain stitch 1 of 3: advance', x: 5.0, y: 0.0, z: 4.0, extrusion: 0.5 },
        { comment: 'chain stitch 2 of 3: plunge', x: 5.0, y: 0.0, z: -1.5, extrusion: 0.5 },
        { comment: 'chain stitch 2 of 3: feed yarn', x: 5.0, y: 0.0, z: -1.5, extrusion: 1.0 },
        { comment: 'chain stitch 2 of 3: raise', x: 5.0, y: 0.0, z: 4.0, extrusion: 1.0 },
        { comment: 'chain stitch 2 of 3: advance', x: 10.0, y: 0.0, z: 4.0, extrusion: 1.0 },
        { comment: 'chain stitch 3 of 3: plunge', x: 10.0, y: 0.0, z: -1.5, extrusion: 1.0 },
        { comment: 'chain stitch 3 of 3: feed yarn', x: 10.0, y: 0.0, z: -1.5, extrusion: 1.5 },
        { comment: 'chain stitch 3 of 3: raise', x: 10.0, y: 0.0, z: 4.0, extrusion: 1.5 },
        { comment: 'chain stitch 3 of 3: advance', x: 15.0, y: 0.0, z: 4.0, extrusion: 1.5 },
        { comment: 'pause for 0.400 s', x: 15.0, y: 0.0, z: 4.0, extrusion: 1.5 },
        { comment: 'reposition', x: 18.0, y: 5.0, z: 4.0, extrusion: 1.5 },
        { comment: 'turn to next row', x: 0.0, y: 12.0, z: 4.0, extrusion: 1.5 },
        { comment: 'single stitch 1 of 1: plunge', x: 0.0, y: 12.0, z: -2.0, extrusion: 1.5 },
        { comment: 'single stitch 1 of 1: feed yarn', x: 0.0, y: 12.0, z: -2.0, extrusion: 2.1 },
        { comment: 'single stitch 1 of 1: raise', x: 0.0, y: 12.0, z: 4.0, extrusion: 2.1 },
        { comment: 'single stitch 1 of 1: advance', x: 4.5, y: 12.0, z: 4.0, extrusion: 2.1 },
      ];
      const fallbackPatternDefaults = {
        safe_z_mm: 4.0,
        fabric_plane_z_mm: 0.0,
        travel_feed_rate_mm_min: 1200,
        plunge_feed_rate_mm_min: 600,
        yarn_feed_rate_mm_min: 300,
        default_row_height_mm: 6.0,
        require_home: false,
        home_state: 'unknown',
      };
      Object.freeze(fallbackPatternPlannerEvents);
      Object.freeze(fallbackPatternDefaults);
      const yarnFlowControllers = [];
      const yarnPulseControllers = [];
      const yarnBeadControllers = [];
      const spoolControllers = [];
      const servoActuatorControllers = [];
      const servoSignalControllers = [];
      let yarnExtrusionActive = false;
      let patternPlannerEvents = [];
      let patternPreviewGroup = null;
      let patternPreviewContainer = null;
      let plannerBounds = null;
      const patternPreviewDurationSeconds = 14;
      let lastPatternStepIndex = -1;
      let lastPatternProgress = -1;
      const machineProfileFallbackMessage =
        'Machine profile metadata unavailable. Export with --machine-profile to surface axis settings.';
      const homingGuardFallbackMessage =
        'Homing guard metadata unavailable. Export planner defaults.require_home and defaults.home_state.';
      const homingGuardPositionFallbackMessage =
        'Coordinates: Awaiting planner coordinates…';
      const patternBoundsFallbackMessage =
        'Planner bounds unavailable. Export --format planner payloads with bounds to preview the motion envelope.';
      const patternDefaultsFallbackMessage =
        'Planner defaults unavailable. Export planner payloads with defaults metadata to surface feed and height settings.';
      const plannerMetadataFallbackMessage =
        'Planner metadata unavailable. Export planner payloads with version and units fields to surface schema details.';
      const yarnFlowStatusFallbackMessage =
        'Yarn flow monitor idle — load a planner preview to track feed events.';
      const yarnFlowSpoolFallbackMessage =
        'Spool status: Parked until planner preview loads.';
      const yarnFlowTotalFallbackMessage =
        'Total yarn fed: Awaiting planner preview…';
      const yarnFlowQueueFallbackMessage =
        'Remaining feed pulses: Awaiting planner preview…';
      const yarnFlowUpcomingFallbackMessage =
        'Next feed pulses: Awaiting planner preview…';
      let plannerDefaults = null;
      let patternExtrusionBaseline = 0;
      let patternExtrusionTarget = 0;
      let yarnFeedStepIndices = [];
      let plannerMetadata = null;

      const FRAME_HALF_WIDTH = 3.6;
      const FRAME_HALF_DEPTH = 2.6;
      const LOWER_RAIL_Y = 0.25;
      const UPPER_RAIL_Y = 4.3;
      const RAIL_THICKNESS = 0.22;

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        500,
      );
      camera.position.set(12, 8, 18);

      const currentCameraTarget = new THREE.Vector3(0, 1.2, 0);
      const desiredCameraTarget = currentCameraTarget.clone();
      const desiredCameraPosition = camera.position.clone();
      const defaultCameraTarget = currentCameraTarget.clone();
      const defaultCameraPosition = camera.position.clone();
      const defaultCameraOffset = defaultCameraPosition.clone().sub(defaultCameraTarget);
      const minCameraRadius = 6;
      const maxCameraRadius = 26;
      const cameraMoveDamping = 4.0;
      let userIsControllingCamera = false;
      let cameraWasMovedByControls = false;

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 60;
      controls.maxPolarAngle = Math.PI * 0.49;
      controls.target.copy(currentCameraTarget);

      controls.addEventListener('start', () => {
        userIsControllingCamera = true;
        cameraWasMovedByControls = false;
        desiredCameraTarget.copy(controls.target);
        desiredCameraPosition.copy(camera.position);
      });

      controls.addEventListener('change', () => {
        if (userIsControllingCamera) {
          cameraWasMovedByControls = true;
        }
      });

      controls.addEventListener('end', () => {
        userIsControllingCamera = false;
        if (cameraWasMovedByControls) {
          currentCameraTarget.copy(controls.target);
          desiredCameraTarget.copy(controls.target);
          desiredCameraPosition.copy(camera.position);
        } else {
          controls.target.copy(currentCameraTarget);
        }
      });

      const ambientLight = new THREE.AmbientLight(0xbac4ff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xf1f3ff, 1.2);
      keyLight.position.set(10, 16, 10);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x6c79ff, 0.6);
      fillLight.position.set(-6, 12, -12);
      scene.add(fillLight);

      const groundGeometry = new THREE.CircleGeometry(16, 64);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x131421,
        roughness: 0.85,
        metalness: 0.2,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(32, 32, 0x2e3a68, 0x1d233c);
      scene.add(gridHelper);

      let selectionSweep = null;

      const selectionRingGeometry = new THREE.RingGeometry(1.0, 1.3, 96, 1);
      const selectionRingMaterial = new THREE.MeshStandardMaterial({
        color: 0x76faff,
        emissive: 0x2ba7bf,
        emissiveIntensity: 0.7,
        metalness: 0.25,
        roughness: 0.4,
        transparent: true,
        opacity: 0.55,
        side: THREE.DoubleSide,
        depthWrite: false,
      });
      const selectionRingGroup = new THREE.Group();
      selectionRingGroup.position.y = selectionRingHeight;
      selectionRingGroup.visible = false;
      selectionRingGroup.scale.setScalar(1.0);
      scene.add(selectionRingGroup);

      const selectionRing = new THREE.Mesh(selectionRingGeometry, selectionRingMaterial);
      selectionRing.rotation.x = -Math.PI / 2;
      selectionRing.renderOrder = 5;
      selectionRingGroup.add(selectionRing);
      addHoverInfo(
        selectionRing,
        'Roadmap selection ring — pulses to mark the active product cluster.',
        { passthrough: true },
      );
      safeAccessHighlights.push({
        material: selectionRingMaterial,
        baseIntensity: 0.7,
        amplitude: 0.4,
        speed: 2.1,
        phaseOffset: 0.6,
        baseOpacity: 0.55,
        opacityAmplitude: 0.25,
        visibleOnly: true,
        object: selectionRingGroup,
      });

      const selectionSweepMaterial = new THREE.MeshStandardMaterial({
        color: 0x9dfff5,
        emissive: 0x3dd7c8,
        emissiveIntensity: 0.9,
        metalness: 0.4,
        roughness: 0.25,
        transparent: true,
        opacity: 0.85,
        side: THREE.DoubleSide,
        depthWrite: false,
      });
      selectionSweep = new THREE.Mesh(
        new THREE.RingGeometry(1.04, 1.26, 96, 1, 0, Math.PI / 4),
        selectionSweepMaterial,
      );
      selectionSweep.rotation.x = -Math.PI / 2;
      selectionSweep.renderOrder = 6;
      selectionRingGroup.add(selectionSweep);
      addHoverInfo(
        selectionSweep,
        'Roadmap sweep — rotates around the selected cluster for quick focus.',
        { passthrough: true },
      );
      safeAccessHighlights.push({
        material: selectionSweepMaterial,
        baseIntensity: 0.9,
        amplitude: 0.5,
        speed: 2.6,
        phaseOffset: 1.2,
        baseOpacity: 0.85,
        opacityAmplitude: 0.2,
        visibleOnly: true,
        object: selectionRingGroup,
      });

      function buildLabel(text, color = '#f5f5f5') {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const padding = 32;
        const fontSize = 56;
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        const metrics = context.measureText(text);
        canvas.width = metrics.width + padding * 2;
        canvas.height = fontSize + padding * 1.4;

        context.fillStyle = 'rgba(12, 13, 25, 0.8)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.strokeStyle = 'rgba(245, 245, 245, 0.35)';
        context.lineWidth = 4;
        context.strokeRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = color;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        const baseScale = 0.02;
        sprite.scale.set(canvas.width * baseScale, canvas.height * baseScale, 1);
        return sprite;
      }

      function addHoverInfo(mesh, text, options = {}) {
        mesh.userData.hoverText = text;
        mesh.userData.hoverPassthrough = options.passthrough ?? false;
        interactiveMeshes.push(mesh);
      }

      function normalizeNumber(value, fallback = 0) {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : fallback;
      }

      function coerceFiniteNumber(value) {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function normalizeBounds(bounds) {
        if (!bounds || typeof bounds !== 'object') {
          return null;
        }

        const normalized = {};
        const axisDefinitions = [
          ['x', ['x_mm', 'x']],
          ['y', ['y_mm', 'y']],
          ['z', ['z_mm', 'z']],
          ['extrusion', ['extrusion_mm', 'extrusion', 'e_mm', 'e']],
        ];

        axisDefinitions.forEach(([key, aliases]) => {
          for (const alias of aliases) {
            const raw = bounds[alias];
            if (!raw || typeof raw !== 'object') {
              continue;
            }
            const min =
              coerceFiniteNumber(raw.min ?? raw.min_mm ?? raw.minimum ?? raw.low);
            const max =
              coerceFiniteNumber(raw.max ?? raw.max_mm ?? raw.maximum ?? raw.high);
            if (min === null || max === null || max < min) {
              continue;
            }
            normalized[key] = { min, max };
            return;
          }
        });

        return Object.keys(normalized).length > 0 ? normalized : null;
      }

      function computeBoundsFromEvents(events) {
        if (!Array.isArray(events) || events.length === 0) {
          return null;
        }

        const summary = {
          x: { min: Infinity, max: -Infinity, has: false },
          y: { min: Infinity, max: -Infinity, has: false },
          z: { min: Infinity, max: -Infinity, has: false },
          extrusion: { min: Infinity, max: -Infinity, has: false },
        };

        events.forEach((event) => {
          if (!event || typeof event !== 'object') {
            return;
          }
          const xValue = coerceFiniteNumber(event.x);
          if (xValue !== null) {
            summary.x.min = Math.min(summary.x.min, xValue);
            summary.x.max = Math.max(summary.x.max, xValue);
            summary.x.has = true;
          }
          const yValue = coerceFiniteNumber(event.y);
          if (yValue !== null) {
            summary.y.min = Math.min(summary.y.min, yValue);
            summary.y.max = Math.max(summary.y.max, yValue);
            summary.y.has = true;
          }
          const zValue = coerceFiniteNumber(event.z);
          if (zValue !== null) {
            summary.z.min = Math.min(summary.z.min, zValue);
            summary.z.max = Math.max(summary.z.max, zValue);
            summary.z.has = true;
          }
          const extrusionValue = coerceFiniteNumber(event.extrusion);
          if (extrusionValue !== null) {
            summary.extrusion.min = Math.min(summary.extrusion.min, extrusionValue);
            summary.extrusion.max = Math.max(summary.extrusion.max, extrusionValue);
            summary.extrusion.has = true;
          }
        });

        const bounds = {};
        if (summary.x.has) {
          bounds.x = { min: summary.x.min, max: summary.x.max };
        }
        if (summary.y.has) {
          bounds.y = { min: summary.y.min, max: summary.y.max };
        }
        if (summary.z.has) {
          bounds.z = { min: summary.z.min, max: summary.z.max };
        }
        if (summary.extrusion.has) {
          bounds.extrusion = {
            min: summary.extrusion.min,
            max: summary.extrusion.max,
          };
        }

        return Object.keys(bounds).length > 0 ? bounds : null;
      }

      function computeExtrusionSummary(events, bounds) {
        let baseline = null;
        let target = null;

        if (bounds && bounds.extrusion) {
          const { min, max } = bounds.extrusion;
          if (Number.isFinite(min)) {
            baseline = min;
          }
          if (Number.isFinite(max)) {
            target = max;
          }
        }

        if (Array.isArray(events)) {
          events.forEach((event) => {
            if (!event || typeof event !== 'object') {
              return;
            }
            const value = coerceFiniteNumber(event.extrusion);
            if (value === null) {
              return;
            }
            baseline = baseline === null ? value : Math.min(baseline, value);
            target = target === null ? value : Math.max(target, value);
          });
        }

        const normalizedBaseline = Number.isFinite(baseline) ? baseline : 0;
        const normalizedTarget = Number.isFinite(target) ? target : normalizedBaseline;

        return [normalizedBaseline, normalizedTarget];
      }

      function buildBoundsHoverText(bounds) {
        if (!bounds) {
          return 'Planner bounds overlay — load a planner export with bounds metadata to preview the motion envelope.';
        }
        const segments = [];
        if (bounds.x) {
          segments.push(`X ${bounds.x.min.toFixed(1)}–${bounds.x.max.toFixed(1)} mm`);
        }
        if (bounds.y) {
          segments.push(`Y ${bounds.y.min.toFixed(1)}–${bounds.y.max.toFixed(1)} mm`);
        }
        if (bounds.z) {
          segments.push(`Z ${bounds.z.min.toFixed(1)}–${bounds.z.max.toFixed(1)} mm`);
        }
        if (bounds.extrusion) {
          segments.push(
            `E ${bounds.extrusion.min.toFixed(1)}–${bounds.extrusion.max.toFixed(1)} mm`,
          );
        }
        if (segments.length === 0) {
          return 'Planner bounds overlay — load a planner export with bounds metadata to preview the motion envelope.';
        }
        return `Planner bounds — ${segments.join(' · ')}`;
      }

      function updatePatternBoundsOverlay(bounds) {
        if (!patternBoundsElement) {
          return;
        }

        if (!bounds) {
          patternBoundsElement.textContent = patternBoundsFallbackMessage;
          setTone(patternBoundsElement, 'warning');
          return;
        }

        const segments = [];
        if (bounds.x) {
          segments.push(`X ${bounds.x.min.toFixed(1)}–${bounds.x.max.toFixed(1)} mm`);
        }
        if (bounds.y) {
          segments.push(`Y ${bounds.y.min.toFixed(1)}–${bounds.y.max.toFixed(1)} mm`);
        }
        if (bounds.z) {
          segments.push(`Z ${bounds.z.min.toFixed(1)}–${bounds.z.max.toFixed(1)} mm`);
        }
        if (bounds.extrusion) {
          segments.push(
            `E ${bounds.extrusion.min.toFixed(1)}–${bounds.extrusion.max.toFixed(1)} mm`,
          );
        }

        if (segments.length === 0) {
          patternBoundsElement.textContent = patternBoundsFallbackMessage;
          setTone(patternBoundsElement, 'warning');
          return;
        }

        patternBoundsElement.textContent = `Bounds: ${segments.join(' · ')}`;
        setTone(patternBoundsElement, 'info');
      }

      function updatePlannerDefaultsPanel(defaults) {
        if (!patternDefaultsStatusElement || !patternDefaultsListElement) {
          return;
        }

        while (patternDefaultsListElement.firstChild) {
          patternDefaultsListElement.removeChild(patternDefaultsListElement.firstChild);
        }

        const data = defaults && typeof defaults === 'object' ? defaults : null;
        const entries = [];

        const safeZ = Number(data?.safe_z_mm);
        if (Number.isFinite(safeZ)) {
          entries.push({ label: 'Safe Z height', value: `${safeZ.toFixed(1)} mm` });
        }

        const fabricPlane = Number(data?.fabric_plane_z_mm);
        if (Number.isFinite(fabricPlane)) {
          entries.push({ label: 'Fabric plane', value: `${fabricPlane.toFixed(1)} mm` });
        }

        const rowHeight = Number(data?.default_row_height_mm);
        if (Number.isFinite(rowHeight)) {
          entries.push({ label: 'Row height', value: `${rowHeight.toFixed(1)} mm` });
        }

        const travelFeed = Number(data?.travel_feed_rate_mm_min);
        if (Number.isFinite(travelFeed)) {
          entries.push({ label: 'Travel feed', value: `${travelFeed.toFixed(0)} mm/min` });
        }

        const plungeFeed = Number(data?.plunge_feed_rate_mm_min);
        if (Number.isFinite(plungeFeed)) {
          entries.push({ label: 'Plunge feed', value: `${plungeFeed.toFixed(0)} mm/min` });
        }

        const yarnFeed = Number(data?.yarn_feed_rate_mm_min);
        if (Number.isFinite(yarnFeed)) {
          entries.push({ label: 'Yarn feed', value: `${yarnFeed.toFixed(0)} mm/min` });
        }

        if (entries.length === 0) {
          patternDefaultsStatusElement.textContent = patternDefaultsFallbackMessage;
          setTone(patternDefaultsStatusElement, 'warning');
          return;
        }

        patternDefaultsStatusElement.textContent = 'Planner defaults:';
        setTone(patternDefaultsStatusElement, 'info');

        entries.forEach(({ label, value }) => {
          const listItem = document.createElement('li');
          listItem.textContent = `${label}: ${value}`;
          patternDefaultsListElement.appendChild(listItem);
        });
      }

      function buildPlannerMetadata(metadata, events) {
        const source = metadata && typeof metadata === 'object' ? metadata : null;
        const normalized = {};

        if (source) {
          const versionCandidate =
            source.version ?? source.schemaVersion ?? source.schema_version ?? null;
          if (typeof versionCandidate === 'string') {
            const trimmed = versionCandidate.trim();
            if (trimmed.length > 0) {
              normalized.version = trimmed;
            }
          } else if (Number.isFinite(versionCandidate)) {
            normalized.version = versionCandidate.toString();
          }

          const unitsCandidate = source.units ?? source.unit ?? null;
          if (typeof unitsCandidate === 'string') {
            const trimmedUnits = unitsCandidate.trim();
            if (trimmedUnits.length > 0) {
              normalized.units = trimmedUnits;
            }
          }

          if (typeof source.source === 'string') {
            const trimmedSource = source.source.trim();
            if (trimmedSource.length > 0) {
              normalized.source = trimmedSource;
            }
          }
        }

        const commandCount = Array.isArray(events) ? events.length : 0;
        if (commandCount > 0) {
          normalized.commandCount = commandCount;
        } else if (
          Number.isFinite(source?.commandCount) &&
          source.commandCount >= 0
        ) {
          normalized.commandCount = Math.round(source.commandCount);
        }

        return Object.keys(normalized).length > 0 ? normalized : null;
      }

      function updatePlannerMetadataPanel(metadata) {
        if (!plannerMetadataStatusElement || !plannerMetadataListElement) {
          return;
        }

        while (plannerMetadataListElement.firstChild) {
          plannerMetadataListElement.removeChild(plannerMetadataListElement.firstChild);
        }

        const data = metadata && typeof metadata === 'object' ? metadata : null;
        const entries = [];

        if (typeof data?.version === 'string' && data.version.trim().length > 0) {
          entries.push({ label: 'Schema version', value: data.version.trim() });
        }

        if (typeof data?.units === 'string' && data.units.trim().length > 0) {
          entries.push({ label: 'Units', value: data.units.trim() });
        }

        if (Number.isFinite(data?.commandCount)) {
          const rounded = Math.max(0, Math.round(data.commandCount));
          entries.push({ label: 'Planner steps', value: `${rounded}` });
        }

        if (typeof data?.source === 'string' && data.source.trim().length > 0) {
          entries.push({ label: 'Source', value: data.source.trim() });
        }

        if (entries.length === 0) {
          plannerMetadataStatusElement.textContent = plannerMetadataFallbackMessage;
          setTone(plannerMetadataStatusElement, 'warning');
          return;
        }

        plannerMetadataStatusElement.textContent = 'Planner metadata:';
        setTone(plannerMetadataStatusElement, 'info');

        entries.forEach(({ label, value }) => {
          const listItem = document.createElement('li');
          listItem.textContent = `${label}: ${value}`;
          plannerMetadataListElement.appendChild(listItem);
        });
      }

      function setTone(element, tone) {
        if (!element) {
          return;
        }

        if (tone) {
          element.dataset.tone = tone;
        } else if (element.dataset && element.dataset.tone) {
          delete element.dataset.tone;
        }
      }

      function resetYarnFlowPanel() {
        if (!yarnFlowStatusElement || !yarnFlowSpoolElement) {
          return;
        }

        patternExtrusionBaseline = 0;
        patternExtrusionTarget = 0;
        yarnFeedStepIndices = [];
        yarnFlowStatusElement.textContent = yarnFlowStatusFallbackMessage;
        setTone(yarnFlowStatusElement, 'neutral');
        yarnFlowSpoolElement.textContent = yarnFlowSpoolFallbackMessage;
        setTone(yarnFlowSpoolElement, 'neutral');
        if (yarnFlowTotalElement) {
          yarnFlowTotalElement.textContent = yarnFlowTotalFallbackMessage;
          setTone(yarnFlowTotalElement, 'neutral');
        }
        if (yarnFlowQueueElement) {
          yarnFlowQueueElement.textContent = yarnFlowQueueFallbackMessage;
          setTone(yarnFlowQueueElement, 'neutral');
        }
        if (yarnFlowUpcomingElement) {
          yarnFlowUpcomingElement.textContent = yarnFlowUpcomingFallbackMessage;
          setTone(yarnFlowUpcomingElement, 'neutral');
        }
      }

      function updateYarnFlowPanel(event, stepIndex, totalSteps) {
        if (!yarnFlowStatusElement || !yarnFlowSpoolElement) {
          return;
        }

        if (!event) {
          resetYarnFlowPanel();
          return;
        }

        const comment =
          typeof event.comment === 'string' && event.comment.trim().length > 0
            ? event.comment.trim()
            : 'Planner move';
        const stepLabel =
          Number.isFinite(stepIndex) && Number.isFinite(totalSteps)
            ? ` (step ${stepIndex + 1} of ${totalSteps})`
            : '';

        if (yarnExtrusionActive) {
          yarnFlowStatusElement.textContent = `Yarn feed active${stepLabel}: ${comment}`;
          setTone(yarnFlowStatusElement, 'ready');
          yarnFlowSpoolElement.textContent =
            'Spool status: Spinning — matching feed pulses.';
          setTone(yarnFlowSpoolElement, 'ready');
        } else {
          yarnFlowStatusElement.textContent = `Yarn feed idle${stepLabel}: ${comment}`;
          setTone(yarnFlowStatusElement, 'info');
          yarnFlowSpoolElement.textContent =
            'Spool status: Parked until the next feed event.';
          setTone(yarnFlowSpoolElement, 'neutral');
        }

        if (yarnFlowTotalElement) {
          const baseline = Number.isFinite(patternExtrusionBaseline)
            ? patternExtrusionBaseline
            : 0;
          const target = Number.isFinite(patternExtrusionTarget)
            ? patternExtrusionTarget
            : baseline;
          const rawExtrusion = Number.isFinite(event.extrusion)
            ? event.extrusion
            : baseline;
          const fed = Math.max(rawExtrusion - baseline, 0);
          const planned = Math.max(target - baseline, 0);
          const fedLabel = fed.toFixed(2);
          let summary = `Total yarn fed: ${fedLabel} mm`;
          if (planned > 0.0001) {
            summary += ` of ${planned.toFixed(2)} mm`;
          }
          yarnFlowTotalElement.textContent = `${summary}.`;
          setTone(yarnFlowTotalElement, yarnExtrusionActive ? 'ready' : 'info');
        }

        if (yarnFlowQueueElement) {
          const totalFeedSteps = Array.isArray(yarnFeedStepIndices)
            ? yarnFeedStepIndices.length
            : 0;
          if (totalFeedSteps > 0 && Number.isFinite(stepIndex)) {
            let remainingFeeds = 0;
            for (let index = 0; index < totalFeedSteps; index += 1) {
              const feedStep = yarnFeedStepIndices[index];
              if (typeof feedStep === 'number' && feedStep > stepIndex) {
                remainingFeeds += 1;
              }
            }
            const summary = `Remaining feed pulses: ${remainingFeeds} of ${totalFeedSteps}.`;
            yarnFlowQueueElement.textContent = summary;
            setTone(yarnFlowQueueElement, remainingFeeds === 0 ? 'ready' : 'info');
          } else {
            yarnFlowQueueElement.textContent =
              'Remaining feed pulses: None in this preview.';
            setTone(yarnFlowQueueElement, 'neutral');
          }
        }

        if (yarnFlowUpcomingElement) {
          const totalFeedSteps = Array.isArray(yarnFeedStepIndices)
            ? yarnFeedStepIndices.length
            : 0;
          if (totalFeedSteps > 0 && Number.isFinite(stepIndex)) {
            const upcomingIndices = [];
            for (let index = 0; index < totalFeedSteps; index += 1) {
              const feedStep = yarnFeedStepIndices[index];
              if (typeof feedStep === 'number' && feedStep > stepIndex) {
                upcomingIndices.push(feedStep);
              }
            }

            if (upcomingIndices.length > 0) {
              const previewLabels = upcomingIndices
                .slice(0, 4)
                .map((value) => `#${value + 1}`);
              let summary = `Next feed pulses: ${previewLabels.join(', ')}`;
              if (upcomingIndices.length > previewLabels.length) {
                summary += ', …';
              }
              yarnFlowUpcomingElement.textContent = `${summary}.`;
              setTone(yarnFlowUpcomingElement, 'info');
            } else {
              yarnFlowUpcomingElement.textContent =
                'Next feed pulses: None remaining in this preview.';
              setTone(yarnFlowUpcomingElement, 'ready');
            }
          } else {
            yarnFlowUpcomingElement.textContent =
              'Next feed pulses: None in this preview.';
            setTone(yarnFlowUpcomingElement, 'neutral');
          }
        }
      }

      function normalizeHomeState(value) {
        if (typeof value !== 'string') {
          return null;
        }

        const trimmed = value.trim();
        return trimmed.length > 0 ? trimmed : null;
      }

      function updateHomingGuardPanel(defaults) {
        if (!homingGuardStatusElement || !homingGuardHomeStateElement) {
          return;
        }

        const guard = defaults && typeof defaults === 'object' ? defaults : null;
        const requireHome =
          typeof guard?.require_home === 'boolean' ? guard.require_home : null;
        const homeState = normalizeHomeState(guard?.home_state);

        if (requireHome === null && !homeState) {
          homingGuardStatusElement.textContent = homingGuardFallbackMessage;
          setTone(homingGuardStatusElement, 'neutral');
          homingGuardHomeStateElement.textContent = '';
          homingGuardHomeStateElement.style.display = 'none';
          return;
        }

        homingGuardHomeStateElement.style.display = '';

        if (requireHome === true) {
          homingGuardStatusElement.textContent =
            'Requires a homed machine before executing this planner preview.';
          setTone(homingGuardStatusElement, 'warning');
        } else if (requireHome === false) {
          homingGuardStatusElement.textContent =
            'Homing optional for this planner preview.';
          setTone(homingGuardStatusElement, 'info');
        } else {
          homingGuardStatusElement.textContent = homingGuardFallbackMessage;
          setTone(homingGuardStatusElement, 'neutral');
        }

        if (homeState) {
          const normalized = homeState.toLowerCase();
          let stateTone = 'info';
          if (normalized === 'homed') {
            stateTone = 'ready';
          } else if (requireHome) {
            stateTone = 'warning';
          }
          homingGuardHomeStateElement.textContent = `Recorded home state: ${homeState}`;
          setTone(homingGuardHomeStateElement, stateTone);
        } else {
          homingGuardHomeStateElement.textContent = 'Recorded home state unavailable.';
          setTone(homingGuardHomeStateElement, 'warning');
        }
      }

      function eventsFromPlannerPayload(payload) {
        if (!payload || typeof payload !== 'object') {
          return [];
        }
        const commands = Array.isArray(payload.commands) ? payload.commands : [];
        return commands.map((entry) => {
          const state = entry && typeof entry === 'object' ? entry.state || {} : {};
          return {
            comment: typeof entry?.comment === 'string' ? entry.comment : null,
            x: normalizeNumber(state.x_mm),
            y: normalizeNumber(state.y_mm),
            z: normalizeNumber(state.z_mm),
            extrusion: normalizeNumber(state.extrusion_mm),
          };
        });
      }

      function applyPatternPlannerEvents(events, options = {}) {
        if (Object.prototype.hasOwnProperty.call(options, 'defaults')) {
          plannerDefaults =
            options.defaults && typeof options.defaults === 'object'
              ? options.defaults
              : null;
        }
        updateHomingGuardPanel(plannerDefaults);
        updatePlannerDefaultsPanel(plannerDefaults);

        patternPlannerEvents = Array.isArray(events) ? [...events] : [];
        yarnFeedStepIndices = [];
        patternExtrusionBaseline = 0;
        patternExtrusionTarget = 0;
        if (patternPlannerEvents.length === 0 && options.resetOverlay !== false) {
          plannerMetadata = null;
        } else {
          const metadataInput = Object.prototype.hasOwnProperty.call(options, 'metadata')
            ? options.metadata
            : plannerMetadata;
          plannerMetadata = buildPlannerMetadata(metadataInput, patternPlannerEvents);
        }
        updatePlannerMetadataPanel(plannerMetadata);
        const providedBounds = Object.prototype.hasOwnProperty.call(options, 'bounds')
          ? normalizeBounds(options.bounds)
          : null;
        plannerBounds = providedBounds ?? computeBoundsFromEvents(patternPlannerEvents);
        const [extrusionBaseline, extrusionTarget] = computeExtrusionSummary(
          patternPlannerEvents,
          plannerBounds,
        );
        patternExtrusionBaseline = extrusionBaseline;
        patternExtrusionTarget = extrusionTarget;
        if (patternPlannerEvents.length > 0) {
          patternPlannerEvents.forEach((event, index) => {
            const comment =
              typeof event?.comment === 'string' ? event.comment.toLowerCase() : '';
            if (comment.includes('feed yarn')) {
              yarnFeedStepIndices.push(index);
            }
          });
        }
        updatePatternBoundsOverlay(plannerBounds);

        if (patternPreviewContainer) {
          if (patternPreviewGroup) {
            patternPreviewContainer.remove(patternPreviewGroup);
          }
          patternPreviewGroup = buildPlannerPreview(patternPlannerEvents, {
            bounds: plannerBounds,
          });
          patternPreviewGroup.position.set(0, 0, 0.01);
          patternPreviewContainer.add(patternPreviewGroup);
        }

        if (patternPlannerEvents.length > 0) {
          lastPatternStepIndex = -1;
          lastPatternProgress = -1;
          updatePatternOverlay(0, 0);
        } else if (options.resetOverlay !== false) {
          lastPatternStepIndex = -1;
          lastPatternProgress = -1;
          if (patternStepElement) {
            patternStepElement.textContent = 'Planner preview idle.';
          }
          if (patternStepIndexElement) {
            patternStepIndexElement.textContent = 'No planner steps loaded';
          }
          if (patternProgressBarElement) {
            patternProgressBarElement.style.width = '0%';
          }
          if (patternPositionElement) {
            patternPositionElement.textContent = 'Position: Awaiting planner coordinates…';
            setTone(patternPositionElement, 'neutral');
          }
          if (homingGuardPositionElement) {
            homingGuardPositionElement.textContent = homingGuardPositionFallbackMessage;
            setTone(homingGuardPositionElement, 'neutral');
          }
          resetYarnFlowPanel();
        }
      }

      function updateMachineProfilePanel(machineProfile) {
        if (!machineProfileStatusElement || !machineProfileAxesElement) {
          return;
        }

        while (machineProfileAxesElement.firstChild) {
          machineProfileAxesElement.removeChild(machineProfileAxesElement.firstChild);
        }

        const axes =
          machineProfile && typeof machineProfile === 'object'
            ? machineProfile.axes || null
            : null;
        const entries =
          axes && typeof axes === 'object' ? Object.entries(axes).filter(Boolean) : [];

        if (!entries || entries.length === 0) {
          machineProfileStatusElement.textContent = machineProfileFallbackMessage;
          return;
        }

        machineProfileStatusElement.textContent = 'Planner-aligned axis settings:';

        entries
          .sort((a, b) => a[0].localeCompare(b[0]))
          .forEach(([name, axis]) => {
            if (!axis || typeof axis !== 'object') {
              return;
            }

            const listItem = document.createElement('li');
            const segments = [];

            const stepsPerMm = Number(axis.steps_per_mm);
            if (Number.isFinite(stepsPerMm)) {
              segments.push(`${stepsPerMm.toFixed(1)} steps/mm`);
            }

            const microstepping = Number(axis.microstepping);
            if (Number.isFinite(microstepping)) {
              segments.push(`×${microstepping} microstepping`);
            }

            const travelMin = Number(axis.travel_min_mm);
            const travelMax = Number(axis.travel_max_mm);
            if (Number.isFinite(travelMin) && Number.isFinite(travelMax)) {
              segments.push(`travel ${travelMin.toFixed(1)}–${travelMax.toFixed(1)} mm`);
            }

            if (segments.length === 0) {
              segments.push('metadata unavailable');
            }

            listItem.textContent = `${name} axis — ${segments.join(' · ')}`;
            machineProfileAxesElement.appendChild(listItem);
          });
      }

      async function loadPlannerPreviewFromSource() {
        if (patternStepElement) {
          patternStepElement.textContent = 'Loading base chain row planner preview…';
        }
        if (patternStepIndexElement) {
          patternStepIndexElement.textContent = 'Fetching pattern_cli export';
        }
        if (patternProgressBarElement) {
          patternProgressBarElement.style.width = '0%';
        }
        if (statusElement) {
          updateStatus('Loading Pattern Studio preview…');
        }

        try {
          const response = await fetch(patternPreviewSource, { cache: 'no-cache' });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          const events = eventsFromPlannerPayload(payload);
          if (!events.length) {
            throw new Error('Planner file contained no commands');
          }
          const defaults = payload?.defaults ?? null;
          const bounds = payload?.bounds ?? null;
          const metadata = {
            version: payload?.version ?? null,
            units: typeof payload?.units === 'string' ? payload.units : null,
            source: 'Base chain row asset',
          };
          applyPatternPlannerEvents(events, { defaults, bounds, metadata });
          updateMachineProfilePanel(payload?.machine_profile ?? null);
          if (statusElement) {
            updateStatus('Pattern Studio preview synced with base chain row.');
          }
        } catch (error) {
          console.warn('Unable to load planner preview', error);
          applyPatternPlannerEvents(fallbackPatternPlannerEvents, {
            defaults: { ...fallbackPatternDefaults },
            metadata: {
              version: 1,
              units: 'millimeters',
              source: 'Fallback preview',
            },
          });
          updateMachineProfilePanel(null);
          if (statusElement) {
            updateStatus('Using fallback planner preview.');
          }
        }
      }

      function buildPlannerPreview(events, options = {}) {
        const group = new THREE.Group();
        group.name = 'pattern-planner-preview';

        const sanitizedBounds = normalizeBounds(options.bounds);

        if (!Array.isArray(events) || events.length === 0) {
          group.userData.preview = {
            points: [],
            cumulativeDistances: [],
            totalDistance: 0,
            marker: null,
            halo: null,
            haloMaterial: null,
            bounds: sanitizedBounds ?? null,
          };
          return group;
        }

        const initialX = coerceFiniteNumber(events[0]?.x) ?? 0;
        const initialY = coerceFiniteNumber(events[0]?.y) ?? 0;
        const initialExtrusion = coerceFiniteNumber(events[0]?.extrusion) ?? 0;

        let minX = initialX;
        let maxX = initialX;
        let minY = initialY;
        let maxY = initialY;
        let maxExtrusion = initialExtrusion;

        events.forEach((event) => {
          const xValue = coerceFiniteNumber(event.x);
          if (xValue !== null) {
            minX = Math.min(minX, xValue);
            maxX = Math.max(maxX, xValue);
          }
          const yValue = coerceFiniteNumber(event.y);
          if (yValue !== null) {
            minY = Math.min(minY, yValue);
            maxY = Math.max(maxY, yValue);
          }
          const extrusionValue = coerceFiniteNumber(event.extrusion);
          if (extrusionValue !== null) {
            maxExtrusion = Math.max(maxExtrusion, extrusionValue);
          }
        });

        const fallbackBounds = {};
        if (Number.isFinite(minX) && Number.isFinite(maxX) && maxX >= minX) {
          fallbackBounds.x = { min: minX, max: maxX };
        }
        if (Number.isFinite(minY) && Number.isFinite(maxY) && maxY >= minY) {
          fallbackBounds.y = { min: minY, max: maxY };
        }
        if (Number.isFinite(maxExtrusion)) {
          fallbackBounds.extrusion = { min: 0, max: maxExtrusion };
        }

        const computedBounds = sanitizedBounds
          ?? (Object.keys(fallbackBounds).length > 0 ? fallbackBounds : null);
        const hoverBounds = computedBounds
          ?? (Object.keys(fallbackBounds).length > 0 ? fallbackBounds : null);

        const displayXMin = Number.isFinite(computedBounds?.x?.min)
          ? computedBounds.x.min
          : Number.isFinite(minX)
            ? minX
            : 0;
        const displayXMax = Number.isFinite(computedBounds?.x?.max)
          ? computedBounds.x.max
          : Number.isFinite(maxX)
            ? maxX
            : displayXMin + 1;
        const displayYMin = Number.isFinite(computedBounds?.y?.min)
          ? computedBounds.y.min
          : Number.isFinite(minY)
            ? minY
            : 0;
        const displayYMax = Number.isFinite(computedBounds?.y?.max)
          ? computedBounds.y.max
          : Number.isFinite(maxY)
            ? maxY
            : displayYMin + 1;
        const displayExtrusionMin = Number.isFinite(computedBounds?.extrusion?.min)
          ? computedBounds.extrusion.min
          : 0;
        const displayExtrusionMax = Number.isFinite(computedBounds?.extrusion?.max)
          ? computedBounds.extrusion.max
          : Number.isFinite(maxExtrusion)
            ? maxExtrusion
            : displayExtrusionMin + 0.01;

        const planeWidth = 0.72;
        const planeHeight = 0.52;
        const usableWidth = planeWidth * 0.88;
        const usableHeight = planeHeight * 0.82;

        const xSpan = Math.max(displayXMax - displayXMin, 1);
        const ySpan = Math.max(displayYMax - displayYMin, 1);
        const extrusionSpan = Math.max(
          displayExtrusionMax - displayExtrusionMin,
          0.01,
        );

        const positions = new Float32Array(events.length * 3);
        const colors = new Float32Array(events.length * 3);
        const points = [];

        events.forEach((event, index) => {
          const xValue = coerceFiniteNumber(event.x);
          const yValue = coerceFiniteNumber(event.y);
          const extrusionValue = coerceFiniteNumber(event.extrusion);

          const safeX = xValue === null ? displayXMin : xValue;
          const safeY = yValue === null ? displayYMin : yValue;
          const safeExtrusion =
            extrusionValue === null ? displayExtrusionMin : extrusionValue;

          const normalizedX = (safeX - displayXMin) / xSpan;
          const normalizedY = (safeY - displayYMin) / ySpan;
          const centeredX = normalizedX - 0.5;
          const centeredY = normalizedY - 0.5;
          const xPos = centeredX * usableWidth;
          const yPos = centeredY * usableHeight;
          const extrusionRatio = Math.max(safeExtrusion - displayExtrusionMin, 0) / extrusionSpan;
          const zPos = 0.02 + extrusionRatio * 0.06;
          const point = new THREE.Vector3(xPos, yPos, zPos);
          points.push(point);

          positions[index * 3] = point.x;
          positions[index * 3 + 1] = point.y;
          positions[index * 3 + 2] = point.z;

          const comment = typeof event.comment === 'string' ? event.comment : '';
          const isExtruding = comment.includes('feed yarn');
          const color = new THREE.Color(isExtruding ? 0xffb46b : 0x7fb3ff);
          colors[index * 3] = color.r;
          colors[index * 3 + 1] = color.g;
          colors[index * 3 + 2] = color.b;
        });

        const boundsGroup = new THREE.Group();
        boundsGroup.name = 'planner-bounds-overlay';
        boundsGroup.position.set(0, 0, 0);
        group.add(boundsGroup);

        const halfWidth = usableWidth / 2;
        const halfHeight = usableHeight / 2;
        const outlineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(-halfWidth, -halfHeight, 0),
          new THREE.Vector3(halfWidth, -halfHeight, 0),
          new THREE.Vector3(halfWidth, halfHeight, 0),
          new THREE.Vector3(-halfWidth, halfHeight, 0),
        ]);
        const outlineMaterial = new THREE.LineBasicMaterial({
          color: 0xdbe4ff,
          transparent: true,
          opacity: 0.85,
          depthTest: false,
        });
        const outline = new THREE.LineLoop(outlineGeometry, outlineMaterial);
        outline.renderOrder = 2;
        boundsGroup.add(outline);

        const fillMaterial = new THREE.MeshBasicMaterial({
          color: 0x6f83ff,
          transparent: true,
          opacity: 0.16,
          depthWrite: false,
          depthTest: false,
        });
        const fill = new THREE.Mesh(new THREE.PlaneGeometry(usableWidth, usableHeight), fillMaterial);
        fill.position.z = -0.0005;
        fill.renderOrder = 1;
        boundsGroup.add(fill);
        addHoverInfo(fill, buildBoundsHoverText(hoverBounds), { passthrough: true });

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const lineMaterial = new THREE.LineBasicMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.95,
        });

        const line = new THREE.Line(geometry, lineMaterial);
        line.renderOrder = 3;
        group.add(line);

        const cumulativeDistances = [0];
        for (let index = 1; index < points.length; index += 1) {
          const previous = points[index - 1];
          const current = points[index];
          const distance = current.distanceTo(previous);
          cumulativeDistances.push(cumulativeDistances[index - 1] + distance);
        }
        const totalDistance =
          cumulativeDistances[cumulativeDistances.length - 1] || 1.0;

        const marker = new THREE.Mesh(
          new THREE.SphereGeometry(0.02, 20, 20),
          new THREE.MeshStandardMaterial({
            color: 0xf5f9ff,
            emissive: 0x88aaff,
            emissiveIntensity: 1.2,
            metalness: 0.35,
            roughness: 0.25,
          }),
        );
        marker.castShadow = true;
        marker.position.copy(points[0]);
        group.add(marker);

        const haloMaterial = new THREE.MeshBasicMaterial({
          color: 0xb9caff,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide,
        });
        const halo = new THREE.Mesh(
          new THREE.RingGeometry(0.04, 0.065, 32),
          haloMaterial,
        );
        halo.rotation.x = Math.PI / 2;
        halo.position.copy(marker.position);
        group.add(halo);

        const previewLabel = buildLabel('Base Chain Row', '#ffe7c9');
        previewLabel.position.set(0, usableHeight * 0.75, 0.05);
        previewLabel.scale.multiplyScalar(0.28);
        group.add(previewLabel);

        group.userData.preview = {
          points,
          cumulativeDistances,
          totalDistance,
          marker,
          halo,
          haloMaterial,
          bounds: hoverBounds,
        };

        return group;
      }

      function disposePreviewGroup(group) {
        group.traverse((child) => {
          if (child.geometry) {
            child.geometry.dispose();
          }
          if (child.material) {
            const materials = Array.isArray(child.material)
              ? child.material
              : [child.material];
            materials.forEach((material) => {
              if (material.map && typeof material.map.dispose === 'function') {
                material.map.dispose();
              }
              if (typeof material.dispose === 'function') {
                material.dispose();
              }
            });
          }
        });
      }

      function updatePatternOverlay(stepIndex, progressRatio) {
        if (!patternStepElement) {
          return;
        }

        const totalSteps = patternPlannerEvents.length;
        if (totalSteps === 0) {
          yarnExtrusionActive = false;
          lastPatternStepIndex = -1;
          lastPatternProgress = -1;
          if (patternProgressBarElement) {
            patternProgressBarElement.style.width = '0%';
          }
          if (patternPositionElement) {
            patternPositionElement.textContent =
              'Position: Awaiting planner coordinates…';
            setTone(patternPositionElement, 'neutral');
          }
          if (homingGuardPositionElement) {
            homingGuardPositionElement.textContent = homingGuardPositionFallbackMessage;
            setTone(homingGuardPositionElement, 'neutral');
          }
          resetYarnFlowPanel();
          return;
        }

        const clampedIndex = Math.min(Math.max(stepIndex, 0), totalSteps - 1);
        const clampedProgress = Math.min(Math.max(progressRatio, 0), 1);

        if (clampedIndex !== lastPatternStepIndex) {
          const event = patternPlannerEvents[clampedIndex] ?? {};
          const comment =
            typeof event.comment === 'string' && event.comment.trim().length > 0
              ? event.comment
              : 'Planner preview event';
          patternStepElement.textContent = comment;
          if (patternStepIndexElement) {
            patternStepIndexElement.textContent = `Step ${clampedIndex + 1} of ${totalSteps}`;
          }
          yarnExtrusionActive =
            typeof comment === 'string' && comment.toLowerCase().includes('feed yarn');
          if (patternPositionElement) {
            const formatCoordinate = (value) =>
              Number.isFinite(value) ? value.toFixed(1) : '—';
            const positionSegments = [
              `X ${formatCoordinate(event.x)} mm`,
              `Y ${formatCoordinate(event.y)} mm`,
              `Z ${formatCoordinate(event.z)} mm`,
              `E ${formatCoordinate(event.extrusion)} mm`,
            ];
            patternPositionElement.textContent = `Position: ${positionSegments.join(' · ')}`;
            setTone(patternPositionElement, yarnExtrusionActive ? 'ready' : 'info');
            if (homingGuardPositionElement) {
              homingGuardPositionElement.textContent = `Coordinates: ${positionSegments.join(' · ')}`;
              setTone(homingGuardPositionElement, yarnExtrusionActive ? 'ready' : 'info');
            }
          }
          updateYarnFlowPanel(event, clampedIndex, totalSteps);
          lastPatternStepIndex = clampedIndex;
        }

        if (Math.abs(clampedProgress - lastPatternProgress) > 0.01) {
          if (patternProgressBarElement) {
            patternProgressBarElement.style.width = `${(clampedProgress * 100).toFixed(1)}%`;
          }
          lastPatternProgress = clampedProgress;
        }
      }
      function updatePatternPreview(elapsedSeconds) {
        if (!patternPreviewGroup) {
          return;
        }
        const preview = patternPreviewGroup.userData.preview;
        if (!preview || preview.totalDistance <= 0) {
          return;
        }

        const cycle = patternPreviewDurationSeconds;
        const wrapped = cycle > 0 ? elapsedSeconds % cycle : elapsedSeconds;
        const progress = wrapped / cycle;
        const targetDistance = progress * preview.totalDistance;

        let index = 0;
        while (
          index < preview.cumulativeDistances.length - 1 &&
          preview.cumulativeDistances[index + 1] < targetDistance
        ) {
          index += 1;
        }

        const startPoint = preview.points[index];
        const endPoint = preview.points[Math.min(index + 1, preview.points.length - 1)];
        const startDistance = preview.cumulativeDistances[index];
        const endDistance = preview.cumulativeDistances[
          Math.min(index + 1, preview.cumulativeDistances.length - 1)
        ];
        const segmentSpan = Math.max(endDistance - startDistance, 1e-6);
        const segmentProgress = (targetDistance - startDistance) / segmentSpan;

        preview.marker.position.lerpVectors(startPoint, endPoint, segmentProgress);
        const pulse = 0.6 + 0.4 * Math.sin(elapsedSeconds * 3.0);
        preview.marker.material.emissiveIntensity = pulse;

        if (preview.halo) {
          preview.halo.position.copy(preview.marker.position);
          const haloPulse = 0.35 + 0.3 * Math.sin(elapsedSeconds * 2.2);
          preview.haloMaterial.opacity = haloPulse;
        }

        updatePatternOverlay(index, progress);
      }

      function createSafetyShield() {
        const shieldGroup = new THREE.Group();
        shieldGroup.name = 'safety-shield';

        const shellMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x9fb7ff,
          transparent: true,
          opacity: 0.18,
          roughness: 0.08,
          metalness: 0.05,
          transmission: 0.82,
          thickness: 0.5,
          clearcoat: 0.6,
          clearcoatRoughness: 0.08,
        });

        const shell = new THREE.Mesh(
          new THREE.BoxGeometry(7.6, 4.8, 5.6),
          shellMaterial,
        );
        shell.position.set(0, 2.6, 0.3);
        shell.castShadow = false;
        shell.receiveShadow = false;
        shieldGroup.add(shell);
        addHoverInfo(
          shell,
          'Polycarbonate shield: translucent enclosure that keeps hands clear during motion demos.',
          { passthrough: true },
        );

        const edgeMaterial = new THREE.LineBasicMaterial({
          color: 0xc4d7ff,
          transparent: true,
          opacity: 0.55,
        });
        const shellEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(shell.geometry),
          edgeMaterial,
        );
        shell.add(shellEdges);

        const hingeMaterial = new THREE.MeshStandardMaterial({
          color: 0x4d5c87,
          metalness: 0.55,
          roughness: 0.35,
          emissive: 0x20283f,
        });

        const hinge = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 4.4, 24),
          hingeMaterial,
        );
        hinge.rotation.z = Math.PI / 2;
        hinge.position.set(3.65, 2.6, 0.3);
        hinge.castShadow = true;
        shieldGroup.add(hinge);

        const doorMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xaec9ff,
          transparent: true,
          opacity: 0.22,
          roughness: 0.1,
          transmission: 0.88,
          thickness: 0.45,
          metalness: 0.02,
        });

        const doorPivot = new THREE.Group();
        doorPivot.position.set(3.65, 2.6, 0.3);
        doorPivot.rotation.y = THREE.MathUtils.degToRad(-18);

        const door = new THREE.Mesh(
          new THREE.BoxGeometry(0.14, 4.4, 5.2),
          doorMaterial,
        );
        door.castShadow = false;
        door.receiveShadow = false;
        doorPivot.add(door);
        addHoverInfo(
          door,
          'Access door swings open for maintenance while keeping bystanders protected.',
        );

        const doorEdges = new THREE.LineSegments(
          new THREE.EdgesGeometry(door.geometry),
          new THREE.LineBasicMaterial({
            color: 0x90b4ff,
            transparent: true,
            opacity: 0.65,
          }),
        );
        door.add(doorEdges);
        shieldGroup.add(doorPivot);

        const latch = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.6, 0.6),
          hingeMaterial,
        );
        latch.position.set(3.9, 2.0, 2.8);
        latch.rotation.y = THREE.MathUtils.degToRad(-18);
        latch.castShadow = true;
        shieldGroup.add(latch);

        const glow = new THREE.PointLight(0x9fbfff, 0.8, 7.0);
        glow.position.set(3.1, 3.8, 2.2);
        shieldGroup.add(glow);

        const label = buildLabel('Polycarbonate Shield', '#d7e5ff');
        label.position.set(0, 4.9, 0.3);
        label.scale.multiplyScalar(0.55);
        shieldGroup.add(label);

        return shieldGroup;
      }

      function createSafeAccessPath() {
        const group = new THREE.Group();
        group.name = 'safe-access-path';

        const pathGeometry = new THREE.PlaneGeometry(3.0, 1.8);
        const pathMaterial = new THREE.MeshStandardMaterial({
          color: 0x66fddf,
          emissive: 0x1b7561,
          emissiveIntensity: 0.5,
          metalness: 0.08,
          roughness: 0.3,
          transparent: true,
          opacity: 0.72,
          side: THREE.DoubleSide,
          depthWrite: false,
        });
        const path = new THREE.Mesh(pathGeometry, pathMaterial);
        path.rotation.x = -Math.PI / 2;
        path.position.set(4.5, 0.025, 0.35);
        path.receiveShadow = false;
        group.add(path);
        addHoverInfo(
          path,
          'Mint-lit safe access path — follow the alternating, pulsing footprints to service the crochet cell without clipping hardware.',
        );
        safeAccessHighlights.push({
          material: pathMaterial,
          baseIntensity: 0.5,
          amplitude: 0.25,
          speed: 1.8,
          baseOpacity: 0.72,
          opacityAmplitude: 0.1,
          phaseOffset: 0,
        });

        const outline = new THREE.LineSegments(
          new THREE.EdgesGeometry(pathGeometry),
          new THREE.LineBasicMaterial({
            color: 0xa9fff0,
            transparent: true,
            opacity: 0.65,
          }),
        );
        outline.rotation.x = -Math.PI / 2;
        outline.position.copy(path.position);
        outline.position.y += 0.002;
        group.add(outline);

        const arrowMaterial = new THREE.MeshStandardMaterial({
          color: 0xc4fff3,
          emissive: 0x2c9c83,
          emissiveIntensity: 0.6,
          metalness: 0.12,
          roughness: 0.25,
        });
        const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.46, 32), arrowMaterial);
        arrow.rotation.z = -Math.PI / 2;
        arrow.position.set(3.55, 0.38, 0.35);
        arrow.castShadow = true;
        group.add(arrow);
        safeAccessHighlights.push({
          material: arrowMaterial,
          baseIntensity: 0.6,
          amplitude: 0.25,
          speed: 2.3,
          phaseOffset: Math.PI / 3,
        });

        const footstepGeometry = new THREE.CircleGeometry(0.26, 40);

        function createStepBadge(stepNumber, footSide) {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const context = canvas.getContext('2d');

          if (context) {
            context.clearRect(0, 0, canvas.width, canvas.height);

            context.save();
            context.translate(canvas.width / 2, canvas.height / 2);
            context.beginPath();
            context.arc(0, 0, canvas.width * 0.42, 0, Math.PI * 2);
            context.fillStyle = 'rgba(12, 37, 32, 0.84)';
            context.fill();
            context.lineWidth = canvas.width * 0.05;
            context.strokeStyle = 'rgba(214, 255, 245, 0.82)';
            context.stroke();
            context.restore();

            context.fillStyle = '#d6fff5';
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            context.font = `${canvas.height * 0.18}px "Segoe UI", sans-serif`;
            context.fillText('STEP', canvas.width / 2, canvas.height * 0.28);

            context.font = `700 ${canvas.height * 0.36}px "Segoe UI", sans-serif`;
            context.fillText(String(stepNumber), canvas.width / 2, canvas.height * 0.55);

            context.font = `${canvas.height * 0.17}px "Segoe UI", sans-serif`;
            context.fillText(footSide.toUpperCase(), canvas.width / 2, canvas.height * 0.78);
          }

          const texture = new THREE.CanvasTexture(canvas);
          texture.colorSpace = THREE.SRGBColorSpace;

          const material = new THREE.MeshStandardMaterial({
            map: texture,
            transparent: true,
            opacity: 0.95,
            metalness: 0.12,
            roughness: 0.45,
            emissive: 0x1e4d3f,
            emissiveIntensity: 0.65,
            side: THREE.DoubleSide,
            depthWrite: false,
          });

          const geometry = new THREE.PlaneGeometry(0.52, 0.52);
          const badge = new THREE.Mesh(geometry, material);
          badge.renderOrder = 5;

          return { badge, material };
        }

        function addFootstep(x, z, rotationDegrees, phaseOffset, stepNumber) {
          const footSide = stepNumber % 2 === 1 ? 'left' : 'right';
          const footprintMaterial = new THREE.MeshStandardMaterial({
            color: 0xdbfff4,
            emissive: 0x2f9270,
            emissiveIntensity: 0.48,
            metalness: 0.08,
            roughness: 0.24,
            transparent: true,
            opacity: 0.86,
            side: THREE.DoubleSide,
            depthWrite: false,
          });
          const footprint = new THREE.Mesh(footstepGeometry, footprintMaterial);
          footprint.rotation.x = -Math.PI / 2;
          footprint.rotation.y = THREE.MathUtils.degToRad(rotationDegrees);
          footprint.position.set(x, 0.03, z);
          footprint.scale.set(1.45, 1.0, 1.15);
          footprint.renderOrder = 3;
          group.add(footprint);
          addHoverInfo(
            footprint,
            `Safe access step ${stepNumber} — position your ${footSide} foot on the mint marker.`,
          );
          safeAccessHighlights.push({
            material: footprintMaterial,
            baseIntensity: 0.48,
            amplitude: 0.32,
            speed: 2.6,
            phaseOffset,
            baseOpacity: 0.86,
            opacityAmplitude: 0.18,
          });

          const toeMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0fff9,
            emissive: 0x42c9a2,
            emissiveIntensity: 0.55,
            metalness: 0.05,
            roughness: 0.22,
            transparent: true,
            opacity: 0.78,
            depthWrite: false,
          });
          const toe = new THREE.Mesh(new THREE.CircleGeometry(0.1, 24), toeMaterial);
          toe.rotation.x = -Math.PI / 2;
          toe.rotation.y = footprint.rotation.y;
          toe.position.set(
            x + Math.cos(footprint.rotation.y) * 0.22,
            0.031,
            z - Math.sin(footprint.rotation.y) * 0.22,
          );
          toe.scale.set(1.25, 1.0, 1.2);
          toe.renderOrder = 4;
          group.add(toe);
          addHoverInfo(
            toe,
            `Safe access step ${stepNumber} — position your ${footSide} foot on the mint marker.`,
          );
          safeAccessHighlights.push({
            material: toeMaterial,
            baseIntensity: 0.55,
            amplitude: 0.25,
            speed: 2.6,
            phaseOffset: phaseOffset + 0.7,
            baseOpacity: 0.78,
            opacityAmplitude: 0.15,
          });

        const { badge, material } = createStepBadge(stepNumber, footSide);
        const forwardOffset = 0.42;
        const radians = THREE.MathUtils.degToRad(rotationDegrees);
        const facingRadians = THREE.MathUtils.degToRad(rotationDegrees - 90);
        const baseHeight = 0.58;
        const baseTilt = THREE.MathUtils.degToRad(-10);
        badge.position.set(
          x + Math.cos(radians) * forwardOffset,
          baseHeight,
          z - Math.sin(radians) * forwardOffset,
        );
        badge.rotation.y = facingRadians;
        badge.rotation.x = baseTilt;
        group.add(badge);
        addHoverInfo(
          badge,
          `Safe access step ${stepNumber} signage — follow the numbered badges through the door.`,
        );
        safeAccessHighlights.push({
          material,
          baseIntensity: 0.65,
          amplitude: 0.22,
          speed: 2.2,
          phaseOffset: phaseOffset + 0.35,
          baseOpacity: 0.95,
          opacityAmplitude: 0.05,
          object: badge,
          visibleOnly: true,
        });
        stepBadgeControllers.push({
          badge,
          baseHeight,
          amplitude: 0.08,
          speed: 1.8,
          phaseOffset: phaseOffset + 0.35,
          baseTilt,
          tiltAmplitude: THREE.MathUtils.degToRad(3.5),
        });
      }

        const stepSequence = [
          { x: 3.85, z: 0.12, rotation: 8, phase: 0.0, step: 1 },
          { x: 4.15, z: 0.58, rotation: 12, phase: 0.45, step: 2 },
          { x: 4.45, z: 0.12, rotation: 8, phase: 0.9, step: 3 },
          { x: 4.75, z: 0.58, rotation: 12, phase: 1.35, step: 4 },
          { x: 5.05, z: 0.12, rotation: 8, phase: 1.8, step: 5 },
          { x: 5.35, z: 0.58, rotation: 12, phase: 2.25, step: 6 },
        ];
        stepSequence.forEach((step) =>
          addFootstep(step.x, step.z, step.rotation, step.phase, step.step),
        );

        const label = buildLabel('Safe Access Path', '#baffec');
        label.position.set(4.6, 0.92, -0.45);
        label.scale.multiplyScalar(0.44);
        group.add(label);

        const guideLight = new THREE.PointLight(0x8affe4, 1.15, 5.5);
        guideLight.position.set(4.25, 0.9, 0.35);
        group.add(guideLight);

        return group;
      }

      function createBeltGuards() {
        const group = new THREE.Group();
        group.name = 'belt-guards';

        const guardMaterial = new THREE.MeshStandardMaterial({
          color: 0x34425a,
          metalness: 0.55,
          roughness: 0.32,
          emissive: 0x141c29,
          emissiveIntensity: 0.45,
        });

        const windowMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x9eb9ff,
          transparent: true,
          opacity: 0.35,
          roughness: 0.12,
          metalness: 0.1,
          transmission: 0.75,
          thickness: 0.3,
        });

        const clipMaterial = new THREE.MeshStandardMaterial({
          color: 0x485673,
          metalness: 0.5,
          roughness: 0.35,
          emissive: 0x1b2333,
          emissiveIntensity: 0.35,
        });

        const guardLength = FRAME_HALF_WIDTH * 2 - 0.5;
        const guardHeight = 0.16;
        const guardDepth = 0.48;
        const guardY = UPPER_RAIL_Y + 0.18;
        const guardOffsetZ = FRAME_HALF_DEPTH - 0.42;

        [-1, 1].forEach((direction, index) => {
          const guard = new THREE.Mesh(
            new THREE.BoxGeometry(guardLength, guardHeight, guardDepth),
            guardMaterial,
          );
          guard.position.set(0, guardY, direction * guardOffsetZ);
          guard.castShadow = true;
          guard.receiveShadow = true;
          group.add(guard);

          if (index === 0) {
            addHoverInfo(
              guard,
              'Snap-on belt guard — shields CoreXY belts from snagging while leaving inspection slots.',
            );
          }

          const inspectionWindow = new THREE.Mesh(
            new THREE.BoxGeometry(
              guardLength * 0.82,
              guardHeight * 0.55,
              guardDepth * 0.55,
            ),
            windowMaterial,
          );
          inspectionWindow.position.set(0, 0.02, 0);
          inspectionWindow.renderOrder = 1;
          guard.add(inspectionWindow);

          const clipPositions = [-guardLength * 0.42, 0, guardLength * 0.42];
          clipPositions.forEach((xPosition) => {
            const clip = new THREE.Mesh(
              new THREE.BoxGeometry(
                guardHeight * 0.85,
                guardHeight * 0.8,
                guardDepth + 0.12,
              ),
              clipMaterial,
            );
            clip.position.set(xPosition, -guardHeight * 0.5, 0);
            clip.castShadow = true;
            clip.receiveShadow = true;
            guard.add(clip);
          });

          const edgeGeometry = new THREE.EdgesGeometry(
            new THREE.BoxGeometry(guardLength, guardHeight, guardDepth),
          );
          const edgeMaterial = new THREE.LineBasicMaterial({
            color: 0xaec6ff,
            transparent: true,
            opacity: 0.55,
          });
          const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
          guard.add(edges);
        });

        const crossGuardLength = FRAME_HALF_DEPTH * 2 - 0.9;
        const crossSpacing = FRAME_HALF_WIDTH - 1.2;

        [-1, 1].forEach((direction) => {
          const crossGuard = new THREE.Mesh(
            new THREE.BoxGeometry(guardHeight, guardHeight, crossGuardLength),
            guardMaterial,
          );
          crossGuard.position.set(direction * crossSpacing, guardY, 0.35);
          crossGuard.castShadow = true;
          crossGuard.receiveShadow = true;
          group.add(crossGuard);

          const crossWindow = new THREE.Mesh(
            new THREE.BoxGeometry(
              guardHeight * 0.6,
              guardHeight * 0.5,
              crossGuardLength * 0.6,
            ),
            windowMaterial,
          );
          crossWindow.position.set(0, 0.015, 0);
          crossWindow.renderOrder = 1;
          crossGuard.add(crossWindow);
        });

        const beltLabel = buildLabel('Snap-On Belt Guards', '#c5d6ff');
        beltLabel.position.set(0, guardY + 0.55, 0.9);
        beltLabel.scale.multiplyScalar(0.45);
        group.add(beltLabel);

        const accent = new THREE.PointLight(0x7ea4ff, 0.9, 5.5);
        accent.position.set(0.4, guardY + 0.3, guardOffsetZ);
        group.add(accent);

        return group;
      }

      function createAxisOrientationBeacons() {
        const group = new THREE.Group();
        group.name = 'axis-orientation-beacons';

        const baseHeight = 0.06;
        const columnHeight = 1.15;
        const arrowLength = 0.9;

        const pedestalMaterial = new THREE.MeshStandardMaterial({
          color: 0x1a2739,
          metalness: 0.38,
          roughness: 0.48,
          emissive: 0x091324,
          emissiveIntensity: 0.35,
        });

        const definitions = [
          {
            axis: 'X',
            color: 0xff6b6b,
            light: 0xffb6a8,
            labelColor: '#ffc9c9',
            direction: new THREE.Vector3(1, 0, 0),
            position: new THREE.Vector3(-3.05, 0, -1.45),
            hover: 'X-axis beacon — points toward positive X travel along the gantry.',
          },
          {
            axis: 'Y',
            color: 0x6bff95,
            light: 0xb9ffd4,
            labelColor: '#c9ffe0',
            direction: new THREE.Vector3(0, 0, 1),
            position: new THREE.Vector3(-3.05, 0, -0.25),
            hover: 'Y-axis beacon — points toward positive Y travel across the plaza.',
          },
          {
            axis: 'Z',
            color: 0x66a0ff,
            light: 0xc2d8ff,
            labelColor: '#d5e5ff',
            direction: new THREE.Vector3(0, 1, 0),
            position: new THREE.Vector3(-3.05, 0, 0.95),
            hover: 'Z-axis beacon — highlights upward motion for plunge depth checks.',
          },
        ];

        const orientationLabelOffset = definitions.reduce(
          (accumulator, definition) => accumulator + definition.position.z,
          0,
        ) / definitions.length;

        definitions.forEach((definition, index) => {
          const { axis, color, light, labelColor, direction, position, hover } = definition;
          const beacon = new THREE.Group();
          beacon.position.copy(position);
          beacon.name = `${axis.toLowerCase()}-axis-beacon`;

          const pedestal = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.26, baseHeight * 2, 28),
            pedestalMaterial,
          );
          pedestal.position.y = baseHeight;
          pedestal.castShadow = true;
          pedestal.receiveShadow = true;
          beacon.add(pedestal);

          const columnMaterial = new THREE.MeshStandardMaterial({
            color,
            emissive: new THREE.Color(color).multiplyScalar(0.35),
            emissiveIntensity: 0.65,
            metalness: 0.32,
            roughness: 0.32,
            transparent: true,
            opacity: 0.82,
            depthWrite: false,
          });
          const column = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, columnHeight, 36),
            columnMaterial,
          );
          column.position.y = baseHeight * 2 + columnHeight / 2;
          column.castShadow = true;
          column.receiveShadow = true;
          beacon.add(column);
          addHoverInfo(column, hover);
          safeAccessHighlights.push({
            material: columnMaterial,
            baseIntensity: 0.65,
            amplitude: 0.28,
            speed: 2.1,
            phaseOffset: index * 0.6,
            baseOpacity: 0.82,
            opacityAmplitude: 0.12,
          });

          const arrowMaterial = new THREE.MeshStandardMaterial({
            color,
            emissive: new THREE.Color(color).multiplyScalar(0.55),
            emissiveIntensity: 0.9,
            metalness: 0.42,
            roughness: 0.28,
            transparent: true,
            opacity: 0.88,
            depthWrite: false,
          });

          const arrowGroup = new THREE.Group();
          arrowGroup.position.y = baseHeight * 2 + columnHeight;
          const shaftLength = arrowLength * 0.65;
          const tipLength = arrowLength - shaftLength;
          const shaft = new THREE.Mesh(
            new THREE.CylinderGeometry(0.022, 0.022, shaftLength, 20),
            arrowMaterial,
          );
          shaft.position.y = shaftLength / 2;
          shaft.castShadow = true;
          arrowGroup.add(shaft);

          const tip = new THREE.Mesh(
            new THREE.ConeGeometry(0.07, tipLength, 28),
            arrowMaterial,
          );
          tip.position.y = shaftLength + tipLength / 2;
          tip.castShadow = true;
          arrowGroup.add(tip);

          const orientation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            direction.clone().normalize(),
          );
          arrowGroup.quaternion.copy(orientation);
          beacon.add(arrowGroup);
          addHoverInfo(arrowGroup, hover, { passthrough: true });
          safeAccessHighlights.push({
            material: arrowMaterial,
            baseIntensity: 0.9,
            amplitude: 0.35,
            speed: 2.6,
            phaseOffset: 0.4 + index * 0.55,
            baseOpacity: 0.88,
            opacityAmplitude: 0.1,
          });

          const beaconLight = new THREE.PointLight(light, 1.1, 3.2);
          beaconLight.position.set(0, arrowLength, 0);
          arrowGroup.add(beaconLight);

          const label = buildLabel(`${axis}-Axis Beacon`, labelColor);
          label.position.set(0, baseHeight * 2 + columnHeight + arrowLength + 0.22, 0);
          label.scale.multiplyScalar(0.32);
          beacon.add(label);

          group.add(beacon);
        });

        const banner = buildLabel('Axis Orientation Beacons', '#d4e8ff');
        banner.position.set(-3.05, baseHeight * 2 + columnHeight + arrowLength + 0.68, orientationLabelOffset);
        banner.scale.multiplyScalar(0.36);
        group.add(banner);

        return group;
      }

      function createElectronicsBay() {
        const group = new THREE.Group();
        group.name = 'electronics-bay';

        const enclosureMaterial = new THREE.MeshStandardMaterial({
          color: 0x1d2639,
          metalness: 0.48,
          roughness: 0.42,
          emissive: 0x0c1321,
          emissiveIntensity: 0.35,
        });
        const enclosure = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.9, 1.2),
          enclosureMaterial,
        );
        enclosure.position.y = 0.45;
        enclosure.castShadow = true;
        group.add(enclosure);
        addHoverInfo(
          enclosure,
          'Electronics bay — shields the controller, drivers, and airflow ducting.',
          { passthrough: true },
        );

        const accessPanel = new THREE.Mesh(
          new THREE.PlaneGeometry(1.4, 0.6),
          new THREE.MeshStandardMaterial({
            color: 0x253656,
            emissive: 0x37548e,
            emissiveIntensity: 0.55,
            transparent: true,
            opacity: 0.65,
            side: THREE.DoubleSide,
          }),
        );
        accessPanel.position.set(0, 0.5, 0.62);
        group.add(accessPanel);

        const vent = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 0.08, 0.08),
          new THREE.MeshStandardMaterial({
            color: 0x455b83,
            metalness: 0.52,
            roughness: 0.34,
          }),
        );
        vent.position.set(0, 0.86, 0.56);
        vent.castShadow = true;
        group.add(vent);

        const controller = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 0.1, 0.68),
          new THREE.MeshStandardMaterial({
            color: 0x1c3d33,
            emissive: 0x0c231d,
            emissiveIntensity: 0.65,
            metalness: 0.32,
            roughness: 0.36,
          }),
        );
        controller.position.set(0, 0.32, 0);
        controller.castShadow = true;
        group.add(controller);
        addHoverInfo(
          controller,
          'Controller stack — SKR Mini and stepper drivers route motion commands.',
        );

        const heatsink = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.16, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x89a8ff,
            emissive: 0x2b448a,
            emissiveIntensity: 0.7,
            metalness: 0.68,
            roughness: 0.28,
          }),
        );
        heatsink.position.set(-0.32, 0.5, -0.12);
        heatsink.castShadow = true;
        group.add(heatsink);

        const fan = new THREE.Mesh(
          new THREE.CylinderGeometry(0.26, 0.26, 0.12, 32),
          new THREE.MeshStandardMaterial({
            color: 0x121722,
            metalness: 0.42,
            roughness: 0.38,
          }),
        );
        fan.rotation.x = Math.PI / 2;
        fan.position.set(0.54, 0.48, 0);
        fan.castShadow = true;
        group.add(fan);
        addHoverInfo(fan, 'Cooling fan — pulls heat away from the driver stack.');

        const fanGlow = new THREE.PointLight(0x6fd8ff, 1.4, 2.8);
        fanGlow.position.set(0.54, 0.88, 0.1);
        group.add(fanGlow);

        const harness = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 1.6, 16),
          new THREE.MeshStandardMaterial({
            color: 0x2c3b52,
            metalness: 0.3,
            roughness: 0.4,
            emissive: 0x111a2a,
            emissiveIntensity: 0.4,
          }),
        );
        harness.rotation.z = Math.PI / 2.4;
        harness.position.set(-0.15, 0.18, 0.38);
        harness.castShadow = true;
        group.add(harness);
        addHoverInfo(
          harness,
          'Cable harness — bundles stepper power and sensor leads toward the gantry.',
        );

        const thermistorMaterial = new THREE.MeshStandardMaterial({
          color: 0xffc59d,
          emissive: 0xff884f,
          emissiveIntensity: 0.55,
          metalness: 0.22,
          roughness: 0.32,
          transparent: true,
          opacity: 0.82,
          depthWrite: false,
        });
        const thermistorCurve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(-0.42, 0.28, 0.16),
          new THREE.Vector3(-0.18, 0.3, 0.42),
          new THREE.Vector3(0.12, 0.38, 0.68),
          new THREE.Vector3(0.36, 0.5, 0.86),
        ]);
        const thermistorChannel = new THREE.Mesh(
          new THREE.TubeGeometry(thermistorCurve, 40, 0.025, 16, false),
          thermistorMaterial,
        );
        thermistorChannel.castShadow = false;
        thermistorChannel.receiveShadow = false;
        group.add(thermistorChannel);
        addHoverInfo(
          thermistorChannel,
          'Thermistor channel — reserved wiring path for the future heated bed accessory.',
          { passthrough: true },
        );
        safeAccessHighlights.push({
          material: thermistorMaterial,
          baseIntensity: 0.55,
          amplitude: 0.25,
          speed: 2.1,
          phaseOffset: 0.35,
          baseOpacity: 0.82,
          opacityAmplitude: 0.12,
        });

        const thermistorGlow = new THREE.PointLight(0xffa15f, 0.9, 2.4);
        thermistorGlow.position.set(0.32, 0.78, 0.88);
        group.add(thermistorGlow);

        const thermistorLabel = buildLabel('Thermistor Channel', '#ffd9c2');
        thermistorLabel.position.set(0.28, 0.92, 0.94);
        thermistorLabel.scale.multiplyScalar(0.34);
        group.add(thermistorLabel);

        const statusLed = new THREE.Mesh(
          new THREE.SphereGeometry(0.08, 16, 16),
          new THREE.MeshStandardMaterial({
            color: 0x7dffbe,
            emissive: 0x33d18a,
            emissiveIntensity: 1.0,
            metalness: 0.2,
            roughness: 0.25,
          }),
        );
        statusLed.position.set(-0.68, 0.68, 0.58);
        statusLed.castShadow = true;
        group.add(statusLed);

        const statusLight = new THREE.PointLight(0x66ffc2, 1.2, 2.2);
        statusLight.position.copy(statusLed.position);
        statusLight.position.y += 0.2;
        group.add(statusLight);

        const label = buildLabel('Electronics Bay', '#a9c8ff');
        label.position.set(0, 1.02, 0.62);
        label.scale.multiplyScalar(0.42);
        group.add(label);

        return group;
      }

      function createTensionPostAssembly() {
        const group = new THREE.Group();
        group.name = 'tension-post-assembly';

        const baseMaterial = new THREE.MeshStandardMaterial({
          color: 0x1d2838,
          metalness: 0.48,
          roughness: 0.36,
        });
        const base = new THREE.Mesh(
          new THREE.CylinderGeometry(0.36, 0.4, 0.12, 32),
          baseMaterial,
        );
        base.position.y = 0.06;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        const riserMaterial = new THREE.MeshStandardMaterial({
          color: 0xd4e2ff,
          metalness: 0.42,
          roughness: 0.25,
          emissive: 0x1c2741,
          emissiveIntensity: 0.4,
        });
        const riserGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.9, 32);
        [-0.16, 0.16].forEach((xOffset, index) => {
          const riser = new THREE.Mesh(riserGeometry, riserMaterial);
          riser.position.set(xOffset, 0.48, 0);
          riser.castShadow = true;
          group.add(riser);
          safeAccessHighlights.push({
            material: riserMaterial,
            baseIntensity: 0.4,
            amplitude: 0.15,
            speed: 1.6,
            phaseOffset: index * 1.2,
          });
        });

        const brace = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 0.38, 24),
          new THREE.MeshStandardMaterial({
            color: 0x7f91b0,
            metalness: 0.55,
            roughness: 0.32,
          }),
        );
        brace.rotation.z = Math.PI / 2;
        brace.position.set(0, 0.88, 0);
        brace.castShadow = true;
        group.add(brace);

        const feltMaterial = new THREE.MeshStandardMaterial({
          color: 0x2c4a3e,
          metalness: 0.15,
          roughness: 0.7,
          emissive: 0x0a1c16,
          emissiveIntensity: 0.5,
        });
        const feltPad = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 0.04, 32),
          feltMaterial,
        );
        feltPad.position.set(0, 0.92, 0);
        feltPad.castShadow = true;
        group.add(feltPad);
        addHoverInfo(
          feltPad,
          'Felt pads cushion yarn wraps so swaps stay smooth and abrasion-free.',
        );
        safeAccessHighlights.push({
          material: feltMaterial,
          baseIntensity: 0.5,
          amplitude: 0.2,
          speed: 1.8,
          phaseOffset: 0.6,
        });

        const clipMaterial = new THREE.MeshStandardMaterial({
          color: 0xfff0c4,
          metalness: 0.75,
          roughness: 0.18,
          emissive: 0x6d4f20,
          emissiveIntensity: 0.6,
        });
        const clip = new THREE.Mesh(
          new THREE.TorusGeometry(0.24, 0.03, 16, 64, Math.PI * 1.3),
          clipMaterial,
        );
        clip.rotation.x = Math.PI / 2;
        clip.rotation.z = Math.PI / 2;
        clip.position.set(0, 0.94, 0);
        clip.castShadow = true;
        group.add(clip);
        addHoverInfo(
          clip,
          'Spring clip pins yarn against the felt to hold tension during swaps.',
        );
        safeAccessHighlights.push({
          material: clipMaterial,
          baseIntensity: 0.6,
          amplitude: 0.25,
          speed: 2.0,
          phaseOffset: 1.4,
        });

        const guideRingMaterial = new THREE.MeshStandardMaterial({
          color: 0xaff3ff,
          metalness: 0.28,
          roughness: 0.22,
          emissive: 0x1f4f59,
          emissiveIntensity: 0.45,
        });
        const guideRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.14, 0.02, 16, 48),
          guideRingMaterial,
        );
        guideRing.rotation.y = Math.PI / 2;
        guideRing.position.set(0.32, 0.88, 0);
        guideRing.castShadow = true;
        group.add(guideRing);
        addHoverInfo(
          guideRing,
          'Guide ring hands yarn into the PTFE tube without nicking fibers.',
        );
        safeAccessHighlights.push({
          material: guideRingMaterial,
          baseIntensity: 0.45,
          amplitude: 0.2,
          speed: 2.2,
          phaseOffset: 0.4,
        });

        const support = new THREE.Mesh(
          new THREE.BoxGeometry(0.18, 0.22, 0.36),
          new THREE.MeshStandardMaterial({
            color: 0x253241,
            metalness: 0.32,
            roughness: 0.48,
          }),
        );
        support.position.set(0, 0.2, -0.12);
        support.castShadow = true;
        group.add(support);

        const accent = new THREE.PointLight(0xa6fbff, 0.9, 2.8);
        accent.position.set(0.1, 1.15, 0.1);
        group.add(accent);

        const label = buildLabel('Tension Post & PTFE Guide', '#b9fff6');
        label.position.set(0.05, 1.2, 0.34);
        label.scale.multiplyScalar(0.38);
        group.add(label);

        const guideEntry = new THREE.Object3D();
        guideEntry.position.set(-0.3, 0.9, 0);
        group.add(guideEntry);

        const guideExit = new THREE.Object3D();
        guideExit.position.set(0.3, 0.9, 0);
        group.add(guideExit);

        group.userData.guideEntry = guideEntry;
        group.userData.guideExit = guideExit;

        return group;
      }

      function createExtrusionFrame() {
        const frameGroup = new THREE.Group();
        frameGroup.name = 'extrusion-frame';

        const aluminumMaterial = new THREE.MeshStandardMaterial({
          color: 0xa8b4c9,
          metalness: 0.65,
          roughness: 0.28,
          emissive: 0x1c2331,
          emissiveIntensity: 0.25,
        });

        const cornerMaterial = new THREE.MeshStandardMaterial({
          color: 0x2d3a52,
          metalness: 0.45,
          roughness: 0.4,
          emissive: 0x121826,
          emissiveIntensity: 0.55,
        });

        const footMaterial = new THREE.MeshStandardMaterial({
          color: 0x14181f,
          metalness: 0.3,
          roughness: 0.55,
          emissive: 0x050608,
          emissiveIntensity: 0.45,
        });

        const lowerRailY = LOWER_RAIL_Y;
        const upperRailY = UPPER_RAIL_Y;
        const railThickness = RAIL_THICKNESS;
        const frameHalfWidth = FRAME_HALF_WIDTH;
        const frameHalfDepth = FRAME_HALF_DEPTH;

        const longRailGeometry = new THREE.BoxGeometry(frameHalfWidth * 2, railThickness, railThickness);
        const shortRailGeometry = new THREE.BoxGeometry(railThickness, railThickness, frameHalfDepth * 2);

        const rails = [
          { geometry: longRailGeometry, position: new THREE.Vector3(0, lowerRailY, frameHalfDepth) },
          { geometry: longRailGeometry, position: new THREE.Vector3(0, lowerRailY, -frameHalfDepth) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(frameHalfWidth, lowerRailY, 0.3) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(-frameHalfWidth, lowerRailY, 0.3) },
          { geometry: longRailGeometry, position: new THREE.Vector3(0, upperRailY, frameHalfDepth) },
          { geometry: longRailGeometry, position: new THREE.Vector3(0, upperRailY, -frameHalfDepth) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(frameHalfWidth, upperRailY, 0.3) },
          { geometry: shortRailGeometry, position: new THREE.Vector3(-frameHalfWidth, upperRailY, 0.3) },
        ];

        rails.forEach(({ geometry, position }, index) => {
          const rail = new THREE.Mesh(geometry, aluminumMaterial);
          rail.position.copy(position);
          rail.castShadow = true;
          frameGroup.add(rail);

          if (index === 0) {
            addHoverInfo(
              rail,
              'Aluminum extrusion frame — 20×20 mm perimeter with corner cubes and leveling feet.',
            );
          }
        });

        const postHeight = upperRailY - lowerRailY;
        const postGeometry = new THREE.BoxGeometry(railThickness, postHeight, railThickness);
        const postPositions = [
          [frameHalfWidth, (upperRailY + lowerRailY) / 2, frameHalfDepth],
          [-frameHalfWidth, (upperRailY + lowerRailY) / 2, frameHalfDepth],
          [frameHalfWidth, (upperRailY + lowerRailY) / 2, -frameHalfDepth],
          [-frameHalfWidth, (upperRailY + lowerRailY) / 2, -frameHalfDepth],
        ];
        postPositions.forEach(([x, y, z]) => {
          const post = new THREE.Mesh(postGeometry, aluminumMaterial);
          post.position.set(x, y, z);
          post.castShadow = true;
          frameGroup.add(post);
        });

        const cornerGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const cornerY = lowerRailY + 0.16;
        postPositions.forEach(([x, , z]) => {
          const cube = new THREE.Mesh(cornerGeometry, cornerMaterial);
          cube.position.set(x, cornerY, z);
          cube.castShadow = true;
          frameGroup.add(cube);
        });

        const footGeometry = new THREE.CylinderGeometry(0.3, 0.34, 0.28, 24);
        const footY = 0.14;
        postPositions.forEach(([x, , z]) => {
          const foot = new THREE.Mesh(footGeometry, footMaterial);
          foot.position.set(x, footY, z);
          foot.castShadow = true;
          frameGroup.add(foot);
          addHoverInfo(foot, 'Leveling foot — printed pad keeps the frame stable on workbenches.');
        });

        const accentLight = new THREE.PointLight(0xb7c9ff, 1.1, 12.0);
        accentLight.position.set(0, upperRailY + 0.5, 0.2);
        frameGroup.add(accentLight);

        const frameLabel = buildLabel('Extrusion Frame', '#dbe8ff');
        frameLabel.position.set(0, upperRailY + 0.6, -frameHalfDepth - 0.2);
        frameLabel.scale.multiplyScalar(0.5);
        frameGroup.add(frameLabel);

        return frameGroup;
      }

      function createV1CAssembly() {
        const group = new THREE.Group();
        group.name = 'v1c-assembly';

        const extrusionFrame = createExtrusionFrame();
        group.add(extrusionFrame);

        const chassisMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a9bff,
          metalness: 0.35,
          roughness: 0.4,
        });
        const chassis = new THREE.Mesh(
          new THREE.BoxGeometry(6, 0.8, 4),
          chassisMaterial,
        );
        chassis.position.y = 0.4;
        chassis.castShadow = true;
        chassis.receiveShadow = true;
        group.add(chassis);
        addHoverInfo(
          chassis,
          'v1c base platform — houses the drive electronics and bed alignment rails.',
        );

        const bedMaterial = new THREE.MeshStandardMaterial({
          color: 0xbfe4ff,
          metalness: 0.2,
          roughness: 0.3,
          transparent: true,
          opacity: 0.9,
          emissive: 0x1b3a4f,
        });
        const bedThickness = 0.25;
        const bed = new THREE.Mesh(new THREE.BoxGeometry(4.8, bedThickness, 3.2), bedMaterial);
        bed.position.set(0, 0.9, 0.2);
        bed.castShadow = true;
        bed.receiveShadow = true;
        group.add(bed);
        addHoverInfo(
          bed,
          'Workpiece support bed: removable build plate with magnetic anchors for swatch staging.',
        );

        const electronicsBay = createElectronicsBay();
        electronicsBay.position.set(-2.1, 0.4, -1.4);
        group.add(electronicsBay);

        const axisBeacons = createAxisOrientationBeacons();
        group.add(axisBeacons);

        const tensionAssembly = createTensionPostAssembly();
        tensionAssembly.position.set(-1.5, 0.92, -1.32);
        group.add(tensionAssembly);

        const bedTopY = bed.position.y + bedThickness / 2;
        const anchorsGroup = new THREE.Group();
        anchorsGroup.name = 'magnetic-anchors';
        const anchorBaseMaterial = new THREE.MeshStandardMaterial({
          color: 0x3f4657,
          metalness: 0.55,
          roughness: 0.32,
        });
        const anchorCapTemplate = new THREE.MeshStandardMaterial({
          color: 0xffe3a4,
          metalness: 0.82,
          roughness: 0.22,
          emissive: 0x8a5a1a,
          emissiveIntensity: 0.45,
        });
        const anchorOffsets = [
          [-1.8, -1.0],
          [1.8, -1.0],
          [-1.8, 1.2],
          [1.8, 1.2],
        ];
        anchorOffsets.forEach(([x, z], index) => {
          const anchorGroup = new THREE.Group();
          anchorGroup.position.set(x, bedTopY + 0.05, z);

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.22, 0.24, 0.08, 32),
            anchorBaseMaterial,
          );
          base.castShadow = true;
          base.receiveShadow = true;
          anchorGroup.add(base);

          const core = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.06, 24),
            new THREE.MeshStandardMaterial({
              color: 0x1b2233,
              metalness: 0.35,
              roughness: 0.45,
            }),
          );
          core.position.y = 0.03;
          core.castShadow = true;
          anchorGroup.add(core);

          const capMaterial = anchorCapTemplate.clone();
          const cap = new THREE.Mesh(
            new THREE.CylinderGeometry(0.14, 0.14, 0.045, 32),
            capMaterial,
          );
          cap.position.y = 0.065;
          cap.castShadow = true;
          anchorGroup.add(cap);
          addHoverInfo(
            cap,
            'Magnetic anchor puck — secures swap-in plates with embedded magnets.',
          );

          const haloMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd27f,
            emissive: 0xffb347,
            emissiveIntensity: 0.5,
            metalness: 0.65,
            roughness: 0.28,
            transparent: true,
            opacity: 0.8,
          });
          const halo = new THREE.Mesh(new THREE.TorusGeometry(0.18, 0.012, 16, 48), haloMaterial);
          halo.rotation.x = Math.PI / 2;
          halo.position.y = 0.028;
          anchorGroup.add(halo);

          const anchorGlow = new THREE.PointLight(0xffdeaa, 0.55, 1.4);
          anchorGlow.position.set(0, 0.2, 0);
          anchorGroup.add(anchorGlow);

          anchorPulseControllers.push({
            capMaterial,
            haloMaterial,
            halo,
            light: anchorGlow,
            baseCapIntensity: capMaterial.emissiveIntensity ?? 0.45,
            capAmplitude: 0.55,
            baseHaloIntensity: haloMaterial.emissiveIntensity ?? 0.5,
            haloAmplitude: 0.65,
            baseHaloOpacity: typeof haloMaterial.opacity === 'number' ? haloMaterial.opacity : 0.8,
            haloOpacityAmplitude: 0.18,
            haloScaleAmplitude: 0.12,
            baseLightIntensity: anchorGlow.intensity,
            lightAmplitude: 0.75,
            phaseOffset: index / anchorOffsets.length,
            speed: 0.22,
          });

          anchorsGroup.add(anchorGroup);
        });

        const anchorsLabel = buildLabel('Magnetic Anchors', '#ffe8bf');
        anchorsLabel.position.set(0, bedTopY + 0.62, 1.5);
        anchorsLabel.scale.multiplyScalar(0.42);
        anchorsGroup.add(anchorsLabel);
        group.add(anchorsGroup);

        const gantryMaterial = new THREE.MeshStandardMaterial({
          color: 0xffc857,
          metalness: 0.2,
          roughness: 0.3,
          emissive: 0x332400,
        });
        const gantry = new THREE.Mesh(new THREE.BoxGeometry(0.6, 4.5, 6.5), gantryMaterial);
        gantry.position.set(0, 2.75, 0.35);
        gantry.castShadow = true;
        group.add(gantry);
        addHoverInfo(
          gantry,
          'Dual-axis gantry lifts the crocheting effector while guiding yarn tension.',
        );

        const zLiftGroup = new THREE.Group();
        zLiftGroup.name = 'z-axis-leadscrew';
        zLiftGroup.position.set(1.45, 0.8, 0.3);

        const zStepperMaterial = new THREE.MeshStandardMaterial({
          color: 0x1c1f2b,
          metalness: 0.55,
          roughness: 0.32,
          emissive: 0x0b0e18,
          emissiveIntensity: 0.35,
        });
        const zStepperHeight = 0.6;
        const zStepper = new THREE.Mesh(
          new THREE.BoxGeometry(0.62, zStepperHeight, 0.62),
          zStepperMaterial,
        );
        zStepper.position.set(0, zStepperHeight / 2, 0);
        zStepper.castShadow = true;
        zStepper.receiveShadow = true;
        zLiftGroup.add(zStepper);
        addHoverInfo(
          zStepper,
          'Compact Z stepper — drives the leadscrew for hook penetration control.',
        );

        const couplerMaterial = new THREE.MeshStandardMaterial({
          color: 0x3c4b6d,
          metalness: 0.7,
          roughness: 0.3,
          emissive: 0x1d2b47,
          emissiveIntensity: 0.4,
        });
        const coupler = new THREE.Mesh(
          new THREE.CylinderGeometry(0.22, 0.22, 0.18, 24),
          couplerMaterial,
        );
        coupler.position.set(0, zStepperHeight + 0.09, 0);
        coupler.castShadow = true;
        coupler.receiveShadow = true;
        zLiftGroup.add(coupler);

        const leadscrewMaterial = new THREE.MeshStandardMaterial({
          color: 0xc7d8ff,
          metalness: 0.85,
          roughness: 0.22,
          emissive: 0x415073,
          emissiveIntensity: 0.35,
        });
        const leadscrewHeight = 3.5;
        const leadscrew = new THREE.Mesh(
          new THREE.CylinderGeometry(0.11, 0.11, leadscrewHeight, 48),
          leadscrewMaterial,
        );
        leadscrew.position.set(0, zStepperHeight + 0.18 + leadscrewHeight / 2, 0);
        leadscrew.castShadow = true;
        leadscrew.receiveShadow = true;
        zLiftGroup.add(leadscrew);
        addHoverInfo(
          leadscrew,
          'Z-axis T8 leadscrew — raises the hook carriage with a 2 mm pitch.',
        );
        safeAccessHighlights.push({
          material: leadscrewMaterial,
          baseIntensity: 0.35,
          amplitude: 0.22,
          speed: 1.8,
          phaseOffset: 0.3,
        });

        const nutMaterial = new THREE.MeshStandardMaterial({
          color: 0xffe0ad,
          metalness: 0.7,
          roughness: 0.28,
          emissive: 0x6a3910,
          emissiveIntensity: 0.5,
        });
        const nut = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.26, 32), nutMaterial);
        nut.position.set(0, zStepperHeight + 1.74, 0);
        nut.castShadow = true;
        nut.receiveShadow = true;
        zLiftGroup.add(nut);
        addHoverInfo(
          nut,
          'Anti-backlash nut — preloads the Z carriage to suppress wobble.',
        );
        safeAccessHighlights.push({
          material: nutMaterial,
          baseIntensity: 0.55,
          amplitude: 0.28,
          speed: 2.4,
          phaseOffset: 1.1,
        });

        const flexureMaterial = new THREE.MeshStandardMaterial({
          color: 0xffc37a,
          metalness: 0.4,
          roughness: 0.32,
          emissive: 0x703808,
          emissiveIntensity: 0.45,
        });
        const flexureGeometry = new THREE.BoxGeometry(0.08, 0.42, 0.36);
        const flexureOffset = 0.26;
        [-1, 1].forEach((direction) => {
          const flexure = new THREE.Mesh(flexureGeometry, flexureMaterial);
          flexure.position.set(direction * flexureOffset, nut.position.y, 0);
          flexure.castShadow = true;
          flexure.receiveShadow = true;
          zLiftGroup.add(flexure);
        });
        addHoverInfo(
          zLiftGroup,
          'Printed flexures clamp the anti-backlash nut and absorb carriage backlash.',
          { passthrough: true },
        );
        safeAccessHighlights.push({
          material: flexureMaterial,
          baseIntensity: 0.5,
          amplitude: 0.3,
          speed: 2.0,
          phaseOffset: 0.6,
        });

        const zLiftLabel = buildLabel('Z-Axis Leadscrew', '#d8f0ff');
        zLiftLabel.position.set(0, zStepperHeight + leadscrewHeight + 0.7, 0);
        zLiftLabel.scale.multiplyScalar(0.34);
        zLiftGroup.add(zLiftLabel);

        const zLiftGlow = new THREE.PointLight(0xaad6ff, 0.9, 3.2);
        zLiftGlow.position.set(0, nut.position.y + 0.4, 0.2);
        zLiftGroup.add(zLiftGlow);

        group.add(zLiftGroup);

        const beltGuards = createBeltGuards();
        group.add(beltGuards);

        const effectorMaterial = new THREE.MeshStandardMaterial({
          color: 0xff6f91,
          roughness: 0.35,
          metalness: 0.15,
          emissive: 0x401220,
        });
        const effectorGeometry = new THREE.CylinderGeometry(0.45, 0.6, 2.2, 32);
        const effector = new THREE.Mesh(effectorGeometry, effectorMaterial);
        effector.rotation.z = Math.PI / 2;
        effector.position.set(1.8, 2.4, 0.6);
        effector.castShadow = true;
        group.add(effector);
        const effectorGuide = new THREE.Object3D();
        effectorGuide.position.set(0.58, 0.24, 0.28);
        effector.add(effectorGuide);
        effector.userData.guide = effectorGuide;
        addHoverInfo(
          effector,
          'Crochet effector: hooks yarn, executes stitch choreography, and measures tension.',
        );

        const fanGroup = new THREE.Group();
        fanGroup.name = 'cooling-fan-assembly';
        fanGroup.position.set(2.35, 2.7, 0.6);

        const bracketMaterial = new THREE.MeshStandardMaterial({
          color: 0x2f3a55,
          metalness: 0.55,
          roughness: 0.35,
          emissive: 0x101627,
          emissiveIntensity: 0.6,
        });
        const bracket = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.92, 0.68), bracketMaterial);
        bracket.position.set(-0.18, 0.02, 0.02);
        bracket.castShadow = true;
        bracket.receiveShadow = true;
        fanGroup.add(bracket);

        const strut = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.18, 0.28), bracketMaterial);
        strut.position.set(-0.36, -0.22, 0.0);
        strut.castShadow = true;
        strut.receiveShadow = true;
        fanGroup.add(strut);

        const housingMaterial = new THREE.MeshStandardMaterial({
          color: 0x445d89,
          metalness: 0.45,
          roughness: 0.28,
          emissive: 0x1b2744,
          emissiveIntensity: 0.55,
        });
        const housing = new THREE.Mesh(new THREE.CylinderGeometry(0.36, 0.36, 0.22, 48), housingMaterial);
        housing.rotation.z = Math.PI / 2;
        housing.position.set(0.1, 0, 0);
        housing.castShadow = true;
        housing.receiveShadow = true;
        fanGroup.add(housing);
        addHoverInfo(
          housing,
          'Cooling fan mount — 20 mm fan keeps the hook actuator cool during long runs.',
        );

        const hub = new THREE.Mesh(
          new THREE.CylinderGeometry(0.09, 0.09, 0.22, 24),
          new THREE.MeshStandardMaterial({
            color: 0xf5f9ff,
            emissive: 0x7fa6ff,
            emissiveIntensity: 0.45,
            metalness: 0.65,
            roughness: 0.18,
          }),
        );
        hub.rotation.z = Math.PI / 2;
        hub.position.set(0.1, 0, 0);
        hub.castShadow = true;
        fanGroup.add(hub);

        const bladesGroup = new THREE.Group();
        bladesGroup.position.set(0.2, 0, 0);
        const bladeMaterial = new THREE.MeshStandardMaterial({
          color: 0xe4ecff,
          emissive: 0x6f8cff,
          emissiveIntensity: 0.4,
          metalness: 0.32,
          roughness: 0.36,
          side: THREE.DoubleSide,
        });
        const bladeGeometry = new THREE.BoxGeometry(0.02, 0.54, 0.16);
        for (let index = 0; index < 3; index += 1) {
          const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
          blade.rotation.x = (Math.PI / 3) * index;
          blade.castShadow = true;
          bladesGroup.add(blade);
        }
        fanGroup.add(bladesGroup);

        const guardMaterial = new THREE.MeshStandardMaterial({
          color: 0xaec4ff,
          emissive: 0x3246a1,
          emissiveIntensity: 0.4,
          transparent: true,
          opacity: 0.65,
          side: THREE.DoubleSide,
        });
        const guard = new THREE.Mesh(new THREE.TorusGeometry(0.34, 0.01, 16, 64), guardMaterial);
        guard.rotation.z = Math.PI / 2;
        guard.position.set(0.2, 0, 0);
        fanGroup.add(guard);

        const fanGlow = new THREE.PointLight(0x9ec4ff, 0.8, 1.8);
        fanGlow.position.set(0.24, 0.1, 0);
        fanGroup.add(fanGlow);

        const fanLabel = buildLabel('Cooling Fan Mount', '#d7e5ff');
        fanLabel.position.set(0.0, 0.95, 0);
        fanLabel.scale.multiplyScalar(0.42);
        fanGroup.add(fanLabel);

        group.add(fanGroup);

        const spoolMaterial = new THREE.MeshStandardMaterial({
          color: 0xd1d5ff,
          metalness: 0.1,
          roughness: 0.6,
        });
        const spool = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 2.8, 32), spoolMaterial);
        spool.position.set(-2.4, 2.1, -1.6);
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        group.add(spool);
        spoolControllers.push({
          mesh: spool,
          axis: 'x',
          idleSpeed: 0,
          activeSpeed: 1.15,
          linkedToExtrusion: true,
          damping: 6.5,
          currentSpeed: 0,
        });
        const spoolGuide = new THREE.Object3D();
        spoolGuide.position.set(0, 0.6, 0);
        spool.add(spoolGuide);
        spool.userData.guide = spoolGuide;
        addHoverInfo(
          spool,
          'Yarn management module: active tensioning keeps stitches uniform throughout runs.',
        );

        const sensorAssembly = new THREE.Group();
        sensorAssembly.position.set(-1.1, 1.9, -1.9);

        const armMaterial = new THREE.MeshStandardMaterial({
          color: 0x7b8bff,
          metalness: 0.25,
          roughness: 0.35,
          emissive: 0x1c224d,
        });
        const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.4, 24), armMaterial);
        arm.rotation.z = Math.PI / 2.6;
        arm.position.set(0.2, 0.1, 0);
        arm.castShadow = true;
        sensorAssembly.add(arm);

        const hinge = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, 0.32, 24),
          new THREE.MeshStandardMaterial({
            color: 0x303756,
            metalness: 0.5,
            roughness: 0.2,
          }),
        );
        hinge.rotation.z = Math.PI / 2;
        hinge.position.set(-0.4, -0.05, 0);
        hinge.castShadow = true;
        sensorAssembly.add(hinge);

        const sensorHousing = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.35, 0.6),
          new THREE.MeshStandardMaterial({
            color: 0xffd59d,
            metalness: 0.2,
            roughness: 0.25,
            emissive: 0x3a260a,
          }),
        );
        sensorHousing.position.set(0.6, 0.18, 0);
        sensorHousing.castShadow = true;
        sensorAssembly.add(sensorHousing);
        addHoverInfo(
          sensorHousing,
          'Hall-effect tension sensor: monitors deflection in the yarn path for feedback control.',
        );

        const sensorIndicator = new THREE.PointLight(0xffc98a, 1.4, 3.5);
        sensorIndicator.position.set(0.6, 0.3, 0);
        sensorAssembly.add(sensorIndicator);

        const sensorGuide = new THREE.Object3D();
        sensorGuide.position.set(0.6, 0.24, 0);
        sensorAssembly.add(sensorGuide);
        sensorAssembly.userData.guide = sensorGuide;

        const sensorLabel = buildLabel('Hall-Effect Sensor', '#ffd59d');
        sensorLabel.position.set(0.6, 0.9, 0);
        sensorLabel.scale.multiplyScalar(0.65);
        sensorAssembly.add(sensorLabel);

        group.add(sensorAssembly);

        group.updateWorldMatrix(true, true);

        const spoolPoint = new THREE.Vector3();
        spool.userData.guide.getWorldPosition(spoolPoint);
        const tensionEntryPoint = new THREE.Vector3();
        tensionAssembly.userData.guideEntry.getWorldPosition(tensionEntryPoint);
        const tensionExitPoint = new THREE.Vector3();
        tensionAssembly.userData.guideExit.getWorldPosition(tensionExitPoint);
        const sensorPoint = new THREE.Vector3();
        sensorAssembly.userData.guide.getWorldPosition(sensorPoint);
        const effectorPoint = new THREE.Vector3();
        effector.userData.guide.getWorldPosition(effectorPoint);

        const ptfeCurve = new THREE.CatmullRomCurve3([
          spoolPoint,
          spoolPoint.clone().add(new THREE.Vector3(0.45, 0.12, 0.18)),
          tensionEntryPoint,
          tensionExitPoint,
          sensorPoint.clone().add(new THREE.Vector3(0.18, 0.15, 0.04)),
          sensorPoint,
          effectorPoint.clone().add(new THREE.Vector3(-0.22, 0.1, -0.12)),
          effectorPoint,
        ]);

        const ptfeMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xbdf6ff,
          metalness: 0.05,
          roughness: 0.08,
          transparent: true,
          opacity: 0.5,
          transmission: 0.9,
          thickness: 0.45,
        });
        const ptfeTube = new THREE.Mesh(
          new THREE.TubeGeometry(ptfeCurve, 160, 0.04, 16, false),
          ptfeMaterial,
        );
        ptfeTube.castShadow = false;
        ptfeTube.receiveShadow = false;
        group.add(ptfeTube);
        addHoverInfo(
          ptfeTube,
          'PTFE guide tube — routes yarn from the spool through the sensor and into the hook.',
          { passthrough: true },
        );
        safeAccessHighlights.push({
          material: ptfeMaterial,
          baseOpacity: 0.5,
          opacityAmplitude: 0.12,
          speed: 1.4,
          phaseOffset: 1.1,
        });

        const yarnTextureCanvas = document.createElement('canvas');
        yarnTextureCanvas.width = 256;
        yarnTextureCanvas.height = 16;
        const yarnContext = yarnTextureCanvas.getContext('2d');
        if (yarnContext) {
          yarnContext.fillStyle = '#55261a';
          yarnContext.fillRect(0, 0, yarnTextureCanvas.width, yarnTextureCanvas.height);
          const stripeWidth = yarnTextureCanvas.width / 16;
          for (let index = 0; index < 16; index += 1) {
            const offset = index * stripeWidth;
            const gradient = yarnContext.createLinearGradient(offset, 0, offset + stripeWidth, 0);
            gradient.addColorStop(0.0, '#ffcf94');
            gradient.addColorStop(0.5, '#ff9f4a');
            gradient.addColorStop(1.0, '#ffcf94');
            yarnContext.fillStyle = gradient;
            yarnContext.fillRect(offset, 0, stripeWidth, yarnTextureCanvas.height);
          }
        }
        const yarnTexture = new THREE.CanvasTexture(yarnTextureCanvas);
        yarnTexture.wrapS = THREE.RepeatWrapping;
        yarnTexture.wrapT = THREE.ClampToEdgeWrapping;
        yarnTexture.repeat.set(8, 1);
        yarnTexture.anisotropy = 4;
        yarnTexture.needsUpdate = true;
        const yarnMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xffffff,
          emissive: 0xffb173,
          emissiveIntensity: 0.45,
          metalness: 0.12,
          roughness: 0.3,
          transparent: true,
          opacity: 0.85,
          transmission: 0.3,
          thickness: 0.18,
          map: yarnTexture,
          side: THREE.DoubleSide,
        });
        const yarnTube = new THREE.Mesh(
          new THREE.TubeGeometry(ptfeCurve, 200, 0.02, 24, false),
          yarnMaterial,
        );
        yarnTube.castShadow = false;
        yarnTube.receiveShadow = false;
        group.add(yarnTube);
        addHoverInfo(
          yarnTube,
          'Animated yarn flow — watch feed pulses as the crochet cell draws fiber.',
          { passthrough: true },
        );
        yarnFlowControllers.push({
          texture: yarnTexture,
          speed: 0.35,
          material: yarnMaterial,
          restIntensity: 0.45,
          activeIntensity: 0.9,
          currentIntensity: 0.45,
        });

        const yarnPulseGroup = new THREE.Group();
        yarnPulseGroup.name = 'yarn-flow-pulses';
        group.add(yarnPulseGroup);
        addHoverInfo(
          yarnPulseGroup,
          'Glowing yarn pulses — trace fiber flow along the PTFE guide during planner playback.',
          { passthrough: true },
        );

        const pulseGeometry = new THREE.SphereGeometry(0.06, 16, 16);
        const pulseCount = 3;
        for (let index = 0; index < pulseCount; index += 1) {
          const pulseMaterial = new THREE.MeshStandardMaterial({
            color: 0xffd6a3,
            emissive: 0xff8c2f,
            emissiveIntensity: 0.18,
            metalness: 0.18,
            roughness: 0.32,
            transparent: true,
            opacity: 0.35,
          });
          const pulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
          pulse.castShadow = false;
          pulse.receiveShadow = false;
          yarnPulseGroup.add(pulse);
          yarnPulseControllers.push({
            mesh: pulse,
            material: pulseMaterial,
            curve: ptfeCurve,
            offset: index / pulseCount,
            activeSpeed: 0.18 + index * 0.015,
            idleSpeed: 0.045 + index * 0.01,
            restIntensity: 0.18,
            activeIntensity: 0.85,
            restOpacity: 0.25,
            activeOpacity: 0.9,
            currentIntensity: 0.18,
            point: new THREE.Vector3(),
          });
        }

        const yarnBeadGroup = new THREE.Group();
        yarnBeadGroup.name = 'yarn-flow-beads';
        group.add(yarnBeadGroup);
        addHoverInfo(
          yarnBeadGroup,
          'Glowing bead queue — ignites when yarn feed steps run to spotlight flow direction.',
          { passthrough: true },
        );

        const beadGeometry = new THREE.SphereGeometry(0.045, 18, 18);
        const beadCount = 3;
        const baseSpeed = 0.36;
        const speedStep = 0.045;
        for (let index = 0; index < beadCount; index += 1) {
          const beadMaterial = new THREE.MeshStandardMaterial({
            color: 0xfff7d6,
            emissive: 0xffc763,
            emissiveIntensity: 0,
            metalness: 0.22,
            roughness: 0.28,
            transparent: true,
            opacity: 0,
            depthWrite: false,
          });
          const bead = new THREE.Mesh(beadGeometry, beadMaterial);
          bead.castShadow = false;
          bead.receiveShadow = false;
          yarnBeadGroup.add(bead);
          yarnBeadControllers.push({
            mesh: bead,
            material: beadMaterial,
            curve: ptfeCurve,
            travel: index / beadCount,
            activeSpeed: baseSpeed + index * speedStep,
            idleSpeed: 0.06,
            restIntensity: 0,
            activeIntensity: 1.4,
            restOpacity: 0,
            activeOpacity: 0.95,
            currentIntensity: 0,
            currentOpacity: 0,
            point: new THREE.Vector3(),
          });
        }

        const displayLabel = buildLabel('v1c – Crochet Robot', '#8ab4ff');
        displayLabel.position.set(0, 4.3, 0);
        group.add(displayLabel);

        const bedLabel = buildLabel('Workpiece Support Bed', '#b6f0ff');
        bedLabel.position.set(0, 1.6, -1.6);
        bedLabel.scale.multiplyScalar(0.85);
        group.add(bedLabel);

        const safetyShield = createSafetyShield();
        group.add(safetyShield);

        const safeAccessPath = createSafeAccessPath();
        group.add(safeAccessPath);

        function createEmergencyStop() {
          const emergencyGroup = new THREE.Group();
          emergencyGroup.position.set(2.2, 0.6, 1.35);

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.55, 0.55, 0.16, 48),
            new THREE.MeshStandardMaterial({
              color: 0x15161f,
              metalness: 0.5,
              roughness: 0.2,
            }),
          );
          base.castShadow = true;
          emergencyGroup.add(base);

          const button = new THREE.Mesh(
            new THREE.CylinderGeometry(0.45, 0.5, 0.28, 48),
            new THREE.MeshStandardMaterial({
              color: 0xff4d4f,
              emissive: 0x5f0608,
              emissiveIntensity: 0.8,
              metalness: 0.2,
              roughness: 0.35,
            }),
          );
          button.position.y = 0.21;
          button.castShadow = true;
          emergencyGroup.add(button);
          addHoverInfo(
            button,
            'Emergency stop switch — instantly cuts power to the v1c motion system.',
          );

          const halo = new THREE.Mesh(
            new THREE.TorusGeometry(0.52, 0.05, 16, 64),
            new THREE.MeshStandardMaterial({
              color: 0xff8083,
              emissive: 0x701010,
              emissiveIntensity: 0.7,
              metalness: 0.35,
              roughness: 0.15,
              transparent: true,
              opacity: 0.85,
            }),
          );
          halo.rotation.x = Math.PI / 2;
          halo.position.y = 0.08;
          emergencyGroup.add(halo);

          const indicator = new THREE.PointLight(0xff494c, 2.3, 4.2);
          indicator.position.y = 0.45;
          emergencyGroup.add(indicator);

          const label = buildLabel('Safety Interlock', '#ffb3b3');
          label.position.set(0, 0.95, 0);
          emergencyGroup.add(label);

          return emergencyGroup;
        }

        function createEndStop(position, axisLabel) {
          const group = new THREE.Group();
          group.position.copy(position);
          group.name = `end-stop-${axisLabel.toLowerCase()}`;

          const housing = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.5, 0.35),
            new THREE.MeshStandardMaterial({
              color: 0xffc285,
              metalness: 0.4,
              roughness: 0.25,
              emissive: 0x462501,
              emissiveIntensity: 0.55,
            }),
          );
          housing.castShadow = true;
          group.add(housing);
          addHoverInfo(
            housing,
            `${axisLabel}-axis end stop — trips firmware limits before overtravel can occur.`,
          );

          const indicatorMaterial = new THREE.MeshStandardMaterial({
            color: 0xfff1c6,
            emissive: 0xffb347,
            emissiveIntensity: 0.85,
            metalness: 0.25,
            roughness: 0.3,
            transparent: true,
            opacity: 0.92,
          });
          const indicator = new THREE.Mesh(
            new THREE.SphereGeometry(0.18, 24, 24),
            indicatorMaterial,
          );
          indicator.position.set(0, 0.44, 0);
          indicator.castShadow = true;
          group.add(indicator);

          const axisPhaseOffset =
            axisLabel === 'X' ? 0 : axisLabel === 'Y' ? Math.PI * 0.4 : Math.PI * 0.8;
          safeAccessHighlights.push({
            tag: `end-stop-${axisLabel.toLowerCase()}-indicator`,
            material: indicatorMaterial,
            baseIntensity: 0.85,
            amplitude: 0.55,
            speed: 3.1,
            phaseOffset: axisPhaseOffset,
            baseOpacity: 0.92,
            opacityAmplitude: 0.06,
          });

          const haloMaterial = new THREE.MeshBasicMaterial({
            color: 0xffe6aa,
            transparent: true,
            opacity: 0.52,
            side: THREE.DoubleSide,
            depthWrite: false,
          });
          const halo = new THREE.Mesh(new THREE.RingGeometry(0.26, 0.36, 40), haloMaterial);
          halo.rotation.x = Math.PI / 2;
          halo.position.set(0, 0.14, 0);
          halo.renderOrder = 6;
          group.add(halo);
          safeAccessHighlights.push({
            tag: `end-stop-${axisLabel.toLowerCase()}-halo`,
            material: haloMaterial,
            baseOpacity: 0.52,
            opacityAmplitude: 0.28,
            speed: 2.6,
            phaseOffset: axisPhaseOffset + 0.9,
          });

          const glowLight = new THREE.PointLight(0xffdd9c, 1.6, 3.4);
          glowLight.position.set(0, 0.6, 0);
          group.add(glowLight);

          const glowStem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.3, 16),
            new THREE.MeshStandardMaterial({
              color: 0xffd492,
              emissive: 0x7a3f02,
              emissiveIntensity: 0.55,
              metalness: 0.3,
              roughness: 0.35,
            }),
          );
          glowStem.position.set(0, 0.28, 0);
          glowStem.castShadow = true;
          group.add(glowStem);

          return group;
        }

        const emergencyStop = createEmergencyStop();
        group.add(emergencyStop);

        const endStops = [
          createEndStop(new THREE.Vector3(3.1, 2.1, 1.1), 'X'),
          createEndStop(new THREE.Vector3(-2.2, 3.6, -2.6), 'Y'),
          createEndStop(new THREE.Vector3(-1.0, 0.95, -1.4), 'Z'),
        ];
        endStops.forEach((stop) => group.add(stop));

        return group;
      }

      function createPedestalCluster(options) {
        const {
          name,
          roadmap,
          hoverText,
          position,
          accentColor,
          hoverColor,
          selectionScale = 0.54,
          selectionHeight = 0.24,
          buildDisplay,
          displayOffset = 0,
        } = options;

        const group = new THREE.Group();
        group.position.copy(position);
        group.userData.name = name;
        group.userData.roadmap = roadmap;
        group.userData.selectionScale = selectionScale;
        group.userData.selectionHeight = selectionHeight;

        const base = new THREE.Mesh(
          new THREE.CylinderGeometry(1.5, 1.8, 0.4, 48),
          new THREE.MeshStandardMaterial({
            color: 0x191c2a,
            roughness: 0.8,
            metalness: 0.15,
          }),
        );
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        const column = new THREE.Mesh(
          new THREE.CylinderGeometry(0.55, 0.75, 1.3, 48),
          new THREE.MeshStandardMaterial({
            color: accentColor,
            emissive: new THREE.Color(accentColor).multiplyScalar(0.35),
            metalness: 0.25,
            roughness: 0.45,
          }),
        );
        column.position.y = 0.85;
        column.castShadow = true;
        group.add(column);

        const platform = new THREE.Mesh(
          new THREE.CylinderGeometry(1.1, 1.1, 0.22, 48),
          new THREE.MeshStandardMaterial({
            color: hoverColor,
            emissive: new THREE.Color(hoverColor).multiplyScalar(0.25),
            metalness: 0.35,
            roughness: 0.3,
          }),
        );
        platform.position.y = 1.48;
        platform.castShadow = true;
        platform.name = `${name.toLowerCase().replace(/\s+/g, '-')}-pedestal`;
        group.add(platform);
        addHoverInfo(platform, hoverText);

        const glow = new THREE.PointLight(accentColor, 1.2, 8.0);
        glow.position.y = 1.7;
        group.add(glow);

        const halo = new THREE.Mesh(
          new THREE.TorusGeometry(1.05, 0.04, 16, 96),
          new THREE.MeshStandardMaterial({
            color: accentColor,
            emissive: new THREE.Color(accentColor).multiplyScalar(0.5),
            emissiveIntensity: 0.6,
            transparent: true,
            opacity: 0.8,
          }),
        );
        halo.rotation.x = Math.PI / 2;
        halo.position.y = 1.62;
        group.add(halo);

        const label = buildLabel(name, '#f5f9ff');
        label.position.set(0, 2.25, 0);
        label.scale.multiplyScalar(0.6);
        group.add(label);

        if (typeof buildDisplay === 'function') {
          const display = buildDisplay();
          if (display) {
            const platformTop = 1.48 + 0.11;
            display.position.y += platformTop + displayOffset;
            group.add(display);
          }
        }

        return group;
      }

      function createTensionLabDisplay() {
        const group = new THREE.Group();
        group.name = 'tension-lab-display';

        const bench = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.12, 1.1),
          new THREE.MeshStandardMaterial({
            color: 0x1a2f3a,
            metalness: 0.35,
            roughness: 0.4,
          }),
        );
        bench.position.y = 0.18;
        bench.castShadow = true;
        bench.receiveShadow = true;
        group.add(bench);
        addHoverInfo(
          bench,
          'Calibration bench — stages load cells and fixture rails for yarn testing.',
        );

        const rail = new THREE.Mesh(
          new THREE.BoxGeometry(1.6, 0.08, 0.14),
          new THREE.MeshStandardMaterial({
            color: 0x0f1f28,
            metalness: 0.3,
            roughness: 0.35,
          }),
        );
        rail.position.set(-0.2, 0.32, -0.04);
        rail.castShadow = true;
        group.add(rail);

        const spoolRig = new THREE.Group();
        spoolRig.position.set(0.38, 0.36, 0.02);

        const spoolCore = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.92, 24),
          new THREE.MeshStandardMaterial({
            color: 0x324451,
            metalness: 0.55,
            roughness: 0.28,
          }),
        );
        spoolCore.rotation.z = Math.PI / 2;
        spoolCore.castShadow = true;
        spoolRig.add(spoolCore);

        const spool = new THREE.Mesh(
          new THREE.CylinderGeometry(0.42, 0.42, 0.8, 48),
          new THREE.MeshStandardMaterial({
            color: 0xffe3a1,
            emissive: 0x94763a,
            emissiveIntensity: 0.35,
            roughness: 0.45,
          }),
        );
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        spoolRig.add(spool);
        spoolControllers.push({
          mesh: spool,
          axis: 'x',
          idleSpeed: 0.35,
          activeSpeed: 0.65,
          linkedToExtrusion: false,
        });
        addHoverInfo(
          spool,
          'Tension spool rig — calibrates hall-effect sensors before they reach production cells.',
        );

        group.add(spoolRig);

        const carriage = new THREE.Mesh(
          new THREE.BoxGeometry(0.34, 0.26, 0.86),
          new THREE.MeshStandardMaterial({
            color: 0x1c4f5c,
            metalness: 0.3,
            roughness: 0.32,
          }),
        );
        carriage.position.set(-0.62, 0.42, -0.05);
        carriage.castShadow = true;
        group.add(carriage);
        addHoverInfo(
          carriage,
          'Sensor carriage — slides along the rail to align load cells with the yarn path.',
        );

        const sensorTower = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.62, 32),
          new THREE.MeshStandardMaterial({
            color: 0x7df0ff,
            emissive: 0x1b6d7d,
            emissiveIntensity: 0.6,
            metalness: 0.4,
            roughness: 0.25,
          }),
        );
        sensorTower.position.set(-0.62, 0.74, 0.24);
        sensorTower.castShadow = true;
        group.add(sensorTower);

        const gaugeDisplay = new THREE.Mesh(
          new THREE.BoxGeometry(0.34, 0.24, 0.18),
          new THREE.MeshStandardMaterial({
            color: 0x0d1c28,
            emissive: 0x163b4d,
            emissiveIntensity: 0.55,
            metalness: 0.28,
            roughness: 0.32,
          }),
        );
        gaugeDisplay.position.set(-0.62, 0.82, 0.52);
        gaugeDisplay.castShadow = true;
        group.add(gaugeDisplay);
        addHoverInfo(
          gaugeDisplay,
          'Live tension telemetry — maps hall sensor readings to grams for planner feedback.',
        );

        const indicator = new THREE.PointLight(0x7df0ff, 1.4, 4.0);
        indicator.position.set(-0.62, 1.18, 0.52);
        group.add(indicator);

        const servoBracket = new THREE.Mesh(
          new THREE.BoxGeometry(0.22, 0.18, 0.46),
          new THREE.MeshStandardMaterial({
            color: 0x243640,
            metalness: 0.42,
            roughness: 0.32,
            emissive: 0x0f1d24,
            emissiveIntensity: 0.35,
          }),
        );
        servoBracket.position.set(0.84, 0.32, -0.28);
        servoBracket.castShadow = true;
        group.add(servoBracket);

        const servoBodyMaterial = new THREE.MeshStandardMaterial({
          color: 0x1a2f3a,
          metalness: 0.5,
          roughness: 0.3,
          emissive: 0x0b1a22,
          emissiveIntensity: 0.45,
        });
        const servoBody = new THREE.Mesh(
          new THREE.BoxGeometry(0.32, 0.26, 0.26),
          servoBodyMaterial,
        );
        servoBody.position.set(0.92, 0.44, -0.28);
        servoBody.castShadow = true;
        group.add(servoBody);
        addHoverInfo(
          servoBody,
          'Micro-servo tension adjuster — trims yarn feed with programmable pulls.',
        );
        safeAccessHighlights.push({
          material: servoBodyMaterial,
          baseIntensity: 0.45,
          amplitude: 0.22,
          speed: 2.1,
          phaseOffset: 0.6,
        });

        const servoPivot = new THREE.Group();
        servoPivot.position.set(0.92, 0.5, -0.28);
        group.add(servoPivot);

        const servoHornMaterial = new THREE.MeshStandardMaterial({
          color: 0xfff1c6,
          metalness: 0.48,
          roughness: 0.22,
          emissive: 0x7a5b1f,
          emissiveIntensity: 0.55,
        });
        const servoHorn = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 0.24, 24),
          servoHornMaterial,
        );
        servoHorn.rotation.z = Math.PI / 2;
        servoHorn.position.set(0.12, 0, 0);
        servoHorn.castShadow = true;
        servoPivot.add(servoHorn);
        safeAccessHighlights.push({
          material: servoHornMaterial,
          baseIntensity: 0.55,
          amplitude: 0.25,
          speed: 2.4,
          phaseOffset: 0.8,
        });

        const linkageDirection = new THREE.Vector3(-0.24, 0, 0.2);
        const linkageLength = linkageDirection.length();
        const linkageMaterial = new THREE.MeshStandardMaterial({
          color: 0xc7d6ff,
          metalness: 0.55,
          roughness: 0.28,
          emissive: 0x2c3d73,
          emissiveIntensity: 0.45,
        });
        const linkage = new THREE.Mesh(
          new THREE.CylinderGeometry(0.018, 0.018, linkageLength, 16),
          linkageMaterial,
        );
        const linkageQuaternion = new THREE.Quaternion().setFromUnitVectors(
          new THREE.Vector3(0, 1, 0),
          linkageDirection.clone().normalize(),
        );
        linkage.quaternion.copy(linkageQuaternion);
        linkage.position.copy(linkageDirection.clone().multiplyScalar(0.5));
        linkage.castShadow = true;
        servoPivot.add(linkage);

        const servoRestAngle = THREE.MathUtils.degToRad(-10);
        const servoActiveAngle = THREE.MathUtils.degToRad(12);
        servoPivot.rotation.y = servoRestAngle;
        servoActuatorControllers.push({
          pivot: servoPivot,
          restAngle: servoRestAngle,
          activeAngle: servoActiveAngle,
          damping: 6.5,
        });

        const servoIndicatorMaterial = new THREE.MeshStandardMaterial({
          color: 0xfff4c9,
          emissive: 0xffb347,
          emissiveIntensity: 0.25,
          metalness: 0.25,
          roughness: 0.28,
          transparent: true,
          opacity: 0.35,
        });
        const servoIndicator = new THREE.Mesh(
          new THREE.SphereGeometry(0.06, 18, 18),
          servoIndicatorMaterial,
        );
        servoIndicator.position.set(0.86, 0.6, -0.42);
        servoIndicator.castShadow = true;
        group.add(servoIndicator);
        servoSignalControllers.push({
          material: servoIndicatorMaterial,
          restIntensity: 0.25,
          activeIntensity: 1.2,
          restOpacity: 0.35,
          activeOpacity: 0.9,
          damping: 5.5,
        });

        const servoLight = new THREE.PointLight(0xffd89c, 0.9, 3.2);
        servoLight.position.set(0.82, 0.92, -0.28);
        group.add(servoLight);

        const servoLabel = buildLabel('Servo Tensioner Prototype', '#ccfff0');
        servoLabel.position.set(0.92, 0.96, -0.32);
        servoLabel.scale.multiplyScalar(0.34);
        group.add(servoLabel);

        return group;
      }

      function createMaterialPrepDisplay() {
        const group = new THREE.Group();
        group.name = 'material-prep-display';

        const table = new THREE.Mesh(
          new THREE.BoxGeometry(2.1, 0.14, 1.2),
          new THREE.MeshStandardMaterial({
            color: 0x1f2d24,
            metalness: 0.32,
            roughness: 0.48,
          }),
        );
        table.position.y = 0.18;
        table.castShadow = true;
        table.receiveShadow = true;
        group.add(table);
        addHoverInfo(
          table,
          'Material prep bench — stages yarn cones and QA tools before automation.',
        );

        const legGeometry = new THREE.BoxGeometry(0.16, 0.42, 0.16);
        const legMaterial = new THREE.MeshStandardMaterial({
          color: 0x16251b,
          metalness: 0.28,
          roughness: 0.42,
        });
        [
          [-0.92, 0.0, -0.5],
          [0.92, 0.0, -0.5],
          [-0.92, 0.0, 0.5],
          [0.92, 0.0, 0.5],
        ].forEach(([x, y, z]) => {
          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.position.set(x, y, z);
          leg.castShadow = true;
          group.add(leg);
        });

        const coneTree = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 0.92, 24),
          new THREE.MeshStandardMaterial({
            color: 0x2a3f30,
            metalness: 0.33,
            roughness: 0.36,
            emissive: 0x102216,
            emissiveIntensity: 0.4,
          }),
        );
        coneTree.position.set(-0.62, 0.64, 0.1);
        coneTree.castShadow = true;
        group.add(coneTree);

        const coneColors = [0xffe1a1, 0xffc4d0, 0xb8ecff];
        coneColors.forEach((color, index) => {
          const cone = new THREE.Mesh(
            new THREE.CylinderGeometry(0.34, 0.22, 0.46, 32),
            new THREE.MeshStandardMaterial({
              color,
              emissive: new THREE.Color(color).multiplyScalar(0.2),
              emissiveIntensity: 0.35,
              roughness: 0.38,
            }),
          );
          cone.rotation.z = Math.PI / 2;
          cone.position.set(-0.62, 0.48 + index * 0.24, 0.1);
          cone.castShadow = true;
          group.add(cone);
        });
        addHoverInfo(
          coneTree,
          'Cone tree — organizes dyed yarn sets with quick-grab color tags.',
        );

        const prepBins = new THREE.Group();
        prepBins.position.set(0.58, 0.36, -0.32);
        group.add(prepBins);

        const binGeometry = new THREE.BoxGeometry(0.46, 0.26, 0.46);
        const binColors = [0x325444, 0x3e6150, 0x274236];
        binColors.forEach((color, index) => {
          const bin = new THREE.Mesh(
            binGeometry,
            new THREE.MeshStandardMaterial({
              color,
              metalness: 0.18,
              roughness: 0.4,
              emissive: new THREE.Color(color).multiplyScalar(0.18),
            }),
          );
          bin.position.set(index * 0.52 - 0.52, 0, 0);
          bin.castShadow = true;
          prepBins.add(bin);
        });
        addHoverInfo(
          prepBins,
          'Prep bins — stage bobbins, winding tools, and pre-measured skeins.',
        );

        const scaleBase = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.08, 0.34),
          new THREE.MeshStandardMaterial({
            color: 0x1f1d2d,
            metalness: 0.4,
            roughness: 0.32,
          }),
        );
        scaleBase.position.set(0.38, 0.32, 0.42);
        scaleBase.castShadow = true;
        group.add(scaleBase);

        const scaleDeck = new THREE.Mesh(
          new THREE.BoxGeometry(0.46, 0.04, 0.3),
          new THREE.MeshStandardMaterial({
            color: 0x6b76ff,
            emissive: 0x2c3080,
            emissiveIntensity: 0.6,
            roughness: 0.28,
          }),
        );
        scaleDeck.position.set(0.38, 0.38, 0.42);
        scaleDeck.castShadow = true;
        group.add(scaleDeck);
        addHoverInfo(
          scaleDeck,
          'Inspection scale — verifies yarn weight and cone swaps before runs.',
        );

        const checklist = new THREE.Mesh(
          new THREE.PlaneGeometry(0.42, 0.58),
          new THREE.MeshStandardMaterial({
            color: 0xc5f1d6,
            emissive: 0x4a8d65,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
          }),
        );
        checklist.position.set(0.1, 0.72, -0.46);
        checklist.rotation.y = -Math.PI / 6;
        checklist.castShadow = true;
        group.add(checklist);
        addHoverInfo(
          checklist,
          'Run cards — log dye lots, spool counts, and prep checks for traceability.',
        );

        const prepLabel = buildLabel('Prep & QA', '#d4ffe5');
        prepLabel.position.set(0.0, 1.0, 0.0);
        prepLabel.scale.multiplyScalar(0.4);
        group.add(prepLabel);

        const workLight = new THREE.PointLight(0x82ffb2, 1.1, 4.8);
        workLight.position.set(-0.6, 1.4, 0.1);
        group.add(workLight);

        return group;
      }

      function createPatternStudioDisplay() {
        const group = new THREE.Group();
        group.name = 'pattern-studio-display';

        const desk = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.12, 1.1),
          new THREE.MeshStandardMaterial({
            color: 0x2d1f24,
            metalness: 0.38,
            roughness: 0.45,
          }),
        );
        desk.position.y = 0.2;
        desk.castShadow = true;
        desk.receiveShadow = true;
        group.add(desk);

        const legGeometry = new THREE.BoxGeometry(0.12, 0.42, 0.12);
        const legMaterial = new THREE.MeshStandardMaterial({
          color: 0x1b1318,
          metalness: 0.35,
          roughness: 0.4,
        });
        [
          [-0.78, 0.01, -0.46],
          [0.78, 0.01, -0.46],
          [-0.78, 0.01, 0.46],
          [0.78, 0.01, 0.46],
        ].forEach(([x, y, z]) => {
          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.position.set(x, y, z);
          leg.castShadow = true;
          group.add(leg);
        });

        const monitorGeometry = new THREE.BoxGeometry(0.08, 0.64, 0.92);
        const monitorMaterial = new THREE.MeshStandardMaterial({
          color: 0x111527,
          emissive: 0x3d4eff,
          emissiveIntensity: 0.68,
          metalness: 0.25,
          roughness: 0.24,
        });
        const leftMonitor = new THREE.Mesh(monitorGeometry, monitorMaterial);
        leftMonitor.position.set(-0.45, 0.6, -0.08);
        leftMonitor.rotation.y = 0.18;
        leftMonitor.castShadow = true;
        group.add(leftMonitor);
        addHoverInfo(
          leftMonitor,
          'Planner console — previews pattern_cli exports with motion overlays.',
        );

        const rightMonitor = leftMonitor.clone();
        rightMonitor.position.set(0.2, 0.6, -0.08);
        rightMonitor.rotation.y = -0.12;
        group.add(rightMonitor);

        const keyboard = new THREE.Mesh(
          new THREE.BoxGeometry(0.62, 0.05, 0.26),
          new THREE.MeshStandardMaterial({
            color: 0x37262d,
            metalness: 0.28,
            roughness: 0.45,
          }),
        );
        keyboard.position.set(-0.1, 0.28, 0.18);
        keyboard.castShadow = true;
        group.add(keyboard);

        const holoBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.36, 0.36, 0.04, 48),
          new THREE.MeshStandardMaterial({
            color: 0x3a2d52,
            metalness: 0.3,
            roughness: 0.35,
          }),
        );
        holoBase.position.set(0.58, 0.28, 0.3);
        holoBase.castShadow = true;
        group.add(holoBase);

        const holoEmitter = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.3, 0.5, 32, 1, true),
          new THREE.MeshStandardMaterial({
            color: 0x8c7dff,
            emissive: 0x4a3aff,
            emissiveIntensity: 0.7,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide,
          }),
        );
        holoEmitter.position.set(0.58, 0.58, 0.3);
        holoEmitter.castShadow = true;
        group.add(holoEmitter);
        addHoverInfo(
          holoEmitter,
          'Holographic planner table — replays pattern_cli --format planner exports for dry runs.',
        );

        const planGrid = new THREE.Mesh(
          new THREE.PlaneGeometry(0.72, 0.52),
          new THREE.MeshStandardMaterial({
            color: 0x90a4ff,
            emissive: 0x5367ff,
            emissiveIntensity: 0.75,
            transparent: true,
            opacity: 0.78,
            side: THREE.DoubleSide,
          }),
        );
        planGrid.position.set(0.58, 0.78, 0.3);
        planGrid.rotation.y = Math.PI / 6;
        group.add(planGrid);
        patternPreviewContainer = planGrid;

        applyPatternPlannerEvents(patternPlannerEvents, { resetOverlay: false });

        addHoverInfo(
          planGrid,
          'Planner hologram — loops a base chain row captured from pattern_cli --format planner.',
          { passthrough: true },
        );

        const holoLight = new THREE.PointLight(0x8c7dff, 1.3, 4.5);
        holoLight.position.set(0.58, 1.2, 0.3);
        group.add(holoLight);

        return group;
      }

      function createV1KResearchDisplay() {
        const group = new THREE.Group();
        group.name = 'v1k-research-display';

        const deck = new THREE.Mesh(
          new THREE.BoxGeometry(2.2, 0.14, 1.4),
          new THREE.MeshStandardMaterial({
            color: 0x1a1c2d,
            metalness: 0.32,
            roughness: 0.5,
          }),
        );
        deck.position.y = 0.2;
        deck.castShadow = true;
        deck.receiveShadow = true;
        group.add(deck);
        addHoverInfo(
          deck,
          'Research deck — stages knitting-bed prototypes for future automation trials.',
        );

        const railMaterial = new THREE.MeshStandardMaterial({
          color: 0x8ea3ff,
          emissive: 0x39477d,
          emissiveIntensity: 0.55,
          metalness: 0.42,
          roughness: 0.28,
        });
        const railGeometry = new THREE.BoxGeometry(0.14, 0.16, 1.26);
        [-0.55, 0.55].forEach((x) => {
          const rail = new THREE.Mesh(railGeometry, railMaterial);
          rail.position.set(x, 0.38, 0.0);
          rail.castShadow = true;
          group.add(rail);
        });

        const bed = new THREE.Mesh(
          new THREE.BoxGeometry(1.9, 0.08, 0.52),
          new THREE.MeshStandardMaterial({
            color: 0xe4e6ff,
            emissive: 0x4d5aff,
            emissiveIntensity: 0.28,
            metalness: 0.18,
            roughness: 0.24,
          }),
        );
        bed.position.set(0, 0.42, 0.0);
        bed.castShadow = true;
        group.add(bed);
        addHoverInfo(
          bed,
          'Needle bed prototype — validates carriage spacing for the knitting platform.',
        );

        const carriage = new THREE.Mesh(
          new THREE.BoxGeometry(0.54, 0.24, 0.74),
          new THREE.MeshStandardMaterial({
            color: 0xff9fb7,
            emissive: 0x6c2440,
            emissiveIntensity: 0.48,
            metalness: 0.3,
            roughness: 0.32,
          }),
        );
        carriage.position.set(0.18, 0.62, 0.0);
        carriage.castShadow = true;
        group.add(carriage);
        addHoverInfo(
          carriage,
          'Carriage sled — hosts interchangeable toolheads and yarn cutters for v1k.',
        );

        const needleGroup = new THREE.Group();
        needleGroup.position.set(0.18, 0.75, 0.0);
        const needleGeometry = new THREE.CylinderGeometry(0.018, 0.018, 0.46, 10);
        const needleMaterial = new THREE.MeshStandardMaterial({
          color: 0xf5f7ff,
          emissive: 0x9097ff,
          emissiveIntensity: 0.35,
          metalness: 0.4,
          roughness: 0.2,
        });
        [-0.24, 0, 0.24].forEach((offset) => {
          const needle = new THREE.Mesh(needleGeometry, needleMaterial);
          needle.rotation.x = Math.PI / 2;
          needle.position.set(offset, 0, 0.0);
          needle.castShadow = true;
          needleGroup.add(needle);
        });
        group.add(needleGroup);

        const consoleBase = new THREE.Mesh(
          new THREE.BoxGeometry(0.9, 0.12, 0.54),
          new THREE.MeshStandardMaterial({
            color: 0x26273d,
            metalness: 0.36,
            roughness: 0.38,
          }),
        );
        consoleBase.position.set(-0.82, 0.28, 0.46);
        consoleBase.castShadow = true;
        group.add(consoleBase);

        const consoleScreen = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.48, 0.58),
          new THREE.MeshStandardMaterial({
            color: 0x101425,
            emissive: 0x3a7bff,
            emissiveIntensity: 0.65,
            metalness: 0.28,
            roughness: 0.28,
          }),
        );
        consoleScreen.position.set(-1.16, 0.66, 0.46);
        consoleScreen.rotation.y = Math.PI / 3.5;
        consoleScreen.castShadow = true;
        group.add(consoleScreen);
        addHoverInfo(
          consoleScreen,
          'Control console — compares crochet motion plans with upcoming knitting paths.',
        );

        const spoolTower = new THREE.Mesh(
          new THREE.CylinderGeometry(0.16, 0.16, 0.9, 24),
          new THREE.MeshStandardMaterial({
            color: 0x34374f,
            metalness: 0.42,
            roughness: 0.34,
          }),
        );
        spoolTower.position.set(0.98, 0.62, 0.52);
        spoolTower.castShadow = true;
        group.add(spoolTower);

        const spool = new THREE.Mesh(
          new THREE.CylinderGeometry(0.42, 0.32, 0.72, 40),
          new THREE.MeshStandardMaterial({
            color: 0xffe6a8,
            emissive: 0x947f3d,
            emissiveIntensity: 0.32,
            roughness: 0.4,
          }),
        );
        spool.rotation.z = Math.PI / 2;
        spool.position.set(0.98, 0.62, 0.52);
        spool.castShadow = true;
        group.add(spool);
        spoolControllers.push({
          mesh: spool,
          axis: 'x',
          idleSpeed: 0.28,
          activeSpeed: 0.45,
          linkedToExtrusion: false,
        });
        addHoverInfo(
          spool,
          'Yarn staging spindle — feeds prototype fibers into the knitting carriage.',
        );

        const telemetryPod = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.24, 0.46, 32),
          new THREE.MeshStandardMaterial({
            color: 0x8cf0ff,
            emissive: 0x2e8896,
            emissiveIntensity: 0.75,
            transparent: true,
            opacity: 0.82,
          }),
        );
        telemetryPod.position.set(-0.15, 0.58, -0.58);
        telemetryPod.castShadow = true;
        group.add(telemetryPod);
        addHoverInfo(
          telemetryPod,
          'Telemetry pod — logs tension and carriage loads during knitting experiments.',
        );

        const workLight = new THREE.PointLight(0xc0a9ff, 1.5, 5.5);
        workLight.position.set(0.2, 1.3, 0.1);
        group.add(workLight);

        const label = buildLabel('Knitting Research', '#f4e9ff');
        label.position.set(0, 1.1, -0.56);
        label.scale.multiplyScalar(0.42);
        group.add(label);

        return group;
      }

      function populateProductLines() {
        const dais = new THREE.Mesh(
          new THREE.CylinderGeometry(4.2, 4.6, 0.6, 72),
          new THREE.MeshStandardMaterial({
            color: 0x151726,
            roughness: 0.85,
            metalness: 0.2,
          }),
        );
        dais.position.y = 0.3;
        dais.receiveShadow = true;
        dais.castShadow = true;

        const v1cCluster = new THREE.Group();
        v1cCluster.add(dais);
        const v1cAssembly = createV1CAssembly();
        v1cCluster.add(v1cAssembly);
        v1cCluster.userData.name = 'v1c Crochet Cell';
        v1cCluster.userData.roadmap =
          'Launch-ready crochet automation cell with emergency stop, gantry, and tension lab.';
        v1cCluster.userData.selectionScale = 1.0;
        v1cCluster.userData.selectionHeight = 0.32;
        scene.add(v1cCluster);
        productClusters.push(v1cCluster);
        addHoverInfo(
          dais,
          'Central robotics cell — houses the v1c crochet robot and its safety perimeter.',
        );

        const daisGlow = new THREE.PointLight(0x7fa8ff, 1.6, 26.0);
        daisGlow.position.set(0, 4.8, 0);
        v1cCluster.add(daisGlow);

        const clusterDefinitions = [
          {
            name: 'Tension Lab',
            roadmap:
              'Calibrates hall sensors, measures yarn pull force, and tunes servo-driven feed loops.',
            hoverText:
              'Tension lab pedestal — stage load cells and spool fixtures before gantry trials.',
            position: new THREE.Vector3(-6.8, 0, -3.5),
            accentColor: 0x7df0ff,
            hoverColor: 0x21404f,
            buildDisplay: createTensionLabDisplay,
          },
          {
            name: 'Material Prep Pod',
            roadmap:
              'Preps yarn cones, QA scales, and dye lots before the crochet cell loads them.',
            hoverText:
              'Material prep pedestal — organize cones, prep bins, and traceability run cards.',
            position: new THREE.Vector3(-6.4, 0, 3.5),
            accentColor: 0x82ffb2,
            hoverColor: 0x1a3525,
            buildDisplay: createMaterialPrepDisplay,
          },
          {
            name: 'Pattern Studio',
            roadmap:
              'Interactive planner hub translating pattern_cli exports into operator-ready motion previews.',
            hoverText:
              'Pattern studio pedestal — review planner exports and prep automation scripts.',
            position: new THREE.Vector3(7.1, 0, -2.6),
            accentColor: 0xffc47d,
            hoverColor: 0x47331e,
            buildDisplay: createPatternStudioDisplay,
          },
          {
            name: 'v1k Research Rig',
            roadmap:
              'Future knitting-focused platform inheriting motion control and safety architecture.',
            hoverText:
              'v1k research pedestal — staging area for the knitting-focused successor platform.',
            position: new THREE.Vector3(0, 0, 7.2),
            accentColor: 0xc0a9ff,
            hoverColor: 0x3a2d52,
            buildDisplay: createV1KResearchDisplay,
            displayOffset: 0.04,
          },
        ];

        clusterDefinitions.forEach((definition) => {
          const cluster = createPedestalCluster(definition);
          scene.add(cluster);
          productClusters.push(cluster);
        });
      }

      populateProductLines();
      loadPlannerPreviewFromSource();

      function updateRoadmapPanel(title, description) {
        roadmapTitleElement.textContent = title;
        roadmapDescriptionElement.textContent = description;
      }

      function selectCluster(cluster) {
        if (!cluster) {
          activeCluster = null;
          selectionRingGroup.visible = false;
          updateRoadmapPanel(
            'Assembly Roadmap',
            'Select a product cluster to learn how it advances the automation journey.',
          );
          desiredCameraTarget.copy(defaultCameraTarget);
          desiredCameraPosition.copy(defaultCameraPosition);
          return;
        }

        if (activeCluster === cluster) {
          return;
        }

        activeCluster = cluster;
        selectionRingGroup.visible = true;
        const targetScale = cluster.userData.selectionScale ?? 1;
        selectionRingGroup.scale.setScalar(targetScale);
        const targetHeight = cluster.userData.selectionHeight ?? selectionRingHeight;
        selectionRingGroup.position.set(
          cluster.position.x,
          targetHeight,
          cluster.position.z,
        );
        if (selectionSweep) {
          selectionSweep.rotation.y = 0;
        }
        updateRoadmapPanel(cluster.userData.name, cluster.userData.roadmap);

        cluster.getWorldPosition(clusterFocusPosition);
        const baseFocusHeight = cluster.userData.selectionHeight ?? selectionRingHeight;
        const focusHeight = baseFocusHeight + 0.8;
        desiredCameraTarget.set(
          clusterFocusPosition.x,
          clusterFocusPosition.y + focusHeight,
          clusterFocusPosition.z,
        );

        cameraOffsetVector.copy(camera.position).sub(currentCameraTarget);
        let offsetLength = cameraOffsetVector.length();
        if (!Number.isFinite(offsetLength) || offsetLength < 1e-3) {
          cameraOffsetVector.copy(defaultCameraOffset);
          offsetLength = cameraOffsetVector.length();
        }
        if (offsetLength < minCameraRadius) {
          cameraOffsetVector.setLength(minCameraRadius);
        } else if (offsetLength > maxCameraRadius) {
          cameraOffsetVector.setLength(maxCameraRadius);
        }
        candidateCameraPosition.copy(desiredCameraTarget).add(cameraOffsetVector);
        candidateCameraPosition.y = Math.max(
          candidateCameraPosition.y,
          desiredCameraTarget.y + 3,
        );
        desiredCameraPosition.copy(candidateCameraPosition);
      }

      if (productClusters.length > 0) {
        selectCluster(productClusters[0]);
      }

      function setPointerFromEvent(event) {
        const bounds = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
        pointer.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
      }

      function findClusterFromObject(object) {
        let current = object;
        while (current) {
          if (current.userData && current.userData.roadmap) {
            return current;
          }
          current = current.parent;
        }
        return null;
      }

      const clock = new THREE.Clock();

      function animate() {
        const delta = clock.getDelta();
        const elapsed = clock.elapsedTime;
        scene.traverse((object) => {
          if (object.name === 'v1c-assembly') {
            object.rotation.y = Math.sin(elapsed * 0.15) * 0.15;
          }
        });
        safeAccessHighlights.forEach((highlight) => {
          const {
            material,
            baseIntensity = 0,
            amplitude = 0,
            speed = 1,
            phaseOffset = 0,
            baseOpacity,
            opacityAmplitude = 0,
            visibleOnly = false,
            object = null,
          } = highlight;
          if (!material) {
            return;
          }
          const isActive = !visibleOnly || (object ? object.visible : true);
          const intensityBase = isActive ? baseIntensity : 0;
          const intensityAmplitude = isActive ? amplitude : 0;
          if (typeof material.emissiveIntensity === 'number') {
            const emissivePulse =
              intensityBase + Math.sin(elapsed * speed + phaseOffset) * intensityAmplitude;
            material.emissiveIntensity = Math.max(0, emissivePulse);
          }
          if (
            typeof baseOpacity === 'number' &&
            typeof material.opacity === 'number' &&
            material.transparent
          ) {
            const opacityBase = isActive ? baseOpacity : 0;
            const opacityAmp = isActive ? opacityAmplitude : 0;
            const opacityPulse =
              opacityBase + Math.sin(elapsed * speed + phaseOffset) * opacityAmp;
            material.opacity = THREE.MathUtils.clamp(opacityPulse, 0, 1);
          }
        });
        anchorPulseControllers.forEach((controller) => {
          const {
            capMaterial,
            haloMaterial,
            halo,
            light,
            baseCapIntensity = 0,
            capAmplitude = 0,
            baseHaloIntensity = 0,
            haloAmplitude = 0,
            baseHaloOpacity,
            haloOpacityAmplitude = 0,
            haloScaleAmplitude = 0,
            baseLightIntensity = 0,
            lightAmplitude = 0,
            phaseOffset = 0,
            speed = 0.22,
          } = controller;

          const angle = (elapsed * speed + phaseOffset) * Math.PI * 2;
          const normalized = 0.5 + 0.5 * Math.sin(angle);
          const emphasis = normalized * normalized;

          if (capMaterial && typeof capMaterial.emissiveIntensity === 'number') {
            capMaterial.emissiveIntensity = Math.max(
              0,
              baseCapIntensity + capAmplitude * emphasis,
            );
          }

          if (haloMaterial && typeof haloMaterial.emissiveIntensity === 'number') {
            haloMaterial.emissiveIntensity = Math.max(
              0,
              baseHaloIntensity + haloAmplitude * emphasis,
            );

            if (typeof baseHaloOpacity === 'number' && haloMaterial.transparent) {
              const opacityPulse = THREE.MathUtils.clamp(
                baseHaloOpacity + haloOpacityAmplitude * (emphasis - 0.5),
                0,
                1,
              );
              haloMaterial.opacity = opacityPulse;
            }
          }

          if (halo) {
            const scale = 1 + haloScaleAmplitude * emphasis;
            halo.scale.setScalar(scale);
          }

          if (light) {
            light.intensity = baseLightIntensity + lightAmplitude * emphasis;
          }
        });
        stepBadgeControllers.forEach((controller) => {
          const {
            badge,
            baseHeight = 0.5,
            amplitude = 0.05,
            speed = 1.6,
            phaseOffset = 0,
            baseTilt = 0,
            tiltAmplitude = 0,
          } = controller;
          if (!badge) {
            return;
          }
          const verticalOffset = Math.sin(elapsed * speed + phaseOffset) * amplitude;
          badge.position.y = baseHeight + verticalOffset;

          if (tiltAmplitude !== 0) {
            const tilt = baseTilt + Math.sin(elapsed * speed * 0.85 + phaseOffset) * tiltAmplitude;
            badge.rotation.x = tilt;
          }
        });
        yarnFlowControllers.forEach((controller) => {
          if (!controller.texture || !controller.material) {
            return;
          }
          controller.texture.offset.x = (controller.texture.offset.x + delta * controller.speed) % 1;
          const target = yarnExtrusionActive
            ? controller.activeIntensity
            : controller.restIntensity;
          controller.currentIntensity = THREE.MathUtils.damp(
            controller.currentIntensity,
            target,
            4.0,
            delta,
          );
          controller.material.emissiveIntensity = controller.currentIntensity;
        });
        yarnPulseControllers.forEach((controller) => {
          const {
            mesh,
            material,
            curve,
            activeSpeed = 0.18,
            idleSpeed = 0.05,
            offset = 0,
            restIntensity = 0.2,
            activeIntensity = 0.8,
            restOpacity = 0.3,
            activeOpacity = 0.9,
            point,
          } = controller;
          if (!mesh || !material || !curve) {
            return;
          }

          const speed = yarnExtrusionActive ? activeSpeed : idleSpeed;
          const travel = (offset + elapsed * speed) % 1;
          if (point) {
            curve.getPointAt(travel, point);
            mesh.position.copy(point);
          } else {
            const position = curve.getPointAt(travel);
            mesh.position.copy(position);
          }

          const target = yarnExtrusionActive ? activeIntensity : restIntensity;
          controller.currentIntensity = THREE.MathUtils.damp(
            controller.currentIntensity ?? restIntensity,
            target,
            4.5,
            delta,
          );
          material.emissiveIntensity = controller.currentIntensity;

          const intensitySpan = Math.max(activeIntensity - restIntensity, 1e-5);
          const normalized = THREE.MathUtils.clamp(
            (controller.currentIntensity - restIntensity) / intensitySpan,
            0,
            1,
          );
          material.opacity = THREE.MathUtils.lerp(restOpacity, activeOpacity, normalized);
        });
        yarnBeadControllers.forEach((controller) => {
          const {
            mesh,
            material,
            curve,
            activeSpeed = 0.36,
            idleSpeed = 0.05,
            restIntensity = 0,
            activeIntensity = 1.2,
            restOpacity = 0,
            activeOpacity = 0.9,
            point,
          } = controller;
          if (!mesh || !material || !curve) {
            return;
          }

          const speed = yarnExtrusionActive ? activeSpeed : idleSpeed;
          const currentTravel = typeof controller.travel === 'number' ? controller.travel : 0;
          const updatedTravel = (currentTravel + delta * speed) % 1;
          controller.travel = updatedTravel;

          if (point) {
            curve.getPointAt(updatedTravel, point);
            mesh.position.copy(point);
          } else {
            const position = curve.getPointAt(updatedTravel);
            mesh.position.copy(position);
          }

          const targetIntensity = yarnExtrusionActive ? activeIntensity : restIntensity;
          controller.currentIntensity = THREE.MathUtils.damp(
            controller.currentIntensity ?? restIntensity,
            targetIntensity,
            6.0,
            delta,
          );
          material.emissiveIntensity = controller.currentIntensity;

          const targetOpacity = yarnExtrusionActive ? activeOpacity : restOpacity;
          controller.currentOpacity = THREE.MathUtils.damp(
            controller.currentOpacity ?? restOpacity,
            targetOpacity,
            6.0,
            delta,
          );
          material.opacity = controller.currentOpacity;
          mesh.visible = material.opacity > 0.02;
        });
        spoolControllers.forEach((controller) => {
          const {
            mesh,
            axis = 'x',
            idleSpeed = 0,
            activeSpeed = idleSpeed,
            linkedToExtrusion = false,
            direction = 1,
            damping = 6.0,
          } = controller;
          if (!mesh) {
            return;
          }
          const isActive = linkedToExtrusion ? yarnExtrusionActive : true;
          const targetSpeed = isActive ? activeSpeed : idleSpeed;
          const currentSpeed = THREE.MathUtils.damp(
            controller.currentSpeed ?? 0,
            targetSpeed,
            damping,
            delta,
          );
          controller.currentSpeed = currentSpeed;
          if (currentSpeed === 0) {
            return;
          }
          const rotationDelta = delta * currentSpeed * direction;
          if (axis === 'y') {
            mesh.rotation.y += rotationDelta;
          } else if (axis === 'z') {
            mesh.rotation.z += rotationDelta;
          } else {
            mesh.rotateX(rotationDelta);
          }
        });
        servoActuatorControllers.forEach((controller) => {
          const { pivot, restAngle = 0, activeAngle = 0, damping = 6.0 } = controller;
          if (!pivot) {
            return;
          }
          const targetAngle = yarnExtrusionActive ? activeAngle : restAngle;
          const currentAngle = THREE.MathUtils.damp(
            controller.currentAngle ?? pivot.rotation.y,
            targetAngle,
            damping,
            delta,
          );
          controller.currentAngle = currentAngle;
          pivot.rotation.y = currentAngle;
        });
        servoSignalControllers.forEach((controller) => {
          const {
            material,
            restIntensity = 0.3,
            activeIntensity = 1.0,
            restOpacity = controller.restOpacity ?? material?.opacity ?? 1,
            activeOpacity = controller.activeOpacity ?? controller.restOpacity ?? material?.opacity ?? 1,
            damping = 5.0,
          } = controller;
          if (!material) {
            return;
          }
          const targetIntensity = yarnExtrusionActive ? activeIntensity : restIntensity;
          controller.currentIntensity = THREE.MathUtils.damp(
            controller.currentIntensity ?? targetIntensity,
            targetIntensity,
            damping,
            delta,
          );
          material.emissiveIntensity = controller.currentIntensity;

          if (typeof material.opacity === 'number') {
            const targetOpacity = yarnExtrusionActive ? activeOpacity : restOpacity;
            controller.currentOpacity = THREE.MathUtils.damp(
              controller.currentOpacity ?? targetOpacity,
              targetOpacity,
              damping,
              delta,
            );
            material.opacity = controller.currentOpacity;
            material.transparent = true;
          }
        });
        if (selectionRingGroup.visible && selectionSweep) {
          selectionSweep.rotation.y =
            (selectionSweep.rotation.y + delta * selectionSweepSpeed) % (Math.PI * 2);
        }
        updatePatternPreview(elapsed);

        if (!userIsControllingCamera) {
          currentCameraTarget.x = THREE.MathUtils.damp(
            currentCameraTarget.x,
            desiredCameraTarget.x,
            cameraMoveDamping,
            delta,
          );
          currentCameraTarget.y = THREE.MathUtils.damp(
            currentCameraTarget.y,
            desiredCameraTarget.y,
            cameraMoveDamping,
            delta,
          );
          currentCameraTarget.z = THREE.MathUtils.damp(
            currentCameraTarget.z,
            desiredCameraTarget.z,
            cameraMoveDamping,
            delta,
          );

          camera.position.x = THREE.MathUtils.damp(
            camera.position.x,
            desiredCameraPosition.x,
            cameraMoveDamping,
            delta,
          );
          camera.position.y = THREE.MathUtils.damp(
            camera.position.y,
            desiredCameraPosition.y,
            cameraMoveDamping,
            delta,
          );
          camera.position.z = THREE.MathUtils.damp(
            camera.position.z,
            desiredCameraPosition.z,
            cameraMoveDamping,
            delta,
          );

          controls.target.copy(currentCameraTarget);
        } else {
          currentCameraTarget.copy(controls.target);
        }

        controls.update();
        renderer.render(scene, camera);
      }

      renderer.setAnimationLoop(animate);

      function updateStatus(message) {
        statusElement.textContent = message;
      }

      function onPointerMove(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(interactiveMeshes, false);
        if (intersects.length > 0) {
          const target =
            intersects.find((hit) => !hit.object.userData.hoverPassthrough) || intersects[0];
          updateStatus(target.object.userData.hoverText || '');
        } else {
          updateStatus('Ready for the next Wove product line…');
        }
      }

      window.addEventListener('pointermove', onPointerMove);

      function onPointerDown(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length === 0) {
          return;
        }

        const targetHit = intersects.find((entry) => findClusterFromObject(entry.object));
        if (!targetHit) {
          return;
        }

        const cluster = findClusterFromObject(targetHit.object);
        if (cluster) {
          selectCluster(cluster);
        }
      }

      window.addEventListener('pointerdown', onPointerDown);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      updateStatus('Ready for the next Wove product line…');
    </script>
  </body>
</html>
