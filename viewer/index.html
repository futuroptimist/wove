<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Wove Product Assembly Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: dark;
        font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at top, #1e1f2f, #0b0c13);
        color: #f5f5f5;
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      #overlay {
        position: fixed;
        top: 1.5rem;
        left: 1.5rem;
        max-width: 22rem;
        padding: 1.25rem 1.5rem;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        border-radius: 0.75rem;
        backdrop-filter: blur(8px);
        box-shadow: 0 0.75rem 2rem rgba(0, 0, 0, 0.35);
      }

      #overlay h1 {
        margin: 0 0 0.5rem;
        font-size: 1.35rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      #overlay p {
        margin: 0 0 0.75rem;
        font-size: 0.95rem;
        line-height: 1.4;
      }

      #overlay ul {
        margin: 0;
        padding-left: 1.1rem;
        font-size: 0.9rem;
        line-height: 1.35;
      }

      #roadmap-panel {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(245, 245, 245, 0.15);
      }

      #roadmap-panel h2 {
        margin: 0 0 0.4rem;
        font-size: 1rem;
        letter-spacing: 0.03em;
        text-transform: uppercase;
        color: #9bb7ff;
      }

      #roadmap-panel p {
        margin: 0;
        font-size: 0.9rem;
        line-height: 1.4;
        color: #e5e7ff;
      }

      #status {
        position: fixed;
        bottom: 1.2rem;
        left: 50%;
        transform: translateX(-50%);
        padding: 0.5rem 0.85rem;
        border-radius: 999px;
        background: rgba(17, 18, 32, 0.8);
        border: 1px solid rgba(245, 245, 245, 0.2);
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }

      @media (max-width: 780px) {
        #overlay {
          left: 50%;
          transform: translateX(-50%);
          width: calc(100% - 3rem);
        }
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <h1>Wove Assembly</h1>
      <p>
        Explore the evolving assembly line for Wove robotics. Start with
        <strong>v1c</strong>, our first crochet robot, and imagine where future
        models will slot in as the roadmap expands.
      </p>
      <ul>
        <li>Drag to orbit, scroll to zoom, right-click to pan.</li>
        <li>Hover a component to read about its function.</li>
        <li>
          Check back often—new Codex tasks will iterate on this experience over
          time.
        </li>
        <li>Click a pedestal to spotlight its roadmap milestone.</li>
      </ul>
      <div id="roadmap-panel">
        <h2 id="roadmap-title">Assembly Roadmap</h2>
        <p id="roadmap-description">
          Select a product cluster to learn how it advances the automation journey.
        </p>
      </div>
    </div>
    <div id="status">Initializing viewer…</div>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c13);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        500,
      );
      camera.position.set(12, 8, 18);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 60;
      controls.maxPolarAngle = Math.PI * 0.49;

      const ambientLight = new THREE.AmbientLight(0xbac4ff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xf1f3ff, 1.2);
      keyLight.position.set(10, 16, 10);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x6c79ff, 0.6);
      fillLight.position.set(-6, 12, -12);
      scene.add(fillLight);

      const groundGeometry = new THREE.CircleGeometry(16, 64);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x131421,
        roughness: 0.85,
        metalness: 0.2,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(32, 32, 0x2e3a68, 0x1d233c);
      scene.add(gridHelper);

      const selectionRingGeometry = new THREE.RingGeometry(3.45, 3.8, 64);
      const selectionRingMaterial = new THREE.MeshBasicMaterial({
        color: 0x8ab4ff,
        transparent: true,
        opacity: 0.45,
        side: THREE.DoubleSide,
      });
      const selectionRing = new THREE.Mesh(selectionRingGeometry, selectionRingMaterial);
      selectionRing.rotation.x = -Math.PI / 2;
      selectionRing.position.y = 0.02;
      selectionRing.visible = false;
      scene.add(selectionRing);

      function buildLabel(text, color = '#f5f5f5') {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const padding = 32;
        const fontSize = 56;
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        const metrics = context.measureText(text);
        canvas.width = metrics.width + padding * 2;
        canvas.height = fontSize + padding * 1.4;

        context.fillStyle = 'rgba(12, 13, 25, 0.8)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.strokeStyle = 'rgba(245, 245, 245, 0.35)';
        context.lineWidth = 4;
        context.strokeRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = color;
        context.textBaseline = 'middle';
        context.textAlign = 'center';
        context.font = `${fontSize}px "Segoe UI", sans-serif`;
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        const baseScale = 0.02;
        sprite.scale.set(canvas.width * baseScale, canvas.height * baseScale, 1);
        return sprite;
      }

      function addHoverInfo(mesh, text) {
        mesh.userData.hoverText = text;
        interactiveMeshes.push(mesh);
      }

      function createV1CAssembly() {
        const group = new THREE.Group();
        group.name = 'v1c-assembly';

        const chassisMaterial = new THREE.MeshStandardMaterial({
          color: 0x5a9bff,
          metalness: 0.35,
          roughness: 0.4,
        });
        const chassis = new THREE.Mesh(
          new THREE.BoxGeometry(6, 0.8, 4),
          chassisMaterial,
        );
        chassis.position.y = 0.4;
        chassis.castShadow = true;
        chassis.receiveShadow = true;
        group.add(chassis);
        addHoverInfo(
          chassis,
          'v1c base platform — houses the drive electronics and bed alignment rails.',
        );

        const gantryMaterial = new THREE.MeshStandardMaterial({
          color: 0xffc857,
          metalness: 0.2,
          roughness: 0.3,
          emissive: 0x332400,
        });
        const gantry = new THREE.Mesh(new THREE.BoxGeometry(0.6, 4.5, 6.5), gantryMaterial);
        gantry.position.set(0, 2.75, 0.35);
        gantry.castShadow = true;
        group.add(gantry);
        addHoverInfo(
          gantry,
          'Dual-axis gantry lifts the crocheting effector while guiding yarn tension.',
        );

        const effectorMaterial = new THREE.MeshStandardMaterial({
          color: 0xff6f91,
          roughness: 0.35,
          metalness: 0.15,
          emissive: 0x401220,
        });
        const effector = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.6, 2.2, 32), effectorMaterial);
        effector.rotation.z = Math.PI / 2;
        effector.position.set(1.8, 2.4, 0.6);
        effector.castShadow = true;
        group.add(effector);
        addHoverInfo(
          effector,
          'Crochet effector: hooks yarn, executes stitch choreography, and measures tension.',
        );

        const spoolMaterial = new THREE.MeshStandardMaterial({
          color: 0xd1d5ff,
          metalness: 0.1,
          roughness: 0.6,
        });
        const spool = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 2.8, 32), spoolMaterial);
        spool.position.set(-2.4, 2.1, -1.6);
        spool.rotation.z = Math.PI / 2;
        spool.castShadow = true;
        group.add(spool);
        addHoverInfo(
          spool,
          'Yarn management module: active tensioning keeps stitches uniform throughout runs.',
        );

        const displayLabel = buildLabel('v1c – Crochet Robot', '#8ab4ff');
        displayLabel.position.set(0, 4.3, 0);
        group.add(displayLabel);

        return group;
      }

      const productLines = [
        {
          id: 'v1c',
          name: 'v1c Crochet Robot',
          position: new THREE.Vector3(0, 0, 0),
          builder: createV1CAssembly,
          roadmap: 'First production crochet robot. Establishes assembly reference for future lines.',
        },
      ];

      const interactiveMeshes = [];
      const productClusters = [];

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const statusElement = document.getElementById('status');
      const roadmapTitleElement = document.getElementById('roadmap-title');
      const roadmapDescriptionElement = document.getElementById('roadmap-description');
      const selectionRingHeight = selectionRing.position.y;

      let activeCluster = null;

      function populateProductLines() {
        productLines.forEach((product, index) => {
          const cluster = new THREE.Group();
          cluster.position.copy(product.position);
          cluster.userData.name = product.name;
          cluster.userData.roadmap = product.roadmap;

          const assembly = product.builder();
          cluster.add(assembly);

          const plinthGeometry = new THREE.CylinderGeometry(3.2, 3.6, 0.5, 48);
          const plinthMaterial = new THREE.MeshStandardMaterial({
            color: index === 0 ? 0x29304b : 0x1a1d2b,
            metalness: 0.15,
            roughness: 0.7,
          });
          const plinth = new THREE.Mesh(plinthGeometry, plinthMaterial);
          plinth.position.y = 0.25;
          plinth.receiveShadow = true;
          cluster.add(plinth);
          addHoverInfo(
            plinth,
            `${product.name} pedestal — staging zone for module calibration and QA checks.`,
          );

          scene.add(cluster);
          productClusters.push(cluster);
        });
      }

      populateProductLines();

      function updateRoadmapPanel(title, description) {
        roadmapTitleElement.textContent = title;
        roadmapDescriptionElement.textContent = description;
      }

      function selectCluster(cluster) {
        if (!cluster) {
          activeCluster = null;
          selectionRing.visible = false;
          updateRoadmapPanel(
            'Assembly Roadmap',
            'Select a product cluster to learn how it advances the automation journey.',
          );
          return;
        }

        if (activeCluster === cluster) {
          return;
        }

        activeCluster = cluster;
        selectionRing.visible = true;
        selectionRing.position.set(cluster.position.x, selectionRingHeight, cluster.position.z);
        updateRoadmapPanel(cluster.userData.name, cluster.userData.roadmap);
      }

      if (productClusters.length > 0) {
        selectCluster(productClusters[0]);
      }

      function setPointerFromEvent(event) {
        const bounds = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
        pointer.y = -((event.clientY - bounds.top) / bounds.height) * 2 + 1;
      }

      function findClusterFromObject(object) {
        let current = object;
        while (current) {
          if (current.userData && current.userData.roadmap) {
            return current;
          }
          current = current.parent;
        }
        return null;
      }

      const clock = new THREE.Clock();

      function animate() {
        const elapsed = clock.getElapsedTime();
        scene.traverse((object) => {
          if (object.name === 'v1c-assembly') {
            object.rotation.y = Math.sin(elapsed * 0.15) * 0.15;
          }
        });

        controls.update();
        renderer.render(scene, camera);
      }

      renderer.setAnimationLoop(animate);

      function updateStatus(message) {
        statusElement.textContent = message;
      }

      function onPointerMove(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(interactiveMeshes, false);
        if (intersects.length > 0) {
          updateStatus(intersects[0].object.userData.hoverText || '');
        } else {
          updateStatus('Ready for the next Wove product line…');
        }
      }

      window.addEventListener('pointermove', onPointerMove);

      function onPointerDown(event) {
        setPointerFromEvent(event);

        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        if (intersects.length === 0) {
          return;
        }

        const cluster = findClusterFromObject(intersects[0].object);
        if (cluster) {
          selectCluster(cluster);
        }
      }

      window.addEventListener('pointerdown', onPointerDown);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      updateStatus('Ready for the next Wove product line…');
    </script>
  </body>
</html>
